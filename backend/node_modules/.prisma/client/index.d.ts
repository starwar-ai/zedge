
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Tenant
 * 
 */
export type Tenant = $Result.DefaultSelection<Prisma.$TenantPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model UserGroup
 * 
 */
export type UserGroup = $Result.DefaultSelection<Prisma.$UserGroupPayload>
/**
 * Model UserGroupMember
 * 
 */
export type UserGroupMember = $Result.DefaultSelection<Prisma.$UserGroupMemberPayload>
/**
 * Model Permission
 * 
 */
export type Permission = $Result.DefaultSelection<Prisma.$PermissionPayload>
/**
 * Model RolePermission
 * 
 */
export type RolePermission = $Result.DefaultSelection<Prisma.$RolePermissionPayload>
/**
 * Model Instance
 * 
 */
export type Instance = $Result.DefaultSelection<Prisma.$InstancePayload>
/**
 * Model PrivateDataDisk
 * 
 */
export type PrivateDataDisk = $Result.DefaultSelection<Prisma.$PrivateDataDiskPayload>
/**
 * Model Vpc
 * 
 */
export type Vpc = $Result.DefaultSelection<Prisma.$VpcPayload>
/**
 * Model Place
 * 
 */
export type Place = $Result.DefaultSelection<Prisma.$PlacePayload>
/**
 * Model Subnet
 * 
 */
export type Subnet = $Result.DefaultSelection<Prisma.$SubnetPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const TenantStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  SUSPENDED: 'SUSPENDED'
};

export type TenantStatus = (typeof TenantStatus)[keyof typeof TenantStatus]


export const UserRole: {
  ADMIN: 'ADMIN',
  TENANT_ADMIN: 'TENANT_ADMIN',
  OPERATOR: 'OPERATOR',
  USER: 'USER'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const UserStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  LOCKED: 'LOCKED'
};

export type UserStatus = (typeof UserStatus)[keyof typeof UserStatus]


export const ResourceType: {
  TENANT: 'TENANT',
  USER: 'USER',
  USER_GROUP: 'USER_GROUP',
  INSTANCE: 'INSTANCE',
  STORAGE: 'STORAGE',
  NETWORK: 'NETWORK',
  IMAGE: 'IMAGE',
  SERVER: 'SERVER',
  EDGE_DC: 'EDGE_DC',
  PLACE: 'PLACE'
};

export type ResourceType = (typeof ResourceType)[keyof typeof ResourceType]


export const PermissionAction: {
  CREATE: 'CREATE',
  READ: 'READ',
  UPDATE: 'UPDATE',
  DELETE: 'DELETE',
  MANAGE: 'MANAGE',
  EXECUTE: 'EXECUTE'
};

export type PermissionAction = (typeof PermissionAction)[keyof typeof PermissionAction]


export const VpcStatus: {
  ACTIVE: 'ACTIVE',
  DISABLED: 'DISABLED',
  DELETED: 'DELETED'
};

export type VpcStatus = (typeof VpcStatus)[keyof typeof VpcStatus]


export const PlaceStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  DISABLED: 'DISABLED'
};

export type PlaceStatus = (typeof PlaceStatus)[keyof typeof PlaceStatus]


export const SubnetStatus: {
  ACTIVE: 'ACTIVE',
  DISABLED: 'DISABLED'
};

export type SubnetStatus = (typeof SubnetStatus)[keyof typeof SubnetStatus]

}

export type TenantStatus = $Enums.TenantStatus

export const TenantStatus: typeof $Enums.TenantStatus

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type UserStatus = $Enums.UserStatus

export const UserStatus: typeof $Enums.UserStatus

export type ResourceType = $Enums.ResourceType

export const ResourceType: typeof $Enums.ResourceType

export type PermissionAction = $Enums.PermissionAction

export const PermissionAction: typeof $Enums.PermissionAction

export type VpcStatus = $Enums.VpcStatus

export const VpcStatus: typeof $Enums.VpcStatus

export type PlaceStatus = $Enums.PlaceStatus

export const PlaceStatus: typeof $Enums.PlaceStatus

export type SubnetStatus = $Enums.SubnetStatus

export const SubnetStatus: typeof $Enums.SubnetStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Tenants
 * const tenants = await prisma.tenant.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Tenants
   * const tenants = await prisma.tenant.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.tenant`: Exposes CRUD operations for the **Tenant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tenants
    * const tenants = await prisma.tenant.findMany()
    * ```
    */
  get tenant(): Prisma.TenantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userGroup`: Exposes CRUD operations for the **UserGroup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserGroups
    * const userGroups = await prisma.userGroup.findMany()
    * ```
    */
  get userGroup(): Prisma.UserGroupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userGroupMember`: Exposes CRUD operations for the **UserGroupMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserGroupMembers
    * const userGroupMembers = await prisma.userGroupMember.findMany()
    * ```
    */
  get userGroupMember(): Prisma.UserGroupMemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.permission`: Exposes CRUD operations for the **Permission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Permissions
    * const permissions = await prisma.permission.findMany()
    * ```
    */
  get permission(): Prisma.PermissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rolePermission`: Exposes CRUD operations for the **RolePermission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RolePermissions
    * const rolePermissions = await prisma.rolePermission.findMany()
    * ```
    */
  get rolePermission(): Prisma.RolePermissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.instance`: Exposes CRUD operations for the **Instance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Instances
    * const instances = await prisma.instance.findMany()
    * ```
    */
  get instance(): Prisma.InstanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.privateDataDisk`: Exposes CRUD operations for the **PrivateDataDisk** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PrivateDataDisks
    * const privateDataDisks = await prisma.privateDataDisk.findMany()
    * ```
    */
  get privateDataDisk(): Prisma.PrivateDataDiskDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vpc`: Exposes CRUD operations for the **Vpc** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vpcs
    * const vpcs = await prisma.vpc.findMany()
    * ```
    */
  get vpc(): Prisma.VpcDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.place`: Exposes CRUD operations for the **Place** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Places
    * const places = await prisma.place.findMany()
    * ```
    */
  get place(): Prisma.PlaceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subnet`: Exposes CRUD operations for the **Subnet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subnets
    * const subnets = await prisma.subnet.findMany()
    * ```
    */
  get subnet(): Prisma.SubnetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.18.0
   * Query Engine version: 34b5a692b7bd79939a9a2c3ef97d816e749cda2f
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Tenant: 'Tenant',
    User: 'User',
    UserGroup: 'UserGroup',
    UserGroupMember: 'UserGroupMember',
    Permission: 'Permission',
    RolePermission: 'RolePermission',
    Instance: 'Instance',
    PrivateDataDisk: 'PrivateDataDisk',
    Vpc: 'Vpc',
    Place: 'Place',
    Subnet: 'Subnet',
    AuditLog: 'AuditLog'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "tenant" | "user" | "userGroup" | "userGroupMember" | "permission" | "rolePermission" | "instance" | "privateDataDisk" | "vpc" | "place" | "subnet" | "auditLog"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Tenant: {
        payload: Prisma.$TenantPayload<ExtArgs>
        fields: Prisma.TenantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TenantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TenantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          findFirst: {
            args: Prisma.TenantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TenantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          findMany: {
            args: Prisma.TenantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          create: {
            args: Prisma.TenantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          createMany: {
            args: Prisma.TenantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TenantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          delete: {
            args: Prisma.TenantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          update: {
            args: Prisma.TenantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          deleteMany: {
            args: Prisma.TenantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TenantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TenantUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          upsert: {
            args: Prisma.TenantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          aggregate: {
            args: Prisma.TenantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenant>
          }
          groupBy: {
            args: Prisma.TenantGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenantGroupByOutputType>[]
          }
          count: {
            args: Prisma.TenantCountArgs<ExtArgs>
            result: $Utils.Optional<TenantCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      UserGroup: {
        payload: Prisma.$UserGroupPayload<ExtArgs>
        fields: Prisma.UserGroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserGroupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserGroupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGroupPayload>
          }
          findFirst: {
            args: Prisma.UserGroupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserGroupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGroupPayload>
          }
          findMany: {
            args: Prisma.UserGroupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGroupPayload>[]
          }
          create: {
            args: Prisma.UserGroupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGroupPayload>
          }
          createMany: {
            args: Prisma.UserGroupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserGroupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGroupPayload>[]
          }
          delete: {
            args: Prisma.UserGroupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGroupPayload>
          }
          update: {
            args: Prisma.UserGroupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGroupPayload>
          }
          deleteMany: {
            args: Prisma.UserGroupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserGroupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserGroupUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGroupPayload>[]
          }
          upsert: {
            args: Prisma.UserGroupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGroupPayload>
          }
          aggregate: {
            args: Prisma.UserGroupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserGroup>
          }
          groupBy: {
            args: Prisma.UserGroupGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserGroupCountArgs<ExtArgs>
            result: $Utils.Optional<UserGroupCountAggregateOutputType> | number
          }
        }
      }
      UserGroupMember: {
        payload: Prisma.$UserGroupMemberPayload<ExtArgs>
        fields: Prisma.UserGroupMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserGroupMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGroupMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserGroupMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGroupMemberPayload>
          }
          findFirst: {
            args: Prisma.UserGroupMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGroupMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserGroupMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGroupMemberPayload>
          }
          findMany: {
            args: Prisma.UserGroupMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGroupMemberPayload>[]
          }
          create: {
            args: Prisma.UserGroupMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGroupMemberPayload>
          }
          createMany: {
            args: Prisma.UserGroupMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserGroupMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGroupMemberPayload>[]
          }
          delete: {
            args: Prisma.UserGroupMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGroupMemberPayload>
          }
          update: {
            args: Prisma.UserGroupMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGroupMemberPayload>
          }
          deleteMany: {
            args: Prisma.UserGroupMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserGroupMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserGroupMemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGroupMemberPayload>[]
          }
          upsert: {
            args: Prisma.UserGroupMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGroupMemberPayload>
          }
          aggregate: {
            args: Prisma.UserGroupMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserGroupMember>
          }
          groupBy: {
            args: Prisma.UserGroupMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserGroupMemberCountArgs<ExtArgs>
            result: $Utils.Optional<UserGroupMemberCountAggregateOutputType> | number
          }
        }
      }
      Permission: {
        payload: Prisma.$PermissionPayload<ExtArgs>
        fields: Prisma.PermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findFirst: {
            args: Prisma.PermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findMany: {
            args: Prisma.PermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          create: {
            args: Prisma.PermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          createMany: {
            args: Prisma.PermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          delete: {
            args: Prisma.PermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          update: {
            args: Prisma.PermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          deleteMany: {
            args: Prisma.PermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PermissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          upsert: {
            args: Prisma.PermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          aggregate: {
            args: Prisma.PermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePermission>
          }
          groupBy: {
            args: Prisma.PermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PermissionCountArgs<ExtArgs>
            result: $Utils.Optional<PermissionCountAggregateOutputType> | number
          }
        }
      }
      RolePermission: {
        payload: Prisma.$RolePermissionPayload<ExtArgs>
        fields: Prisma.RolePermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RolePermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RolePermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          findFirst: {
            args: Prisma.RolePermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RolePermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          findMany: {
            args: Prisma.RolePermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>[]
          }
          create: {
            args: Prisma.RolePermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          createMany: {
            args: Prisma.RolePermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RolePermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>[]
          }
          delete: {
            args: Prisma.RolePermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          update: {
            args: Prisma.RolePermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          deleteMany: {
            args: Prisma.RolePermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RolePermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RolePermissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>[]
          }
          upsert: {
            args: Prisma.RolePermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          aggregate: {
            args: Prisma.RolePermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRolePermission>
          }
          groupBy: {
            args: Prisma.RolePermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<RolePermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.RolePermissionCountArgs<ExtArgs>
            result: $Utils.Optional<RolePermissionCountAggregateOutputType> | number
          }
        }
      }
      Instance: {
        payload: Prisma.$InstancePayload<ExtArgs>
        fields: Prisma.InstanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InstanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InstanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstancePayload>
          }
          findFirst: {
            args: Prisma.InstanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InstanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstancePayload>
          }
          findMany: {
            args: Prisma.InstanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstancePayload>[]
          }
          create: {
            args: Prisma.InstanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstancePayload>
          }
          createMany: {
            args: Prisma.InstanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InstanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstancePayload>[]
          }
          delete: {
            args: Prisma.InstanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstancePayload>
          }
          update: {
            args: Prisma.InstanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstancePayload>
          }
          deleteMany: {
            args: Prisma.InstanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InstanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InstanceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstancePayload>[]
          }
          upsert: {
            args: Prisma.InstanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstancePayload>
          }
          aggregate: {
            args: Prisma.InstanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInstance>
          }
          groupBy: {
            args: Prisma.InstanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<InstanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.InstanceCountArgs<ExtArgs>
            result: $Utils.Optional<InstanceCountAggregateOutputType> | number
          }
        }
      }
      PrivateDataDisk: {
        payload: Prisma.$PrivateDataDiskPayload<ExtArgs>
        fields: Prisma.PrivateDataDiskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PrivateDataDiskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateDataDiskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PrivateDataDiskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateDataDiskPayload>
          }
          findFirst: {
            args: Prisma.PrivateDataDiskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateDataDiskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PrivateDataDiskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateDataDiskPayload>
          }
          findMany: {
            args: Prisma.PrivateDataDiskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateDataDiskPayload>[]
          }
          create: {
            args: Prisma.PrivateDataDiskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateDataDiskPayload>
          }
          createMany: {
            args: Prisma.PrivateDataDiskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PrivateDataDiskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateDataDiskPayload>[]
          }
          delete: {
            args: Prisma.PrivateDataDiskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateDataDiskPayload>
          }
          update: {
            args: Prisma.PrivateDataDiskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateDataDiskPayload>
          }
          deleteMany: {
            args: Prisma.PrivateDataDiskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PrivateDataDiskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PrivateDataDiskUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateDataDiskPayload>[]
          }
          upsert: {
            args: Prisma.PrivateDataDiskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateDataDiskPayload>
          }
          aggregate: {
            args: Prisma.PrivateDataDiskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrivateDataDisk>
          }
          groupBy: {
            args: Prisma.PrivateDataDiskGroupByArgs<ExtArgs>
            result: $Utils.Optional<PrivateDataDiskGroupByOutputType>[]
          }
          count: {
            args: Prisma.PrivateDataDiskCountArgs<ExtArgs>
            result: $Utils.Optional<PrivateDataDiskCountAggregateOutputType> | number
          }
        }
      }
      Vpc: {
        payload: Prisma.$VpcPayload<ExtArgs>
        fields: Prisma.VpcFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VpcFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VpcPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VpcFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VpcPayload>
          }
          findFirst: {
            args: Prisma.VpcFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VpcPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VpcFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VpcPayload>
          }
          findMany: {
            args: Prisma.VpcFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VpcPayload>[]
          }
          create: {
            args: Prisma.VpcCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VpcPayload>
          }
          createMany: {
            args: Prisma.VpcCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VpcCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VpcPayload>[]
          }
          delete: {
            args: Prisma.VpcDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VpcPayload>
          }
          update: {
            args: Prisma.VpcUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VpcPayload>
          }
          deleteMany: {
            args: Prisma.VpcDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VpcUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VpcUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VpcPayload>[]
          }
          upsert: {
            args: Prisma.VpcUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VpcPayload>
          }
          aggregate: {
            args: Prisma.VpcAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVpc>
          }
          groupBy: {
            args: Prisma.VpcGroupByArgs<ExtArgs>
            result: $Utils.Optional<VpcGroupByOutputType>[]
          }
          count: {
            args: Prisma.VpcCountArgs<ExtArgs>
            result: $Utils.Optional<VpcCountAggregateOutputType> | number
          }
        }
      }
      Place: {
        payload: Prisma.$PlacePayload<ExtArgs>
        fields: Prisma.PlaceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlaceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlaceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacePayload>
          }
          findFirst: {
            args: Prisma.PlaceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlaceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacePayload>
          }
          findMany: {
            args: Prisma.PlaceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacePayload>[]
          }
          create: {
            args: Prisma.PlaceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacePayload>
          }
          createMany: {
            args: Prisma.PlaceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlaceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacePayload>[]
          }
          delete: {
            args: Prisma.PlaceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacePayload>
          }
          update: {
            args: Prisma.PlaceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacePayload>
          }
          deleteMany: {
            args: Prisma.PlaceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlaceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlaceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacePayload>[]
          }
          upsert: {
            args: Prisma.PlaceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacePayload>
          }
          aggregate: {
            args: Prisma.PlaceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlace>
          }
          groupBy: {
            args: Prisma.PlaceGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlaceGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlaceCountArgs<ExtArgs>
            result: $Utils.Optional<PlaceCountAggregateOutputType> | number
          }
        }
      }
      Subnet: {
        payload: Prisma.$SubnetPayload<ExtArgs>
        fields: Prisma.SubnetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubnetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubnetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubnetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubnetPayload>
          }
          findFirst: {
            args: Prisma.SubnetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubnetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubnetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubnetPayload>
          }
          findMany: {
            args: Prisma.SubnetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubnetPayload>[]
          }
          create: {
            args: Prisma.SubnetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubnetPayload>
          }
          createMany: {
            args: Prisma.SubnetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubnetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubnetPayload>[]
          }
          delete: {
            args: Prisma.SubnetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubnetPayload>
          }
          update: {
            args: Prisma.SubnetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubnetPayload>
          }
          deleteMany: {
            args: Prisma.SubnetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubnetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubnetUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubnetPayload>[]
          }
          upsert: {
            args: Prisma.SubnetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubnetPayload>
          }
          aggregate: {
            args: Prisma.SubnetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubnet>
          }
          groupBy: {
            args: Prisma.SubnetGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubnetGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubnetCountArgs<ExtArgs>
            result: $Utils.Optional<SubnetCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    tenant?: TenantOmit
    user?: UserOmit
    userGroup?: UserGroupOmit
    userGroupMember?: UserGroupMemberOmit
    permission?: PermissionOmit
    rolePermission?: RolePermissionOmit
    instance?: InstanceOmit
    privateDataDisk?: PrivateDataDiskOmit
    vpc?: VpcOmit
    place?: PlaceOmit
    subnet?: SubnetOmit
    auditLog?: AuditLogOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type TenantCountOutputType
   */

  export type TenantCountOutputType = {
    users: number
    userGroups: number
    instances: number
    privateDataDisks: number
    vpcs: number
    places: number
  }

  export type TenantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | TenantCountOutputTypeCountUsersArgs
    userGroups?: boolean | TenantCountOutputTypeCountUserGroupsArgs
    instances?: boolean | TenantCountOutputTypeCountInstancesArgs
    privateDataDisks?: boolean | TenantCountOutputTypeCountPrivateDataDisksArgs
    vpcs?: boolean | TenantCountOutputTypeCountVpcsArgs
    places?: boolean | TenantCountOutputTypeCountPlacesArgs
  }

  // Custom InputTypes
  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantCountOutputType
     */
    select?: TenantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountUserGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserGroupWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountInstancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstanceWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountPrivateDataDisksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrivateDataDiskWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountVpcsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VpcWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountPlacesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlaceWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    groupMemberships: number
    instances: number
    privateDataDisks: number
    createdTenants: number
    vpcs: number
    createdVpcs: number
    updatedVpcs: number
    createdPlaces: number
    updatedPlaces: number
    createdSubnets: number
    updatedSubnets: number
    auditLogs: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    groupMemberships?: boolean | UserCountOutputTypeCountGroupMembershipsArgs
    instances?: boolean | UserCountOutputTypeCountInstancesArgs
    privateDataDisks?: boolean | UserCountOutputTypeCountPrivateDataDisksArgs
    createdTenants?: boolean | UserCountOutputTypeCountCreatedTenantsArgs
    vpcs?: boolean | UserCountOutputTypeCountVpcsArgs
    createdVpcs?: boolean | UserCountOutputTypeCountCreatedVpcsArgs
    updatedVpcs?: boolean | UserCountOutputTypeCountUpdatedVpcsArgs
    createdPlaces?: boolean | UserCountOutputTypeCountCreatedPlacesArgs
    updatedPlaces?: boolean | UserCountOutputTypeCountUpdatedPlacesArgs
    createdSubnets?: boolean | UserCountOutputTypeCountCreatedSubnetsArgs
    updatedSubnets?: boolean | UserCountOutputTypeCountUpdatedSubnetsArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGroupMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserGroupMemberWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInstancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstanceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPrivateDataDisksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrivateDataDiskWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedTenantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountVpcsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VpcWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedVpcsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VpcWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUpdatedVpcsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VpcWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedPlacesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlaceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUpdatedPlacesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlaceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedSubnetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubnetWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUpdatedSubnetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubnetWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }


  /**
   * Count Type UserGroupCountOutputType
   */

  export type UserGroupCountOutputType = {
    childGroups: number
    members: number
  }

  export type UserGroupCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    childGroups?: boolean | UserGroupCountOutputTypeCountChildGroupsArgs
    members?: boolean | UserGroupCountOutputTypeCountMembersArgs
  }

  // Custom InputTypes
  /**
   * UserGroupCountOutputType without action
   */
  export type UserGroupCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGroupCountOutputType
     */
    select?: UserGroupCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserGroupCountOutputType without action
   */
  export type UserGroupCountOutputTypeCountChildGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserGroupWhereInput
  }

  /**
   * UserGroupCountOutputType without action
   */
  export type UserGroupCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserGroupMemberWhereInput
  }


  /**
   * Count Type PermissionCountOutputType
   */

  export type PermissionCountOutputType = {
    rolePermissions: number
  }

  export type PermissionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rolePermissions?: boolean | PermissionCountOutputTypeCountRolePermissionsArgs
  }

  // Custom InputTypes
  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionCountOutputType
     */
    select?: PermissionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeCountRolePermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionWhereInput
  }


  /**
   * Count Type VpcCountOutputType
   */

  export type VpcCountOutputType = {
    subnets: number
  }

  export type VpcCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subnets?: boolean | VpcCountOutputTypeCountSubnetsArgs
  }

  // Custom InputTypes
  /**
   * VpcCountOutputType without action
   */
  export type VpcCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VpcCountOutputType
     */
    select?: VpcCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VpcCountOutputType without action
   */
  export type VpcCountOutputTypeCountSubnetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubnetWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Tenant
   */

  export type AggregateTenant = {
    _count: TenantCountAggregateOutputType | null
    _avg: TenantAvgAggregateOutputType | null
    _sum: TenantSumAggregateOutputType | null
    _min: TenantMinAggregateOutputType | null
    _max: TenantMaxAggregateOutputType | null
  }

  export type TenantAvgAggregateOutputType = {
    vlanId: number | null
  }

  export type TenantSumAggregateOutputType = {
    vlanId: number | null
  }

  export type TenantMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    status: $Enums.TenantStatus | null
    adminUserId: string | null
    vlanId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
  }

  export type TenantMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    status: $Enums.TenantStatus | null
    adminUserId: string | null
    vlanId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
  }

  export type TenantCountAggregateOutputType = {
    id: number
    name: number
    description: number
    status: number
    adminUserId: number
    vlanId: number
    quotaConfig: number
    createdAt: number
    updatedAt: number
    createdBy: number
    _all: number
  }


  export type TenantAvgAggregateInputType = {
    vlanId?: true
  }

  export type TenantSumAggregateInputType = {
    vlanId?: true
  }

  export type TenantMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    adminUserId?: true
    vlanId?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
  }

  export type TenantMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    adminUserId?: true
    vlanId?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
  }

  export type TenantCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    adminUserId?: true
    vlanId?: true
    quotaConfig?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    _all?: true
  }

  export type TenantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenant to aggregate.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tenants
    **/
    _count?: true | TenantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TenantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TenantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenantMaxAggregateInputType
  }

  export type GetTenantAggregateType<T extends TenantAggregateArgs> = {
        [P in keyof T & keyof AggregateTenant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenant[P]>
      : GetScalarType<T[P], AggregateTenant[P]>
  }




  export type TenantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantWhereInput
    orderBy?: TenantOrderByWithAggregationInput | TenantOrderByWithAggregationInput[]
    by: TenantScalarFieldEnum[] | TenantScalarFieldEnum
    having?: TenantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenantCountAggregateInputType | true
    _avg?: TenantAvgAggregateInputType
    _sum?: TenantSumAggregateInputType
    _min?: TenantMinAggregateInputType
    _max?: TenantMaxAggregateInputType
  }

  export type TenantGroupByOutputType = {
    id: string
    name: string
    description: string | null
    status: $Enums.TenantStatus
    adminUserId: string | null
    vlanId: number | null
    quotaConfig: JsonValue | null
    createdAt: Date
    updatedAt: Date
    createdBy: string | null
    _count: TenantCountAggregateOutputType | null
    _avg: TenantAvgAggregateOutputType | null
    _sum: TenantSumAggregateOutputType | null
    _min: TenantMinAggregateOutputType | null
    _max: TenantMaxAggregateOutputType | null
  }

  type GetTenantGroupByPayload<T extends TenantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenantGroupByOutputType[P]>
            : GetScalarType<T[P], TenantGroupByOutputType[P]>
        }
      >
    >


  export type TenantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    adminUserId?: boolean
    vlanId?: boolean
    quotaConfig?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    users?: boolean | Tenant$usersArgs<ExtArgs>
    userGroups?: boolean | Tenant$userGroupsArgs<ExtArgs>
    instances?: boolean | Tenant$instancesArgs<ExtArgs>
    privateDataDisks?: boolean | Tenant$privateDataDisksArgs<ExtArgs>
    vpcs?: boolean | Tenant$vpcsArgs<ExtArgs>
    places?: boolean | Tenant$placesArgs<ExtArgs>
    creator?: boolean | Tenant$creatorArgs<ExtArgs>
    _count?: boolean | TenantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    adminUserId?: boolean
    vlanId?: boolean
    quotaConfig?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    creator?: boolean | Tenant$creatorArgs<ExtArgs>
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    adminUserId?: boolean
    vlanId?: boolean
    quotaConfig?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    creator?: boolean | Tenant$creatorArgs<ExtArgs>
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    adminUserId?: boolean
    vlanId?: boolean
    quotaConfig?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
  }

  export type TenantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "status" | "adminUserId" | "vlanId" | "quotaConfig" | "createdAt" | "updatedAt" | "createdBy", ExtArgs["result"]["tenant"]>
  export type TenantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Tenant$usersArgs<ExtArgs>
    userGroups?: boolean | Tenant$userGroupsArgs<ExtArgs>
    instances?: boolean | Tenant$instancesArgs<ExtArgs>
    privateDataDisks?: boolean | Tenant$privateDataDisksArgs<ExtArgs>
    vpcs?: boolean | Tenant$vpcsArgs<ExtArgs>
    places?: boolean | Tenant$placesArgs<ExtArgs>
    creator?: boolean | Tenant$creatorArgs<ExtArgs>
    _count?: boolean | TenantCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TenantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | Tenant$creatorArgs<ExtArgs>
  }
  export type TenantIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | Tenant$creatorArgs<ExtArgs>
  }

  export type $TenantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tenant"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      userGroups: Prisma.$UserGroupPayload<ExtArgs>[]
      instances: Prisma.$InstancePayload<ExtArgs>[]
      privateDataDisks: Prisma.$PrivateDataDiskPayload<ExtArgs>[]
      vpcs: Prisma.$VpcPayload<ExtArgs>[]
      places: Prisma.$PlacePayload<ExtArgs>[]
      creator: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      status: $Enums.TenantStatus
      adminUserId: string | null
      vlanId: number | null
      quotaConfig: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
      createdBy: string | null
    }, ExtArgs["result"]["tenant"]>
    composites: {}
  }

  type TenantGetPayload<S extends boolean | null | undefined | TenantDefaultArgs> = $Result.GetResult<Prisma.$TenantPayload, S>

  type TenantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TenantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TenantCountAggregateInputType | true
    }

  export interface TenantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tenant'], meta: { name: 'Tenant' } }
    /**
     * Find zero or one Tenant that matches the filter.
     * @param {TenantFindUniqueArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TenantFindUniqueArgs>(args: SelectSubset<T, TenantFindUniqueArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tenant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TenantFindUniqueOrThrowArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TenantFindUniqueOrThrowArgs>(args: SelectSubset<T, TenantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tenant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindFirstArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TenantFindFirstArgs>(args?: SelectSubset<T, TenantFindFirstArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tenant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindFirstOrThrowArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TenantFindFirstOrThrowArgs>(args?: SelectSubset<T, TenantFindFirstOrThrowArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tenants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tenants
     * const tenants = await prisma.tenant.findMany()
     * 
     * // Get first 10 Tenants
     * const tenants = await prisma.tenant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tenantWithIdOnly = await prisma.tenant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TenantFindManyArgs>(args?: SelectSubset<T, TenantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tenant.
     * @param {TenantCreateArgs} args - Arguments to create a Tenant.
     * @example
     * // Create one Tenant
     * const Tenant = await prisma.tenant.create({
     *   data: {
     *     // ... data to create a Tenant
     *   }
     * })
     * 
     */
    create<T extends TenantCreateArgs>(args: SelectSubset<T, TenantCreateArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tenants.
     * @param {TenantCreateManyArgs} args - Arguments to create many Tenants.
     * @example
     * // Create many Tenants
     * const tenant = await prisma.tenant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TenantCreateManyArgs>(args?: SelectSubset<T, TenantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tenants and returns the data saved in the database.
     * @param {TenantCreateManyAndReturnArgs} args - Arguments to create many Tenants.
     * @example
     * // Create many Tenants
     * const tenant = await prisma.tenant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tenants and only return the `id`
     * const tenantWithIdOnly = await prisma.tenant.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TenantCreateManyAndReturnArgs>(args?: SelectSubset<T, TenantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tenant.
     * @param {TenantDeleteArgs} args - Arguments to delete one Tenant.
     * @example
     * // Delete one Tenant
     * const Tenant = await prisma.tenant.delete({
     *   where: {
     *     // ... filter to delete one Tenant
     *   }
     * })
     * 
     */
    delete<T extends TenantDeleteArgs>(args: SelectSubset<T, TenantDeleteArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tenant.
     * @param {TenantUpdateArgs} args - Arguments to update one Tenant.
     * @example
     * // Update one Tenant
     * const tenant = await prisma.tenant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TenantUpdateArgs>(args: SelectSubset<T, TenantUpdateArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tenants.
     * @param {TenantDeleteManyArgs} args - Arguments to filter Tenants to delete.
     * @example
     * // Delete a few Tenants
     * const { count } = await prisma.tenant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TenantDeleteManyArgs>(args?: SelectSubset<T, TenantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tenants
     * const tenant = await prisma.tenant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TenantUpdateManyArgs>(args: SelectSubset<T, TenantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tenants and returns the data updated in the database.
     * @param {TenantUpdateManyAndReturnArgs} args - Arguments to update many Tenants.
     * @example
     * // Update many Tenants
     * const tenant = await prisma.tenant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tenants and only return the `id`
     * const tenantWithIdOnly = await prisma.tenant.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TenantUpdateManyAndReturnArgs>(args: SelectSubset<T, TenantUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tenant.
     * @param {TenantUpsertArgs} args - Arguments to update or create a Tenant.
     * @example
     * // Update or create a Tenant
     * const tenant = await prisma.tenant.upsert({
     *   create: {
     *     // ... data to create a Tenant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tenant we want to update
     *   }
     * })
     */
    upsert<T extends TenantUpsertArgs>(args: SelectSubset<T, TenantUpsertArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantCountArgs} args - Arguments to filter Tenants to count.
     * @example
     * // Count the number of Tenants
     * const count = await prisma.tenant.count({
     *   where: {
     *     // ... the filter for the Tenants we want to count
     *   }
     * })
    **/
    count<T extends TenantCountArgs>(
      args?: Subset<T, TenantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenantAggregateArgs>(args: Subset<T, TenantAggregateArgs>): Prisma.PrismaPromise<GetTenantAggregateType<T>>

    /**
     * Group by Tenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TenantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TenantGroupByArgs['orderBy'] }
        : { orderBy?: TenantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TenantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tenant model
   */
  readonly fields: TenantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tenant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TenantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Tenant$usersArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userGroups<T extends Tenant$userGroupsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$userGroupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    instances<T extends Tenant$instancesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$instancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    privateDataDisks<T extends Tenant$privateDataDisksArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$privateDataDisksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrivateDataDiskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    vpcs<T extends Tenant$vpcsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$vpcsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VpcPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    places<T extends Tenant$placesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$placesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlacePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    creator<T extends Tenant$creatorArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$creatorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tenant model
   */
  interface TenantFieldRefs {
    readonly id: FieldRef<"Tenant", 'String'>
    readonly name: FieldRef<"Tenant", 'String'>
    readonly description: FieldRef<"Tenant", 'String'>
    readonly status: FieldRef<"Tenant", 'TenantStatus'>
    readonly adminUserId: FieldRef<"Tenant", 'String'>
    readonly vlanId: FieldRef<"Tenant", 'Int'>
    readonly quotaConfig: FieldRef<"Tenant", 'Json'>
    readonly createdAt: FieldRef<"Tenant", 'DateTime'>
    readonly updatedAt: FieldRef<"Tenant", 'DateTime'>
    readonly createdBy: FieldRef<"Tenant", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Tenant findUnique
   */
  export type TenantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant findUniqueOrThrow
   */
  export type TenantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant findFirst
   */
  export type TenantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenants.
     */
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant findFirstOrThrow
   */
  export type TenantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenants.
     */
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant findMany
   */
  export type TenantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenants to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant create
   */
  export type TenantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The data needed to create a Tenant.
     */
    data: XOR<TenantCreateInput, TenantUncheckedCreateInput>
  }

  /**
   * Tenant createMany
   */
  export type TenantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tenants.
     */
    data: TenantCreateManyInput | TenantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tenant createManyAndReturn
   */
  export type TenantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * The data used to create many Tenants.
     */
    data: TenantCreateManyInput | TenantCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tenant update
   */
  export type TenantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The data needed to update a Tenant.
     */
    data: XOR<TenantUpdateInput, TenantUncheckedUpdateInput>
    /**
     * Choose, which Tenant to update.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant updateMany
   */
  export type TenantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tenants.
     */
    data: XOR<TenantUpdateManyMutationInput, TenantUncheckedUpdateManyInput>
    /**
     * Filter which Tenants to update
     */
    where?: TenantWhereInput
    /**
     * Limit how many Tenants to update.
     */
    limit?: number
  }

  /**
   * Tenant updateManyAndReturn
   */
  export type TenantUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * The data used to update Tenants.
     */
    data: XOR<TenantUpdateManyMutationInput, TenantUncheckedUpdateManyInput>
    /**
     * Filter which Tenants to update
     */
    where?: TenantWhereInput
    /**
     * Limit how many Tenants to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tenant upsert
   */
  export type TenantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The filter to search for the Tenant to update in case it exists.
     */
    where: TenantWhereUniqueInput
    /**
     * In case the Tenant found by the `where` argument doesn't exist, create a new Tenant with this data.
     */
    create: XOR<TenantCreateInput, TenantUncheckedCreateInput>
    /**
     * In case the Tenant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TenantUpdateInput, TenantUncheckedUpdateInput>
  }

  /**
   * Tenant delete
   */
  export type TenantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter which Tenant to delete.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant deleteMany
   */
  export type TenantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenants to delete
     */
    where?: TenantWhereInput
    /**
     * Limit how many Tenants to delete.
     */
    limit?: number
  }

  /**
   * Tenant.users
   */
  export type Tenant$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Tenant.userGroups
   */
  export type Tenant$userGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGroup
     */
    select?: UserGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserGroup
     */
    omit?: UserGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGroupInclude<ExtArgs> | null
    where?: UserGroupWhereInput
    orderBy?: UserGroupOrderByWithRelationInput | UserGroupOrderByWithRelationInput[]
    cursor?: UserGroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserGroupScalarFieldEnum | UserGroupScalarFieldEnum[]
  }

  /**
   * Tenant.instances
   */
  export type Tenant$instancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instance
     */
    select?: InstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instance
     */
    omit?: InstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstanceInclude<ExtArgs> | null
    where?: InstanceWhereInput
    orderBy?: InstanceOrderByWithRelationInput | InstanceOrderByWithRelationInput[]
    cursor?: InstanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InstanceScalarFieldEnum | InstanceScalarFieldEnum[]
  }

  /**
   * Tenant.privateDataDisks
   */
  export type Tenant$privateDataDisksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateDataDisk
     */
    select?: PrivateDataDiskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateDataDisk
     */
    omit?: PrivateDataDiskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateDataDiskInclude<ExtArgs> | null
    where?: PrivateDataDiskWhereInput
    orderBy?: PrivateDataDiskOrderByWithRelationInput | PrivateDataDiskOrderByWithRelationInput[]
    cursor?: PrivateDataDiskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PrivateDataDiskScalarFieldEnum | PrivateDataDiskScalarFieldEnum[]
  }

  /**
   * Tenant.vpcs
   */
  export type Tenant$vpcsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vpc
     */
    select?: VpcSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vpc
     */
    omit?: VpcOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VpcInclude<ExtArgs> | null
    where?: VpcWhereInput
    orderBy?: VpcOrderByWithRelationInput | VpcOrderByWithRelationInput[]
    cursor?: VpcWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VpcScalarFieldEnum | VpcScalarFieldEnum[]
  }

  /**
   * Tenant.places
   */
  export type Tenant$placesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Place
     */
    select?: PlaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Place
     */
    omit?: PlaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceInclude<ExtArgs> | null
    where?: PlaceWhereInput
    orderBy?: PlaceOrderByWithRelationInput | PlaceOrderByWithRelationInput[]
    cursor?: PlaceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlaceScalarFieldEnum | PlaceScalarFieldEnum[]
  }

  /**
   * Tenant.creator
   */
  export type Tenant$creatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Tenant without action
   */
  export type TenantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    username: string | null
    email: string | null
    passwordHash: string | null
    role: $Enums.UserRole | null
    status: $Enums.UserStatus | null
    tenantId: string | null
    lastLoginAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    username: string | null
    email: string | null
    passwordHash: string | null
    role: $Enums.UserRole | null
    status: $Enums.UserStatus | null
    tenantId: string | null
    lastLoginAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    username: number
    email: number
    passwordHash: number
    role: number
    status: number
    tenantId: number
    quotaConfig: number
    lastLoginAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    username?: true
    email?: true
    passwordHash?: true
    role?: true
    status?: true
    tenantId?: true
    lastLoginAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    username?: true
    email?: true
    passwordHash?: true
    role?: true
    status?: true
    tenantId?: true
    lastLoginAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    username?: true
    email?: true
    passwordHash?: true
    role?: true
    status?: true
    tenantId?: true
    quotaConfig?: true
    lastLoginAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    username: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    status: $Enums.UserStatus
    tenantId: string | null
    quotaConfig: JsonValue | null
    lastLoginAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    passwordHash?: boolean
    role?: boolean
    status?: boolean
    tenantId?: boolean
    quotaConfig?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | User$tenantArgs<ExtArgs>
    groupMemberships?: boolean | User$groupMembershipsArgs<ExtArgs>
    instances?: boolean | User$instancesArgs<ExtArgs>
    privateDataDisks?: boolean | User$privateDataDisksArgs<ExtArgs>
    createdTenants?: boolean | User$createdTenantsArgs<ExtArgs>
    vpcs?: boolean | User$vpcsArgs<ExtArgs>
    createdVpcs?: boolean | User$createdVpcsArgs<ExtArgs>
    updatedVpcs?: boolean | User$updatedVpcsArgs<ExtArgs>
    createdPlaces?: boolean | User$createdPlacesArgs<ExtArgs>
    updatedPlaces?: boolean | User$updatedPlacesArgs<ExtArgs>
    createdSubnets?: boolean | User$createdSubnetsArgs<ExtArgs>
    updatedSubnets?: boolean | User$updatedSubnetsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    passwordHash?: boolean
    role?: boolean
    status?: boolean
    tenantId?: boolean
    quotaConfig?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | User$tenantArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    passwordHash?: boolean
    role?: boolean
    status?: boolean
    tenantId?: boolean
    quotaConfig?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | User$tenantArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    username?: boolean
    email?: boolean
    passwordHash?: boolean
    role?: boolean
    status?: boolean
    tenantId?: boolean
    quotaConfig?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "username" | "email" | "passwordHash" | "role" | "status" | "tenantId" | "quotaConfig" | "lastLoginAt" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | User$tenantArgs<ExtArgs>
    groupMemberships?: boolean | User$groupMembershipsArgs<ExtArgs>
    instances?: boolean | User$instancesArgs<ExtArgs>
    privateDataDisks?: boolean | User$privateDataDisksArgs<ExtArgs>
    createdTenants?: boolean | User$createdTenantsArgs<ExtArgs>
    vpcs?: boolean | User$vpcsArgs<ExtArgs>
    createdVpcs?: boolean | User$createdVpcsArgs<ExtArgs>
    updatedVpcs?: boolean | User$updatedVpcsArgs<ExtArgs>
    createdPlaces?: boolean | User$createdPlacesArgs<ExtArgs>
    updatedPlaces?: boolean | User$updatedPlacesArgs<ExtArgs>
    createdSubnets?: boolean | User$createdSubnetsArgs<ExtArgs>
    updatedSubnets?: boolean | User$updatedSubnetsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | User$tenantArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | User$tenantArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs> | null
      groupMemberships: Prisma.$UserGroupMemberPayload<ExtArgs>[]
      instances: Prisma.$InstancePayload<ExtArgs>[]
      privateDataDisks: Prisma.$PrivateDataDiskPayload<ExtArgs>[]
      createdTenants: Prisma.$TenantPayload<ExtArgs>[]
      vpcs: Prisma.$VpcPayload<ExtArgs>[]
      createdVpcs: Prisma.$VpcPayload<ExtArgs>[]
      updatedVpcs: Prisma.$VpcPayload<ExtArgs>[]
      createdPlaces: Prisma.$PlacePayload<ExtArgs>[]
      updatedPlaces: Prisma.$PlacePayload<ExtArgs>[]
      createdSubnets: Prisma.$SubnetPayload<ExtArgs>[]
      updatedSubnets: Prisma.$SubnetPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      username: string
      email: string
      passwordHash: string
      role: $Enums.UserRole
      status: $Enums.UserStatus
      tenantId: string | null
      quotaConfig: Prisma.JsonValue | null
      lastLoginAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends User$tenantArgs<ExtArgs> = {}>(args?: Subset<T, User$tenantArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    groupMemberships<T extends User$groupMembershipsArgs<ExtArgs> = {}>(args?: Subset<T, User$groupMembershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserGroupMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    instances<T extends User$instancesArgs<ExtArgs> = {}>(args?: Subset<T, User$instancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    privateDataDisks<T extends User$privateDataDisksArgs<ExtArgs> = {}>(args?: Subset<T, User$privateDataDisksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrivateDataDiskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdTenants<T extends User$createdTenantsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdTenantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    vpcs<T extends User$vpcsArgs<ExtArgs> = {}>(args?: Subset<T, User$vpcsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VpcPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdVpcs<T extends User$createdVpcsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdVpcsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VpcPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    updatedVpcs<T extends User$updatedVpcsArgs<ExtArgs> = {}>(args?: Subset<T, User$updatedVpcsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VpcPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdPlaces<T extends User$createdPlacesArgs<ExtArgs> = {}>(args?: Subset<T, User$createdPlacesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlacePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    updatedPlaces<T extends User$updatedPlacesArgs<ExtArgs> = {}>(args?: Subset<T, User$updatedPlacesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlacePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdSubnets<T extends User$createdSubnetsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdSubnetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubnetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    updatedSubnets<T extends User$updatedSubnetsArgs<ExtArgs> = {}>(args?: Subset<T, User$updatedSubnetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubnetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly status: FieldRef<"User", 'UserStatus'>
    readonly tenantId: FieldRef<"User", 'String'>
    readonly quotaConfig: FieldRef<"User", 'Json'>
    readonly lastLoginAt: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.tenant
   */
  export type User$tenantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    where?: TenantWhereInput
  }

  /**
   * User.groupMemberships
   */
  export type User$groupMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGroupMember
     */
    select?: UserGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserGroupMember
     */
    omit?: UserGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGroupMemberInclude<ExtArgs> | null
    where?: UserGroupMemberWhereInput
    orderBy?: UserGroupMemberOrderByWithRelationInput | UserGroupMemberOrderByWithRelationInput[]
    cursor?: UserGroupMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserGroupMemberScalarFieldEnum | UserGroupMemberScalarFieldEnum[]
  }

  /**
   * User.instances
   */
  export type User$instancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instance
     */
    select?: InstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instance
     */
    omit?: InstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstanceInclude<ExtArgs> | null
    where?: InstanceWhereInput
    orderBy?: InstanceOrderByWithRelationInput | InstanceOrderByWithRelationInput[]
    cursor?: InstanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InstanceScalarFieldEnum | InstanceScalarFieldEnum[]
  }

  /**
   * User.privateDataDisks
   */
  export type User$privateDataDisksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateDataDisk
     */
    select?: PrivateDataDiskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateDataDisk
     */
    omit?: PrivateDataDiskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateDataDiskInclude<ExtArgs> | null
    where?: PrivateDataDiskWhereInput
    orderBy?: PrivateDataDiskOrderByWithRelationInput | PrivateDataDiskOrderByWithRelationInput[]
    cursor?: PrivateDataDiskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PrivateDataDiskScalarFieldEnum | PrivateDataDiskScalarFieldEnum[]
  }

  /**
   * User.createdTenants
   */
  export type User$createdTenantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    where?: TenantWhereInput
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    cursor?: TenantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * User.vpcs
   */
  export type User$vpcsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vpc
     */
    select?: VpcSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vpc
     */
    omit?: VpcOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VpcInclude<ExtArgs> | null
    where?: VpcWhereInput
    orderBy?: VpcOrderByWithRelationInput | VpcOrderByWithRelationInput[]
    cursor?: VpcWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VpcScalarFieldEnum | VpcScalarFieldEnum[]
  }

  /**
   * User.createdVpcs
   */
  export type User$createdVpcsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vpc
     */
    select?: VpcSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vpc
     */
    omit?: VpcOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VpcInclude<ExtArgs> | null
    where?: VpcWhereInput
    orderBy?: VpcOrderByWithRelationInput | VpcOrderByWithRelationInput[]
    cursor?: VpcWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VpcScalarFieldEnum | VpcScalarFieldEnum[]
  }

  /**
   * User.updatedVpcs
   */
  export type User$updatedVpcsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vpc
     */
    select?: VpcSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vpc
     */
    omit?: VpcOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VpcInclude<ExtArgs> | null
    where?: VpcWhereInput
    orderBy?: VpcOrderByWithRelationInput | VpcOrderByWithRelationInput[]
    cursor?: VpcWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VpcScalarFieldEnum | VpcScalarFieldEnum[]
  }

  /**
   * User.createdPlaces
   */
  export type User$createdPlacesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Place
     */
    select?: PlaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Place
     */
    omit?: PlaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceInclude<ExtArgs> | null
    where?: PlaceWhereInput
    orderBy?: PlaceOrderByWithRelationInput | PlaceOrderByWithRelationInput[]
    cursor?: PlaceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlaceScalarFieldEnum | PlaceScalarFieldEnum[]
  }

  /**
   * User.updatedPlaces
   */
  export type User$updatedPlacesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Place
     */
    select?: PlaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Place
     */
    omit?: PlaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceInclude<ExtArgs> | null
    where?: PlaceWhereInput
    orderBy?: PlaceOrderByWithRelationInput | PlaceOrderByWithRelationInput[]
    cursor?: PlaceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlaceScalarFieldEnum | PlaceScalarFieldEnum[]
  }

  /**
   * User.createdSubnets
   */
  export type User$createdSubnetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subnet
     */
    select?: SubnetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subnet
     */
    omit?: SubnetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubnetInclude<ExtArgs> | null
    where?: SubnetWhereInput
    orderBy?: SubnetOrderByWithRelationInput | SubnetOrderByWithRelationInput[]
    cursor?: SubnetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubnetScalarFieldEnum | SubnetScalarFieldEnum[]
  }

  /**
   * User.updatedSubnets
   */
  export type User$updatedSubnetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subnet
     */
    select?: SubnetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subnet
     */
    omit?: SubnetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubnetInclude<ExtArgs> | null
    where?: SubnetWhereInput
    orderBy?: SubnetOrderByWithRelationInput | SubnetOrderByWithRelationInput[]
    cursor?: SubnetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubnetScalarFieldEnum | SubnetScalarFieldEnum[]
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model UserGroup
   */

  export type AggregateUserGroup = {
    _count: UserGroupCountAggregateOutputType | null
    _min: UserGroupMinAggregateOutputType | null
    _max: UserGroupMaxAggregateOutputType | null
  }

  export type UserGroupMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    tenantId: string | null
    parentGroupId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserGroupMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    tenantId: string | null
    parentGroupId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserGroupCountAggregateOutputType = {
    id: number
    name: number
    description: number
    tenantId: number
    parentGroupId: number
    quotaConfig: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserGroupMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    tenantId?: true
    parentGroupId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserGroupMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    tenantId?: true
    parentGroupId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserGroupCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    tenantId?: true
    parentGroupId?: true
    quotaConfig?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserGroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserGroup to aggregate.
     */
    where?: UserGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserGroups to fetch.
     */
    orderBy?: UserGroupOrderByWithRelationInput | UserGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserGroups
    **/
    _count?: true | UserGroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserGroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserGroupMaxAggregateInputType
  }

  export type GetUserGroupAggregateType<T extends UserGroupAggregateArgs> = {
        [P in keyof T & keyof AggregateUserGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserGroup[P]>
      : GetScalarType<T[P], AggregateUserGroup[P]>
  }




  export type UserGroupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserGroupWhereInput
    orderBy?: UserGroupOrderByWithAggregationInput | UserGroupOrderByWithAggregationInput[]
    by: UserGroupScalarFieldEnum[] | UserGroupScalarFieldEnum
    having?: UserGroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserGroupCountAggregateInputType | true
    _min?: UserGroupMinAggregateInputType
    _max?: UserGroupMaxAggregateInputType
  }

  export type UserGroupGroupByOutputType = {
    id: string
    name: string
    description: string | null
    tenantId: string
    parentGroupId: string | null
    quotaConfig: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: UserGroupCountAggregateOutputType | null
    _min: UserGroupMinAggregateOutputType | null
    _max: UserGroupMaxAggregateOutputType | null
  }

  type GetUserGroupGroupByPayload<T extends UserGroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupGroupByOutputType[P]>
        }
      >
    >


  export type UserGroupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    tenantId?: boolean
    parentGroupId?: boolean
    quotaConfig?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    parentGroup?: boolean | UserGroup$parentGroupArgs<ExtArgs>
    childGroups?: boolean | UserGroup$childGroupsArgs<ExtArgs>
    members?: boolean | UserGroup$membersArgs<ExtArgs>
    _count?: boolean | UserGroupCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userGroup"]>

  export type UserGroupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    tenantId?: boolean
    parentGroupId?: boolean
    quotaConfig?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    parentGroup?: boolean | UserGroup$parentGroupArgs<ExtArgs>
  }, ExtArgs["result"]["userGroup"]>

  export type UserGroupSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    tenantId?: boolean
    parentGroupId?: boolean
    quotaConfig?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    parentGroup?: boolean | UserGroup$parentGroupArgs<ExtArgs>
  }, ExtArgs["result"]["userGroup"]>

  export type UserGroupSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    tenantId?: boolean
    parentGroupId?: boolean
    quotaConfig?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserGroupOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "tenantId" | "parentGroupId" | "quotaConfig" | "createdAt" | "updatedAt", ExtArgs["result"]["userGroup"]>
  export type UserGroupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    parentGroup?: boolean | UserGroup$parentGroupArgs<ExtArgs>
    childGroups?: boolean | UserGroup$childGroupsArgs<ExtArgs>
    members?: boolean | UserGroup$membersArgs<ExtArgs>
    _count?: boolean | UserGroupCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserGroupIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    parentGroup?: boolean | UserGroup$parentGroupArgs<ExtArgs>
  }
  export type UserGroupIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    parentGroup?: boolean | UserGroup$parentGroupArgs<ExtArgs>
  }

  export type $UserGroupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserGroup"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      parentGroup: Prisma.$UserGroupPayload<ExtArgs> | null
      childGroups: Prisma.$UserGroupPayload<ExtArgs>[]
      members: Prisma.$UserGroupMemberPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      tenantId: string
      parentGroupId: string | null
      quotaConfig: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userGroup"]>
    composites: {}
  }

  type UserGroupGetPayload<S extends boolean | null | undefined | UserGroupDefaultArgs> = $Result.GetResult<Prisma.$UserGroupPayload, S>

  type UserGroupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserGroupFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserGroupCountAggregateInputType | true
    }

  export interface UserGroupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserGroup'], meta: { name: 'UserGroup' } }
    /**
     * Find zero or one UserGroup that matches the filter.
     * @param {UserGroupFindUniqueArgs} args - Arguments to find a UserGroup
     * @example
     * // Get one UserGroup
     * const userGroup = await prisma.userGroup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserGroupFindUniqueArgs>(args: SelectSubset<T, UserGroupFindUniqueArgs<ExtArgs>>): Prisma__UserGroupClient<$Result.GetResult<Prisma.$UserGroupPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserGroup that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserGroupFindUniqueOrThrowArgs} args - Arguments to find a UserGroup
     * @example
     * // Get one UserGroup
     * const userGroup = await prisma.userGroup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserGroupFindUniqueOrThrowArgs>(args: SelectSubset<T, UserGroupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserGroupClient<$Result.GetResult<Prisma.$UserGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserGroup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupFindFirstArgs} args - Arguments to find a UserGroup
     * @example
     * // Get one UserGroup
     * const userGroup = await prisma.userGroup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserGroupFindFirstArgs>(args?: SelectSubset<T, UserGroupFindFirstArgs<ExtArgs>>): Prisma__UserGroupClient<$Result.GetResult<Prisma.$UserGroupPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserGroup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupFindFirstOrThrowArgs} args - Arguments to find a UserGroup
     * @example
     * // Get one UserGroup
     * const userGroup = await prisma.userGroup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserGroupFindFirstOrThrowArgs>(args?: SelectSubset<T, UserGroupFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserGroupClient<$Result.GetResult<Prisma.$UserGroupPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserGroups
     * const userGroups = await prisma.userGroup.findMany()
     * 
     * // Get first 10 UserGroups
     * const userGroups = await prisma.userGroup.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userGroupWithIdOnly = await prisma.userGroup.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserGroupFindManyArgs>(args?: SelectSubset<T, UserGroupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserGroup.
     * @param {UserGroupCreateArgs} args - Arguments to create a UserGroup.
     * @example
     * // Create one UserGroup
     * const UserGroup = await prisma.userGroup.create({
     *   data: {
     *     // ... data to create a UserGroup
     *   }
     * })
     * 
     */
    create<T extends UserGroupCreateArgs>(args: SelectSubset<T, UserGroupCreateArgs<ExtArgs>>): Prisma__UserGroupClient<$Result.GetResult<Prisma.$UserGroupPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserGroups.
     * @param {UserGroupCreateManyArgs} args - Arguments to create many UserGroups.
     * @example
     * // Create many UserGroups
     * const userGroup = await prisma.userGroup.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserGroupCreateManyArgs>(args?: SelectSubset<T, UserGroupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserGroups and returns the data saved in the database.
     * @param {UserGroupCreateManyAndReturnArgs} args - Arguments to create many UserGroups.
     * @example
     * // Create many UserGroups
     * const userGroup = await prisma.userGroup.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserGroups and only return the `id`
     * const userGroupWithIdOnly = await prisma.userGroup.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserGroupCreateManyAndReturnArgs>(args?: SelectSubset<T, UserGroupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserGroupPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserGroup.
     * @param {UserGroupDeleteArgs} args - Arguments to delete one UserGroup.
     * @example
     * // Delete one UserGroup
     * const UserGroup = await prisma.userGroup.delete({
     *   where: {
     *     // ... filter to delete one UserGroup
     *   }
     * })
     * 
     */
    delete<T extends UserGroupDeleteArgs>(args: SelectSubset<T, UserGroupDeleteArgs<ExtArgs>>): Prisma__UserGroupClient<$Result.GetResult<Prisma.$UserGroupPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserGroup.
     * @param {UserGroupUpdateArgs} args - Arguments to update one UserGroup.
     * @example
     * // Update one UserGroup
     * const userGroup = await prisma.userGroup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserGroupUpdateArgs>(args: SelectSubset<T, UserGroupUpdateArgs<ExtArgs>>): Prisma__UserGroupClient<$Result.GetResult<Prisma.$UserGroupPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserGroups.
     * @param {UserGroupDeleteManyArgs} args - Arguments to filter UserGroups to delete.
     * @example
     * // Delete a few UserGroups
     * const { count } = await prisma.userGroup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserGroupDeleteManyArgs>(args?: SelectSubset<T, UserGroupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserGroups
     * const userGroup = await prisma.userGroup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserGroupUpdateManyArgs>(args: SelectSubset<T, UserGroupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserGroups and returns the data updated in the database.
     * @param {UserGroupUpdateManyAndReturnArgs} args - Arguments to update many UserGroups.
     * @example
     * // Update many UserGroups
     * const userGroup = await prisma.userGroup.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserGroups and only return the `id`
     * const userGroupWithIdOnly = await prisma.userGroup.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserGroupUpdateManyAndReturnArgs>(args: SelectSubset<T, UserGroupUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserGroupPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserGroup.
     * @param {UserGroupUpsertArgs} args - Arguments to update or create a UserGroup.
     * @example
     * // Update or create a UserGroup
     * const userGroup = await prisma.userGroup.upsert({
     *   create: {
     *     // ... data to create a UserGroup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserGroup we want to update
     *   }
     * })
     */
    upsert<T extends UserGroupUpsertArgs>(args: SelectSubset<T, UserGroupUpsertArgs<ExtArgs>>): Prisma__UserGroupClient<$Result.GetResult<Prisma.$UserGroupPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupCountArgs} args - Arguments to filter UserGroups to count.
     * @example
     * // Count the number of UserGroups
     * const count = await prisma.userGroup.count({
     *   where: {
     *     // ... the filter for the UserGroups we want to count
     *   }
     * })
    **/
    count<T extends UserGroupCountArgs>(
      args?: Subset<T, UserGroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserGroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserGroupAggregateArgs>(args: Subset<T, UserGroupAggregateArgs>): Prisma.PrismaPromise<GetUserGroupAggregateType<T>>

    /**
     * Group by UserGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserGroup model
   */
  readonly fields: UserGroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserGroup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserGroupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    parentGroup<T extends UserGroup$parentGroupArgs<ExtArgs> = {}>(args?: Subset<T, UserGroup$parentGroupArgs<ExtArgs>>): Prisma__UserGroupClient<$Result.GetResult<Prisma.$UserGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    childGroups<T extends UserGroup$childGroupsArgs<ExtArgs> = {}>(args?: Subset<T, UserGroup$childGroupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    members<T extends UserGroup$membersArgs<ExtArgs> = {}>(args?: Subset<T, UserGroup$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserGroupMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserGroup model
   */
  interface UserGroupFieldRefs {
    readonly id: FieldRef<"UserGroup", 'String'>
    readonly name: FieldRef<"UserGroup", 'String'>
    readonly description: FieldRef<"UserGroup", 'String'>
    readonly tenantId: FieldRef<"UserGroup", 'String'>
    readonly parentGroupId: FieldRef<"UserGroup", 'String'>
    readonly quotaConfig: FieldRef<"UserGroup", 'Json'>
    readonly createdAt: FieldRef<"UserGroup", 'DateTime'>
    readonly updatedAt: FieldRef<"UserGroup", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserGroup findUnique
   */
  export type UserGroupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGroup
     */
    select?: UserGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserGroup
     */
    omit?: UserGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGroupInclude<ExtArgs> | null
    /**
     * Filter, which UserGroup to fetch.
     */
    where: UserGroupWhereUniqueInput
  }

  /**
   * UserGroup findUniqueOrThrow
   */
  export type UserGroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGroup
     */
    select?: UserGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserGroup
     */
    omit?: UserGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGroupInclude<ExtArgs> | null
    /**
     * Filter, which UserGroup to fetch.
     */
    where: UserGroupWhereUniqueInput
  }

  /**
   * UserGroup findFirst
   */
  export type UserGroupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGroup
     */
    select?: UserGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserGroup
     */
    omit?: UserGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGroupInclude<ExtArgs> | null
    /**
     * Filter, which UserGroup to fetch.
     */
    where?: UserGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserGroups to fetch.
     */
    orderBy?: UserGroupOrderByWithRelationInput | UserGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserGroups.
     */
    cursor?: UserGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserGroups.
     */
    distinct?: UserGroupScalarFieldEnum | UserGroupScalarFieldEnum[]
  }

  /**
   * UserGroup findFirstOrThrow
   */
  export type UserGroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGroup
     */
    select?: UserGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserGroup
     */
    omit?: UserGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGroupInclude<ExtArgs> | null
    /**
     * Filter, which UserGroup to fetch.
     */
    where?: UserGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserGroups to fetch.
     */
    orderBy?: UserGroupOrderByWithRelationInput | UserGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserGroups.
     */
    cursor?: UserGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserGroups.
     */
    distinct?: UserGroupScalarFieldEnum | UserGroupScalarFieldEnum[]
  }

  /**
   * UserGroup findMany
   */
  export type UserGroupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGroup
     */
    select?: UserGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserGroup
     */
    omit?: UserGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGroupInclude<ExtArgs> | null
    /**
     * Filter, which UserGroups to fetch.
     */
    where?: UserGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserGroups to fetch.
     */
    orderBy?: UserGroupOrderByWithRelationInput | UserGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserGroups.
     */
    cursor?: UserGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserGroups.
     */
    skip?: number
    distinct?: UserGroupScalarFieldEnum | UserGroupScalarFieldEnum[]
  }

  /**
   * UserGroup create
   */
  export type UserGroupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGroup
     */
    select?: UserGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserGroup
     */
    omit?: UserGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGroupInclude<ExtArgs> | null
    /**
     * The data needed to create a UserGroup.
     */
    data: XOR<UserGroupCreateInput, UserGroupUncheckedCreateInput>
  }

  /**
   * UserGroup createMany
   */
  export type UserGroupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserGroups.
     */
    data: UserGroupCreateManyInput | UserGroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserGroup createManyAndReturn
   */
  export type UserGroupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGroup
     */
    select?: UserGroupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserGroup
     */
    omit?: UserGroupOmit<ExtArgs> | null
    /**
     * The data used to create many UserGroups.
     */
    data: UserGroupCreateManyInput | UserGroupCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGroupIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserGroup update
   */
  export type UserGroupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGroup
     */
    select?: UserGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserGroup
     */
    omit?: UserGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGroupInclude<ExtArgs> | null
    /**
     * The data needed to update a UserGroup.
     */
    data: XOR<UserGroupUpdateInput, UserGroupUncheckedUpdateInput>
    /**
     * Choose, which UserGroup to update.
     */
    where: UserGroupWhereUniqueInput
  }

  /**
   * UserGroup updateMany
   */
  export type UserGroupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserGroups.
     */
    data: XOR<UserGroupUpdateManyMutationInput, UserGroupUncheckedUpdateManyInput>
    /**
     * Filter which UserGroups to update
     */
    where?: UserGroupWhereInput
    /**
     * Limit how many UserGroups to update.
     */
    limit?: number
  }

  /**
   * UserGroup updateManyAndReturn
   */
  export type UserGroupUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGroup
     */
    select?: UserGroupSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserGroup
     */
    omit?: UserGroupOmit<ExtArgs> | null
    /**
     * The data used to update UserGroups.
     */
    data: XOR<UserGroupUpdateManyMutationInput, UserGroupUncheckedUpdateManyInput>
    /**
     * Filter which UserGroups to update
     */
    where?: UserGroupWhereInput
    /**
     * Limit how many UserGroups to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGroupIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserGroup upsert
   */
  export type UserGroupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGroup
     */
    select?: UserGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserGroup
     */
    omit?: UserGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGroupInclude<ExtArgs> | null
    /**
     * The filter to search for the UserGroup to update in case it exists.
     */
    where: UserGroupWhereUniqueInput
    /**
     * In case the UserGroup found by the `where` argument doesn't exist, create a new UserGroup with this data.
     */
    create: XOR<UserGroupCreateInput, UserGroupUncheckedCreateInput>
    /**
     * In case the UserGroup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserGroupUpdateInput, UserGroupUncheckedUpdateInput>
  }

  /**
   * UserGroup delete
   */
  export type UserGroupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGroup
     */
    select?: UserGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserGroup
     */
    omit?: UserGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGroupInclude<ExtArgs> | null
    /**
     * Filter which UserGroup to delete.
     */
    where: UserGroupWhereUniqueInput
  }

  /**
   * UserGroup deleteMany
   */
  export type UserGroupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserGroups to delete
     */
    where?: UserGroupWhereInput
    /**
     * Limit how many UserGroups to delete.
     */
    limit?: number
  }

  /**
   * UserGroup.parentGroup
   */
  export type UserGroup$parentGroupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGroup
     */
    select?: UserGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserGroup
     */
    omit?: UserGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGroupInclude<ExtArgs> | null
    where?: UserGroupWhereInput
  }

  /**
   * UserGroup.childGroups
   */
  export type UserGroup$childGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGroup
     */
    select?: UserGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserGroup
     */
    omit?: UserGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGroupInclude<ExtArgs> | null
    where?: UserGroupWhereInput
    orderBy?: UserGroupOrderByWithRelationInput | UserGroupOrderByWithRelationInput[]
    cursor?: UserGroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserGroupScalarFieldEnum | UserGroupScalarFieldEnum[]
  }

  /**
   * UserGroup.members
   */
  export type UserGroup$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGroupMember
     */
    select?: UserGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserGroupMember
     */
    omit?: UserGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGroupMemberInclude<ExtArgs> | null
    where?: UserGroupMemberWhereInput
    orderBy?: UserGroupMemberOrderByWithRelationInput | UserGroupMemberOrderByWithRelationInput[]
    cursor?: UserGroupMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserGroupMemberScalarFieldEnum | UserGroupMemberScalarFieldEnum[]
  }

  /**
   * UserGroup without action
   */
  export type UserGroupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGroup
     */
    select?: UserGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserGroup
     */
    omit?: UserGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGroupInclude<ExtArgs> | null
  }


  /**
   * Model UserGroupMember
   */

  export type AggregateUserGroupMember = {
    _count: UserGroupMemberCountAggregateOutputType | null
    _min: UserGroupMemberMinAggregateOutputType | null
    _max: UserGroupMemberMaxAggregateOutputType | null
  }

  export type UserGroupMemberMinAggregateOutputType = {
    id: string | null
    groupId: string | null
    userId: string | null
    joinedAt: Date | null
    addedBy: string | null
  }

  export type UserGroupMemberMaxAggregateOutputType = {
    id: string | null
    groupId: string | null
    userId: string | null
    joinedAt: Date | null
    addedBy: string | null
  }

  export type UserGroupMemberCountAggregateOutputType = {
    id: number
    groupId: number
    userId: number
    joinedAt: number
    addedBy: number
    _all: number
  }


  export type UserGroupMemberMinAggregateInputType = {
    id?: true
    groupId?: true
    userId?: true
    joinedAt?: true
    addedBy?: true
  }

  export type UserGroupMemberMaxAggregateInputType = {
    id?: true
    groupId?: true
    userId?: true
    joinedAt?: true
    addedBy?: true
  }

  export type UserGroupMemberCountAggregateInputType = {
    id?: true
    groupId?: true
    userId?: true
    joinedAt?: true
    addedBy?: true
    _all?: true
  }

  export type UserGroupMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserGroupMember to aggregate.
     */
    where?: UserGroupMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserGroupMembers to fetch.
     */
    orderBy?: UserGroupMemberOrderByWithRelationInput | UserGroupMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserGroupMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserGroupMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserGroupMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserGroupMembers
    **/
    _count?: true | UserGroupMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserGroupMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserGroupMemberMaxAggregateInputType
  }

  export type GetUserGroupMemberAggregateType<T extends UserGroupMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateUserGroupMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserGroupMember[P]>
      : GetScalarType<T[P], AggregateUserGroupMember[P]>
  }




  export type UserGroupMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserGroupMemberWhereInput
    orderBy?: UserGroupMemberOrderByWithAggregationInput | UserGroupMemberOrderByWithAggregationInput[]
    by: UserGroupMemberScalarFieldEnum[] | UserGroupMemberScalarFieldEnum
    having?: UserGroupMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserGroupMemberCountAggregateInputType | true
    _min?: UserGroupMemberMinAggregateInputType
    _max?: UserGroupMemberMaxAggregateInputType
  }

  export type UserGroupMemberGroupByOutputType = {
    id: string
    groupId: string
    userId: string
    joinedAt: Date
    addedBy: string | null
    _count: UserGroupMemberCountAggregateOutputType | null
    _min: UserGroupMemberMinAggregateOutputType | null
    _max: UserGroupMemberMaxAggregateOutputType | null
  }

  type GetUserGroupMemberGroupByPayload<T extends UserGroupMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupMemberGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupMemberGroupByOutputType[P]>
        }
      >
    >


  export type UserGroupMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupId?: boolean
    userId?: boolean
    joinedAt?: boolean
    addedBy?: boolean
    group?: boolean | UserGroupDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userGroupMember"]>

  export type UserGroupMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupId?: boolean
    userId?: boolean
    joinedAt?: boolean
    addedBy?: boolean
    group?: boolean | UserGroupDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userGroupMember"]>

  export type UserGroupMemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupId?: boolean
    userId?: boolean
    joinedAt?: boolean
    addedBy?: boolean
    group?: boolean | UserGroupDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userGroupMember"]>

  export type UserGroupMemberSelectScalar = {
    id?: boolean
    groupId?: boolean
    userId?: boolean
    joinedAt?: boolean
    addedBy?: boolean
  }

  export type UserGroupMemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "groupId" | "userId" | "joinedAt" | "addedBy", ExtArgs["result"]["userGroupMember"]>
  export type UserGroupMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | UserGroupDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserGroupMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | UserGroupDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserGroupMemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | UserGroupDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserGroupMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserGroupMember"
    objects: {
      group: Prisma.$UserGroupPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      groupId: string
      userId: string
      joinedAt: Date
      addedBy: string | null
    }, ExtArgs["result"]["userGroupMember"]>
    composites: {}
  }

  type UserGroupMemberGetPayload<S extends boolean | null | undefined | UserGroupMemberDefaultArgs> = $Result.GetResult<Prisma.$UserGroupMemberPayload, S>

  type UserGroupMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserGroupMemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserGroupMemberCountAggregateInputType | true
    }

  export interface UserGroupMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserGroupMember'], meta: { name: 'UserGroupMember' } }
    /**
     * Find zero or one UserGroupMember that matches the filter.
     * @param {UserGroupMemberFindUniqueArgs} args - Arguments to find a UserGroupMember
     * @example
     * // Get one UserGroupMember
     * const userGroupMember = await prisma.userGroupMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserGroupMemberFindUniqueArgs>(args: SelectSubset<T, UserGroupMemberFindUniqueArgs<ExtArgs>>): Prisma__UserGroupMemberClient<$Result.GetResult<Prisma.$UserGroupMemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserGroupMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserGroupMemberFindUniqueOrThrowArgs} args - Arguments to find a UserGroupMember
     * @example
     * // Get one UserGroupMember
     * const userGroupMember = await prisma.userGroupMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserGroupMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, UserGroupMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserGroupMemberClient<$Result.GetResult<Prisma.$UserGroupMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserGroupMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupMemberFindFirstArgs} args - Arguments to find a UserGroupMember
     * @example
     * // Get one UserGroupMember
     * const userGroupMember = await prisma.userGroupMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserGroupMemberFindFirstArgs>(args?: SelectSubset<T, UserGroupMemberFindFirstArgs<ExtArgs>>): Prisma__UserGroupMemberClient<$Result.GetResult<Prisma.$UserGroupMemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserGroupMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupMemberFindFirstOrThrowArgs} args - Arguments to find a UserGroupMember
     * @example
     * // Get one UserGroupMember
     * const userGroupMember = await prisma.userGroupMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserGroupMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, UserGroupMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserGroupMemberClient<$Result.GetResult<Prisma.$UserGroupMemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserGroupMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserGroupMembers
     * const userGroupMembers = await prisma.userGroupMember.findMany()
     * 
     * // Get first 10 UserGroupMembers
     * const userGroupMembers = await prisma.userGroupMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userGroupMemberWithIdOnly = await prisma.userGroupMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserGroupMemberFindManyArgs>(args?: SelectSubset<T, UserGroupMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserGroupMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserGroupMember.
     * @param {UserGroupMemberCreateArgs} args - Arguments to create a UserGroupMember.
     * @example
     * // Create one UserGroupMember
     * const UserGroupMember = await prisma.userGroupMember.create({
     *   data: {
     *     // ... data to create a UserGroupMember
     *   }
     * })
     * 
     */
    create<T extends UserGroupMemberCreateArgs>(args: SelectSubset<T, UserGroupMemberCreateArgs<ExtArgs>>): Prisma__UserGroupMemberClient<$Result.GetResult<Prisma.$UserGroupMemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserGroupMembers.
     * @param {UserGroupMemberCreateManyArgs} args - Arguments to create many UserGroupMembers.
     * @example
     * // Create many UserGroupMembers
     * const userGroupMember = await prisma.userGroupMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserGroupMemberCreateManyArgs>(args?: SelectSubset<T, UserGroupMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserGroupMembers and returns the data saved in the database.
     * @param {UserGroupMemberCreateManyAndReturnArgs} args - Arguments to create many UserGroupMembers.
     * @example
     * // Create many UserGroupMembers
     * const userGroupMember = await prisma.userGroupMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserGroupMembers and only return the `id`
     * const userGroupMemberWithIdOnly = await prisma.userGroupMember.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserGroupMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, UserGroupMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserGroupMemberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserGroupMember.
     * @param {UserGroupMemberDeleteArgs} args - Arguments to delete one UserGroupMember.
     * @example
     * // Delete one UserGroupMember
     * const UserGroupMember = await prisma.userGroupMember.delete({
     *   where: {
     *     // ... filter to delete one UserGroupMember
     *   }
     * })
     * 
     */
    delete<T extends UserGroupMemberDeleteArgs>(args: SelectSubset<T, UserGroupMemberDeleteArgs<ExtArgs>>): Prisma__UserGroupMemberClient<$Result.GetResult<Prisma.$UserGroupMemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserGroupMember.
     * @param {UserGroupMemberUpdateArgs} args - Arguments to update one UserGroupMember.
     * @example
     * // Update one UserGroupMember
     * const userGroupMember = await prisma.userGroupMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserGroupMemberUpdateArgs>(args: SelectSubset<T, UserGroupMemberUpdateArgs<ExtArgs>>): Prisma__UserGroupMemberClient<$Result.GetResult<Prisma.$UserGroupMemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserGroupMembers.
     * @param {UserGroupMemberDeleteManyArgs} args - Arguments to filter UserGroupMembers to delete.
     * @example
     * // Delete a few UserGroupMembers
     * const { count } = await prisma.userGroupMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserGroupMemberDeleteManyArgs>(args?: SelectSubset<T, UserGroupMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserGroupMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserGroupMembers
     * const userGroupMember = await prisma.userGroupMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserGroupMemberUpdateManyArgs>(args: SelectSubset<T, UserGroupMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserGroupMembers and returns the data updated in the database.
     * @param {UserGroupMemberUpdateManyAndReturnArgs} args - Arguments to update many UserGroupMembers.
     * @example
     * // Update many UserGroupMembers
     * const userGroupMember = await prisma.userGroupMember.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserGroupMembers and only return the `id`
     * const userGroupMemberWithIdOnly = await prisma.userGroupMember.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserGroupMemberUpdateManyAndReturnArgs>(args: SelectSubset<T, UserGroupMemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserGroupMemberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserGroupMember.
     * @param {UserGroupMemberUpsertArgs} args - Arguments to update or create a UserGroupMember.
     * @example
     * // Update or create a UserGroupMember
     * const userGroupMember = await prisma.userGroupMember.upsert({
     *   create: {
     *     // ... data to create a UserGroupMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserGroupMember we want to update
     *   }
     * })
     */
    upsert<T extends UserGroupMemberUpsertArgs>(args: SelectSubset<T, UserGroupMemberUpsertArgs<ExtArgs>>): Prisma__UserGroupMemberClient<$Result.GetResult<Prisma.$UserGroupMemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserGroupMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupMemberCountArgs} args - Arguments to filter UserGroupMembers to count.
     * @example
     * // Count the number of UserGroupMembers
     * const count = await prisma.userGroupMember.count({
     *   where: {
     *     // ... the filter for the UserGroupMembers we want to count
     *   }
     * })
    **/
    count<T extends UserGroupMemberCountArgs>(
      args?: Subset<T, UserGroupMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserGroupMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserGroupMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserGroupMemberAggregateArgs>(args: Subset<T, UserGroupMemberAggregateArgs>): Prisma.PrismaPromise<GetUserGroupMemberAggregateType<T>>

    /**
     * Group by UserGroupMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupMemberGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserGroupMember model
   */
  readonly fields: UserGroupMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserGroupMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserGroupMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    group<T extends UserGroupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserGroupDefaultArgs<ExtArgs>>): Prisma__UserGroupClient<$Result.GetResult<Prisma.$UserGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserGroupMember model
   */
  interface UserGroupMemberFieldRefs {
    readonly id: FieldRef<"UserGroupMember", 'String'>
    readonly groupId: FieldRef<"UserGroupMember", 'String'>
    readonly userId: FieldRef<"UserGroupMember", 'String'>
    readonly joinedAt: FieldRef<"UserGroupMember", 'DateTime'>
    readonly addedBy: FieldRef<"UserGroupMember", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserGroupMember findUnique
   */
  export type UserGroupMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGroupMember
     */
    select?: UserGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserGroupMember
     */
    omit?: UserGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which UserGroupMember to fetch.
     */
    where: UserGroupMemberWhereUniqueInput
  }

  /**
   * UserGroupMember findUniqueOrThrow
   */
  export type UserGroupMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGroupMember
     */
    select?: UserGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserGroupMember
     */
    omit?: UserGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which UserGroupMember to fetch.
     */
    where: UserGroupMemberWhereUniqueInput
  }

  /**
   * UserGroupMember findFirst
   */
  export type UserGroupMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGroupMember
     */
    select?: UserGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserGroupMember
     */
    omit?: UserGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which UserGroupMember to fetch.
     */
    where?: UserGroupMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserGroupMembers to fetch.
     */
    orderBy?: UserGroupMemberOrderByWithRelationInput | UserGroupMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserGroupMembers.
     */
    cursor?: UserGroupMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserGroupMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserGroupMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserGroupMembers.
     */
    distinct?: UserGroupMemberScalarFieldEnum | UserGroupMemberScalarFieldEnum[]
  }

  /**
   * UserGroupMember findFirstOrThrow
   */
  export type UserGroupMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGroupMember
     */
    select?: UserGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserGroupMember
     */
    omit?: UserGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which UserGroupMember to fetch.
     */
    where?: UserGroupMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserGroupMembers to fetch.
     */
    orderBy?: UserGroupMemberOrderByWithRelationInput | UserGroupMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserGroupMembers.
     */
    cursor?: UserGroupMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserGroupMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserGroupMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserGroupMembers.
     */
    distinct?: UserGroupMemberScalarFieldEnum | UserGroupMemberScalarFieldEnum[]
  }

  /**
   * UserGroupMember findMany
   */
  export type UserGroupMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGroupMember
     */
    select?: UserGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserGroupMember
     */
    omit?: UserGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which UserGroupMembers to fetch.
     */
    where?: UserGroupMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserGroupMembers to fetch.
     */
    orderBy?: UserGroupMemberOrderByWithRelationInput | UserGroupMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserGroupMembers.
     */
    cursor?: UserGroupMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserGroupMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserGroupMembers.
     */
    skip?: number
    distinct?: UserGroupMemberScalarFieldEnum | UserGroupMemberScalarFieldEnum[]
  }

  /**
   * UserGroupMember create
   */
  export type UserGroupMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGroupMember
     */
    select?: UserGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserGroupMember
     */
    omit?: UserGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGroupMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a UserGroupMember.
     */
    data: XOR<UserGroupMemberCreateInput, UserGroupMemberUncheckedCreateInput>
  }

  /**
   * UserGroupMember createMany
   */
  export type UserGroupMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserGroupMembers.
     */
    data: UserGroupMemberCreateManyInput | UserGroupMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserGroupMember createManyAndReturn
   */
  export type UserGroupMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGroupMember
     */
    select?: UserGroupMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserGroupMember
     */
    omit?: UserGroupMemberOmit<ExtArgs> | null
    /**
     * The data used to create many UserGroupMembers.
     */
    data: UserGroupMemberCreateManyInput | UserGroupMemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGroupMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserGroupMember update
   */
  export type UserGroupMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGroupMember
     */
    select?: UserGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserGroupMember
     */
    omit?: UserGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGroupMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a UserGroupMember.
     */
    data: XOR<UserGroupMemberUpdateInput, UserGroupMemberUncheckedUpdateInput>
    /**
     * Choose, which UserGroupMember to update.
     */
    where: UserGroupMemberWhereUniqueInput
  }

  /**
   * UserGroupMember updateMany
   */
  export type UserGroupMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserGroupMembers.
     */
    data: XOR<UserGroupMemberUpdateManyMutationInput, UserGroupMemberUncheckedUpdateManyInput>
    /**
     * Filter which UserGroupMembers to update
     */
    where?: UserGroupMemberWhereInput
    /**
     * Limit how many UserGroupMembers to update.
     */
    limit?: number
  }

  /**
   * UserGroupMember updateManyAndReturn
   */
  export type UserGroupMemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGroupMember
     */
    select?: UserGroupMemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserGroupMember
     */
    omit?: UserGroupMemberOmit<ExtArgs> | null
    /**
     * The data used to update UserGroupMembers.
     */
    data: XOR<UserGroupMemberUpdateManyMutationInput, UserGroupMemberUncheckedUpdateManyInput>
    /**
     * Filter which UserGroupMembers to update
     */
    where?: UserGroupMemberWhereInput
    /**
     * Limit how many UserGroupMembers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGroupMemberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserGroupMember upsert
   */
  export type UserGroupMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGroupMember
     */
    select?: UserGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserGroupMember
     */
    omit?: UserGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGroupMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the UserGroupMember to update in case it exists.
     */
    where: UserGroupMemberWhereUniqueInput
    /**
     * In case the UserGroupMember found by the `where` argument doesn't exist, create a new UserGroupMember with this data.
     */
    create: XOR<UserGroupMemberCreateInput, UserGroupMemberUncheckedCreateInput>
    /**
     * In case the UserGroupMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserGroupMemberUpdateInput, UserGroupMemberUncheckedUpdateInput>
  }

  /**
   * UserGroupMember delete
   */
  export type UserGroupMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGroupMember
     */
    select?: UserGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserGroupMember
     */
    omit?: UserGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGroupMemberInclude<ExtArgs> | null
    /**
     * Filter which UserGroupMember to delete.
     */
    where: UserGroupMemberWhereUniqueInput
  }

  /**
   * UserGroupMember deleteMany
   */
  export type UserGroupMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserGroupMembers to delete
     */
    where?: UserGroupMemberWhereInput
    /**
     * Limit how many UserGroupMembers to delete.
     */
    limit?: number
  }

  /**
   * UserGroupMember without action
   */
  export type UserGroupMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGroupMember
     */
    select?: UserGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserGroupMember
     */
    omit?: UserGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGroupMemberInclude<ExtArgs> | null
  }


  /**
   * Model Permission
   */

  export type AggregatePermission = {
    _count: PermissionCountAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  export type PermissionMinAggregateOutputType = {
    id: string | null
    resourceType: $Enums.ResourceType | null
    action: $Enums.PermissionAction | null
    permissionName: string | null
    description: string | null
    createdAt: Date | null
  }

  export type PermissionMaxAggregateOutputType = {
    id: string | null
    resourceType: $Enums.ResourceType | null
    action: $Enums.PermissionAction | null
    permissionName: string | null
    description: string | null
    createdAt: Date | null
  }

  export type PermissionCountAggregateOutputType = {
    id: number
    resourceType: number
    action: number
    permissionName: number
    description: number
    createdAt: number
    _all: number
  }


  export type PermissionMinAggregateInputType = {
    id?: true
    resourceType?: true
    action?: true
    permissionName?: true
    description?: true
    createdAt?: true
  }

  export type PermissionMaxAggregateInputType = {
    id?: true
    resourceType?: true
    action?: true
    permissionName?: true
    description?: true
    createdAt?: true
  }

  export type PermissionCountAggregateInputType = {
    id?: true
    resourceType?: true
    action?: true
    permissionName?: true
    description?: true
    createdAt?: true
    _all?: true
  }

  export type PermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permission to aggregate.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Permissions
    **/
    _count?: true | PermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermissionMaxAggregateInputType
  }

  export type GetPermissionAggregateType<T extends PermissionAggregateArgs> = {
        [P in keyof T & keyof AggregatePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermission[P]>
      : GetScalarType<T[P], AggregatePermission[P]>
  }




  export type PermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermissionWhereInput
    orderBy?: PermissionOrderByWithAggregationInput | PermissionOrderByWithAggregationInput[]
    by: PermissionScalarFieldEnum[] | PermissionScalarFieldEnum
    having?: PermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermissionCountAggregateInputType | true
    _min?: PermissionMinAggregateInputType
    _max?: PermissionMaxAggregateInputType
  }

  export type PermissionGroupByOutputType = {
    id: string
    resourceType: $Enums.ResourceType
    action: $Enums.PermissionAction
    permissionName: string
    description: string | null
    createdAt: Date
    _count: PermissionCountAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  type GetPermissionGroupByPayload<T extends PermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermissionGroupByOutputType[P]>
            : GetScalarType<T[P], PermissionGroupByOutputType[P]>
        }
      >
    >


  export type PermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    resourceType?: boolean
    action?: boolean
    permissionName?: boolean
    description?: boolean
    createdAt?: boolean
    rolePermissions?: boolean | Permission$rolePermissionsArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    resourceType?: boolean
    action?: boolean
    permissionName?: boolean
    description?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    resourceType?: boolean
    action?: boolean
    permissionName?: boolean
    description?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectScalar = {
    id?: boolean
    resourceType?: boolean
    action?: boolean
    permissionName?: boolean
    description?: boolean
    createdAt?: boolean
  }

  export type PermissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "resourceType" | "action" | "permissionName" | "description" | "createdAt", ExtArgs["result"]["permission"]>
  export type PermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rolePermissions?: boolean | Permission$rolePermissionsArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PermissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PermissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Permission"
    objects: {
      rolePermissions: Prisma.$RolePermissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      resourceType: $Enums.ResourceType
      action: $Enums.PermissionAction
      permissionName: string
      description: string | null
      createdAt: Date
    }, ExtArgs["result"]["permission"]>
    composites: {}
  }

  type PermissionGetPayload<S extends boolean | null | undefined | PermissionDefaultArgs> = $Result.GetResult<Prisma.$PermissionPayload, S>

  type PermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PermissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PermissionCountAggregateInputType | true
    }

  export interface PermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Permission'], meta: { name: 'Permission' } }
    /**
     * Find zero or one Permission that matches the filter.
     * @param {PermissionFindUniqueArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PermissionFindUniqueArgs>(args: SelectSubset<T, PermissionFindUniqueArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Permission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PermissionFindUniqueOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, PermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PermissionFindFirstArgs>(args?: SelectSubset<T, PermissionFindFirstArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, PermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permissions
     * const permissions = await prisma.permission.findMany()
     * 
     * // Get first 10 Permissions
     * const permissions = await prisma.permission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const permissionWithIdOnly = await prisma.permission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PermissionFindManyArgs>(args?: SelectSubset<T, PermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Permission.
     * @param {PermissionCreateArgs} args - Arguments to create a Permission.
     * @example
     * // Create one Permission
     * const Permission = await prisma.permission.create({
     *   data: {
     *     // ... data to create a Permission
     *   }
     * })
     * 
     */
    create<T extends PermissionCreateArgs>(args: SelectSubset<T, PermissionCreateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Permissions.
     * @param {PermissionCreateManyArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PermissionCreateManyArgs>(args?: SelectSubset<T, PermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Permissions and returns the data saved in the database.
     * @param {PermissionCreateManyAndReturnArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Permissions and only return the `id`
     * const permissionWithIdOnly = await prisma.permission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, PermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Permission.
     * @param {PermissionDeleteArgs} args - Arguments to delete one Permission.
     * @example
     * // Delete one Permission
     * const Permission = await prisma.permission.delete({
     *   where: {
     *     // ... filter to delete one Permission
     *   }
     * })
     * 
     */
    delete<T extends PermissionDeleteArgs>(args: SelectSubset<T, PermissionDeleteArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Permission.
     * @param {PermissionUpdateArgs} args - Arguments to update one Permission.
     * @example
     * // Update one Permission
     * const permission = await prisma.permission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PermissionUpdateArgs>(args: SelectSubset<T, PermissionUpdateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Permissions.
     * @param {PermissionDeleteManyArgs} args - Arguments to filter Permissions to delete.
     * @example
     * // Delete a few Permissions
     * const { count } = await prisma.permission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PermissionDeleteManyArgs>(args?: SelectSubset<T, PermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permissions
     * const permission = await prisma.permission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PermissionUpdateManyArgs>(args: SelectSubset<T, PermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions and returns the data updated in the database.
     * @param {PermissionUpdateManyAndReturnArgs} args - Arguments to update many Permissions.
     * @example
     * // Update many Permissions
     * const permission = await prisma.permission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Permissions and only return the `id`
     * const permissionWithIdOnly = await prisma.permission.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PermissionUpdateManyAndReturnArgs>(args: SelectSubset<T, PermissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Permission.
     * @param {PermissionUpsertArgs} args - Arguments to update or create a Permission.
     * @example
     * // Update or create a Permission
     * const permission = await prisma.permission.upsert({
     *   create: {
     *     // ... data to create a Permission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permission we want to update
     *   }
     * })
     */
    upsert<T extends PermissionUpsertArgs>(args: SelectSubset<T, PermissionUpsertArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionCountArgs} args - Arguments to filter Permissions to count.
     * @example
     * // Count the number of Permissions
     * const count = await prisma.permission.count({
     *   where: {
     *     // ... the filter for the Permissions we want to count
     *   }
     * })
    **/
    count<T extends PermissionCountArgs>(
      args?: Subset<T, PermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermissionAggregateArgs>(args: Subset<T, PermissionAggregateArgs>): Prisma.PrismaPromise<GetPermissionAggregateType<T>>

    /**
     * Group by Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PermissionGroupByArgs['orderBy'] }
        : { orderBy?: PermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Permission model
   */
  readonly fields: PermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Permission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    rolePermissions<T extends Permission$rolePermissionsArgs<ExtArgs> = {}>(args?: Subset<T, Permission$rolePermissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Permission model
   */
  interface PermissionFieldRefs {
    readonly id: FieldRef<"Permission", 'String'>
    readonly resourceType: FieldRef<"Permission", 'ResourceType'>
    readonly action: FieldRef<"Permission", 'PermissionAction'>
    readonly permissionName: FieldRef<"Permission", 'String'>
    readonly description: FieldRef<"Permission", 'String'>
    readonly createdAt: FieldRef<"Permission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Permission findUnique
   */
  export type PermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findUniqueOrThrow
   */
  export type PermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findFirst
   */
  export type PermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findFirstOrThrow
   */
  export type PermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findMany
   */
  export type PermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permissions to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission create
   */
  export type PermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a Permission.
     */
    data: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
  }

  /**
   * Permission createMany
   */
  export type PermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Permissions.
     */
    data: PermissionCreateManyInput | PermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Permission createManyAndReturn
   */
  export type PermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * The data used to create many Permissions.
     */
    data: PermissionCreateManyInput | PermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Permission update
   */
  export type PermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a Permission.
     */
    data: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
    /**
     * Choose, which Permission to update.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission updateMany
   */
  export type PermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Permissions.
     */
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyInput>
    /**
     * Filter which Permissions to update
     */
    where?: PermissionWhereInput
    /**
     * Limit how many Permissions to update.
     */
    limit?: number
  }

  /**
   * Permission updateManyAndReturn
   */
  export type PermissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * The data used to update Permissions.
     */
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyInput>
    /**
     * Filter which Permissions to update
     */
    where?: PermissionWhereInput
    /**
     * Limit how many Permissions to update.
     */
    limit?: number
  }

  /**
   * Permission upsert
   */
  export type PermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the Permission to update in case it exists.
     */
    where: PermissionWhereUniqueInput
    /**
     * In case the Permission found by the `where` argument doesn't exist, create a new Permission with this data.
     */
    create: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
    /**
     * In case the Permission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
  }

  /**
   * Permission delete
   */
  export type PermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter which Permission to delete.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission deleteMany
   */
  export type PermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permissions to delete
     */
    where?: PermissionWhereInput
    /**
     * Limit how many Permissions to delete.
     */
    limit?: number
  }

  /**
   * Permission.rolePermissions
   */
  export type Permission$rolePermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    where?: RolePermissionWhereInput
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    cursor?: RolePermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * Permission without action
   */
  export type PermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
  }


  /**
   * Model RolePermission
   */

  export type AggregateRolePermission = {
    _count: RolePermissionCountAggregateOutputType | null
    _min: RolePermissionMinAggregateOutputType | null
    _max: RolePermissionMaxAggregateOutputType | null
  }

  export type RolePermissionMinAggregateOutputType = {
    id: string | null
    role: $Enums.UserRole | null
    permissionId: string | null
  }

  export type RolePermissionMaxAggregateOutputType = {
    id: string | null
    role: $Enums.UserRole | null
    permissionId: string | null
  }

  export type RolePermissionCountAggregateOutputType = {
    id: number
    role: number
    permissionId: number
    _all: number
  }


  export type RolePermissionMinAggregateInputType = {
    id?: true
    role?: true
    permissionId?: true
  }

  export type RolePermissionMaxAggregateInputType = {
    id?: true
    role?: true
    permissionId?: true
  }

  export type RolePermissionCountAggregateInputType = {
    id?: true
    role?: true
    permissionId?: true
    _all?: true
  }

  export type RolePermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolePermission to aggregate.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RolePermissions
    **/
    _count?: true | RolePermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolePermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolePermissionMaxAggregateInputType
  }

  export type GetRolePermissionAggregateType<T extends RolePermissionAggregateArgs> = {
        [P in keyof T & keyof AggregateRolePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRolePermission[P]>
      : GetScalarType<T[P], AggregateRolePermission[P]>
  }




  export type RolePermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionWhereInput
    orderBy?: RolePermissionOrderByWithAggregationInput | RolePermissionOrderByWithAggregationInput[]
    by: RolePermissionScalarFieldEnum[] | RolePermissionScalarFieldEnum
    having?: RolePermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolePermissionCountAggregateInputType | true
    _min?: RolePermissionMinAggregateInputType
    _max?: RolePermissionMaxAggregateInputType
  }

  export type RolePermissionGroupByOutputType = {
    id: string
    role: $Enums.UserRole
    permissionId: string
    _count: RolePermissionCountAggregateOutputType | null
    _min: RolePermissionMinAggregateOutputType | null
    _max: RolePermissionMaxAggregateOutputType | null
  }

  type GetRolePermissionGroupByPayload<T extends RolePermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolePermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolePermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolePermissionGroupByOutputType[P]>
            : GetScalarType<T[P], RolePermissionGroupByOutputType[P]>
        }
      >
    >


  export type RolePermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role?: boolean
    permissionId?: boolean
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolePermission"]>

  export type RolePermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role?: boolean
    permissionId?: boolean
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolePermission"]>

  export type RolePermissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role?: boolean
    permissionId?: boolean
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolePermission"]>

  export type RolePermissionSelectScalar = {
    id?: boolean
    role?: boolean
    permissionId?: boolean
  }

  export type RolePermissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "role" | "permissionId", ExtArgs["result"]["rolePermission"]>
  export type RolePermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }
  export type RolePermissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }
  export type RolePermissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }

  export type $RolePermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RolePermission"
    objects: {
      permission: Prisma.$PermissionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      role: $Enums.UserRole
      permissionId: string
    }, ExtArgs["result"]["rolePermission"]>
    composites: {}
  }

  type RolePermissionGetPayload<S extends boolean | null | undefined | RolePermissionDefaultArgs> = $Result.GetResult<Prisma.$RolePermissionPayload, S>

  type RolePermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RolePermissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RolePermissionCountAggregateInputType | true
    }

  export interface RolePermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RolePermission'], meta: { name: 'RolePermission' } }
    /**
     * Find zero or one RolePermission that matches the filter.
     * @param {RolePermissionFindUniqueArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RolePermissionFindUniqueArgs>(args: SelectSubset<T, RolePermissionFindUniqueArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RolePermission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RolePermissionFindUniqueOrThrowArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RolePermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, RolePermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RolePermission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindFirstArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RolePermissionFindFirstArgs>(args?: SelectSubset<T, RolePermissionFindFirstArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RolePermission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindFirstOrThrowArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RolePermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, RolePermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RolePermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RolePermissions
     * const rolePermissions = await prisma.rolePermission.findMany()
     * 
     * // Get first 10 RolePermissions
     * const rolePermissions = await prisma.rolePermission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rolePermissionWithIdOnly = await prisma.rolePermission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RolePermissionFindManyArgs>(args?: SelectSubset<T, RolePermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RolePermission.
     * @param {RolePermissionCreateArgs} args - Arguments to create a RolePermission.
     * @example
     * // Create one RolePermission
     * const RolePermission = await prisma.rolePermission.create({
     *   data: {
     *     // ... data to create a RolePermission
     *   }
     * })
     * 
     */
    create<T extends RolePermissionCreateArgs>(args: SelectSubset<T, RolePermissionCreateArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RolePermissions.
     * @param {RolePermissionCreateManyArgs} args - Arguments to create many RolePermissions.
     * @example
     * // Create many RolePermissions
     * const rolePermission = await prisma.rolePermission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RolePermissionCreateManyArgs>(args?: SelectSubset<T, RolePermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RolePermissions and returns the data saved in the database.
     * @param {RolePermissionCreateManyAndReturnArgs} args - Arguments to create many RolePermissions.
     * @example
     * // Create many RolePermissions
     * const rolePermission = await prisma.rolePermission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RolePermissions and only return the `id`
     * const rolePermissionWithIdOnly = await prisma.rolePermission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RolePermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, RolePermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RolePermission.
     * @param {RolePermissionDeleteArgs} args - Arguments to delete one RolePermission.
     * @example
     * // Delete one RolePermission
     * const RolePermission = await prisma.rolePermission.delete({
     *   where: {
     *     // ... filter to delete one RolePermission
     *   }
     * })
     * 
     */
    delete<T extends RolePermissionDeleteArgs>(args: SelectSubset<T, RolePermissionDeleteArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RolePermission.
     * @param {RolePermissionUpdateArgs} args - Arguments to update one RolePermission.
     * @example
     * // Update one RolePermission
     * const rolePermission = await prisma.rolePermission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RolePermissionUpdateArgs>(args: SelectSubset<T, RolePermissionUpdateArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RolePermissions.
     * @param {RolePermissionDeleteManyArgs} args - Arguments to filter RolePermissions to delete.
     * @example
     * // Delete a few RolePermissions
     * const { count } = await prisma.rolePermission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RolePermissionDeleteManyArgs>(args?: SelectSubset<T, RolePermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RolePermissions
     * const rolePermission = await prisma.rolePermission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RolePermissionUpdateManyArgs>(args: SelectSubset<T, RolePermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RolePermissions and returns the data updated in the database.
     * @param {RolePermissionUpdateManyAndReturnArgs} args - Arguments to update many RolePermissions.
     * @example
     * // Update many RolePermissions
     * const rolePermission = await prisma.rolePermission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RolePermissions and only return the `id`
     * const rolePermissionWithIdOnly = await prisma.rolePermission.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RolePermissionUpdateManyAndReturnArgs>(args: SelectSubset<T, RolePermissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RolePermission.
     * @param {RolePermissionUpsertArgs} args - Arguments to update or create a RolePermission.
     * @example
     * // Update or create a RolePermission
     * const rolePermission = await prisma.rolePermission.upsert({
     *   create: {
     *     // ... data to create a RolePermission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RolePermission we want to update
     *   }
     * })
     */
    upsert<T extends RolePermissionUpsertArgs>(args: SelectSubset<T, RolePermissionUpsertArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionCountArgs} args - Arguments to filter RolePermissions to count.
     * @example
     * // Count the number of RolePermissions
     * const count = await prisma.rolePermission.count({
     *   where: {
     *     // ... the filter for the RolePermissions we want to count
     *   }
     * })
    **/
    count<T extends RolePermissionCountArgs>(
      args?: Subset<T, RolePermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolePermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RolePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolePermissionAggregateArgs>(args: Subset<T, RolePermissionAggregateArgs>): Prisma.PrismaPromise<GetRolePermissionAggregateType<T>>

    /**
     * Group by RolePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RolePermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RolePermissionGroupByArgs['orderBy'] }
        : { orderBy?: RolePermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RolePermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolePermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RolePermission model
   */
  readonly fields: RolePermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RolePermission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RolePermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    permission<T extends PermissionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PermissionDefaultArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RolePermission model
   */
  interface RolePermissionFieldRefs {
    readonly id: FieldRef<"RolePermission", 'String'>
    readonly role: FieldRef<"RolePermission", 'UserRole'>
    readonly permissionId: FieldRef<"RolePermission", 'String'>
  }
    

  // Custom InputTypes
  /**
   * RolePermission findUnique
   */
  export type RolePermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission findUniqueOrThrow
   */
  export type RolePermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission findFirst
   */
  export type RolePermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolePermissions.
     */
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * RolePermission findFirstOrThrow
   */
  export type RolePermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolePermissions.
     */
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * RolePermission findMany
   */
  export type RolePermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermissions to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * RolePermission create
   */
  export type RolePermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a RolePermission.
     */
    data: XOR<RolePermissionCreateInput, RolePermissionUncheckedCreateInput>
  }

  /**
   * RolePermission createMany
   */
  export type RolePermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RolePermissions.
     */
    data: RolePermissionCreateManyInput | RolePermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RolePermission createManyAndReturn
   */
  export type RolePermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * The data used to create many RolePermissions.
     */
    data: RolePermissionCreateManyInput | RolePermissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RolePermission update
   */
  export type RolePermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a RolePermission.
     */
    data: XOR<RolePermissionUpdateInput, RolePermissionUncheckedUpdateInput>
    /**
     * Choose, which RolePermission to update.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission updateMany
   */
  export type RolePermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RolePermissions.
     */
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyInput>
    /**
     * Filter which RolePermissions to update
     */
    where?: RolePermissionWhereInput
    /**
     * Limit how many RolePermissions to update.
     */
    limit?: number
  }

  /**
   * RolePermission updateManyAndReturn
   */
  export type RolePermissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * The data used to update RolePermissions.
     */
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyInput>
    /**
     * Filter which RolePermissions to update
     */
    where?: RolePermissionWhereInput
    /**
     * Limit how many RolePermissions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RolePermission upsert
   */
  export type RolePermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the RolePermission to update in case it exists.
     */
    where: RolePermissionWhereUniqueInput
    /**
     * In case the RolePermission found by the `where` argument doesn't exist, create a new RolePermission with this data.
     */
    create: XOR<RolePermissionCreateInput, RolePermissionUncheckedCreateInput>
    /**
     * In case the RolePermission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RolePermissionUpdateInput, RolePermissionUncheckedUpdateInput>
  }

  /**
   * RolePermission delete
   */
  export type RolePermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter which RolePermission to delete.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission deleteMany
   */
  export type RolePermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolePermissions to delete
     */
    where?: RolePermissionWhereInput
    /**
     * Limit how many RolePermissions to delete.
     */
    limit?: number
  }

  /**
   * RolePermission without action
   */
  export type RolePermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
  }


  /**
   * Model Instance
   */

  export type AggregateInstance = {
    _count: InstanceCountAggregateOutputType | null
    _min: InstanceMinAggregateOutputType | null
    _max: InstanceMaxAggregateOutputType | null
  }

  export type InstanceMinAggregateOutputType = {
    id: string | null
    name: string | null
    tenantId: string | null
    userId: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InstanceMaxAggregateOutputType = {
    id: string | null
    name: string | null
    tenantId: string | null
    userId: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InstanceCountAggregateOutputType = {
    id: number
    name: number
    tenantId: number
    userId: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InstanceMinAggregateInputType = {
    id?: true
    name?: true
    tenantId?: true
    userId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InstanceMaxAggregateInputType = {
    id?: true
    name?: true
    tenantId?: true
    userId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InstanceCountAggregateInputType = {
    id?: true
    name?: true
    tenantId?: true
    userId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InstanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Instance to aggregate.
     */
    where?: InstanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Instances to fetch.
     */
    orderBy?: InstanceOrderByWithRelationInput | InstanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InstanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Instances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Instances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Instances
    **/
    _count?: true | InstanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InstanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InstanceMaxAggregateInputType
  }

  export type GetInstanceAggregateType<T extends InstanceAggregateArgs> = {
        [P in keyof T & keyof AggregateInstance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInstance[P]>
      : GetScalarType<T[P], AggregateInstance[P]>
  }




  export type InstanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstanceWhereInput
    orderBy?: InstanceOrderByWithAggregationInput | InstanceOrderByWithAggregationInput[]
    by: InstanceScalarFieldEnum[] | InstanceScalarFieldEnum
    having?: InstanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InstanceCountAggregateInputType | true
    _min?: InstanceMinAggregateInputType
    _max?: InstanceMaxAggregateInputType
  }

  export type InstanceGroupByOutputType = {
    id: string
    name: string
    tenantId: string
    userId: string
    status: string
    createdAt: Date
    updatedAt: Date
    _count: InstanceCountAggregateOutputType | null
    _min: InstanceMinAggregateOutputType | null
    _max: InstanceMaxAggregateOutputType | null
  }

  type GetInstanceGroupByPayload<T extends InstanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InstanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InstanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InstanceGroupByOutputType[P]>
            : GetScalarType<T[P], InstanceGroupByOutputType[P]>
        }
      >
    >


  export type InstanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    tenantId?: boolean
    userId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["instance"]>

  export type InstanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    tenantId?: boolean
    userId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["instance"]>

  export type InstanceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    tenantId?: boolean
    userId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["instance"]>

  export type InstanceSelectScalar = {
    id?: boolean
    name?: boolean
    tenantId?: boolean
    userId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InstanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "tenantId" | "userId" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["instance"]>
  export type InstanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type InstanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type InstanceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $InstancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Instance"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      tenantId: string
      userId: string
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["instance"]>
    composites: {}
  }

  type InstanceGetPayload<S extends boolean | null | undefined | InstanceDefaultArgs> = $Result.GetResult<Prisma.$InstancePayload, S>

  type InstanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InstanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InstanceCountAggregateInputType | true
    }

  export interface InstanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Instance'], meta: { name: 'Instance' } }
    /**
     * Find zero or one Instance that matches the filter.
     * @param {InstanceFindUniqueArgs} args - Arguments to find a Instance
     * @example
     * // Get one Instance
     * const instance = await prisma.instance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InstanceFindUniqueArgs>(args: SelectSubset<T, InstanceFindUniqueArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Instance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InstanceFindUniqueOrThrowArgs} args - Arguments to find a Instance
     * @example
     * // Get one Instance
     * const instance = await prisma.instance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InstanceFindUniqueOrThrowArgs>(args: SelectSubset<T, InstanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Instance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstanceFindFirstArgs} args - Arguments to find a Instance
     * @example
     * // Get one Instance
     * const instance = await prisma.instance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InstanceFindFirstArgs>(args?: SelectSubset<T, InstanceFindFirstArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Instance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstanceFindFirstOrThrowArgs} args - Arguments to find a Instance
     * @example
     * // Get one Instance
     * const instance = await prisma.instance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InstanceFindFirstOrThrowArgs>(args?: SelectSubset<T, InstanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Instances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Instances
     * const instances = await prisma.instance.findMany()
     * 
     * // Get first 10 Instances
     * const instances = await prisma.instance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const instanceWithIdOnly = await prisma.instance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InstanceFindManyArgs>(args?: SelectSubset<T, InstanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Instance.
     * @param {InstanceCreateArgs} args - Arguments to create a Instance.
     * @example
     * // Create one Instance
     * const Instance = await prisma.instance.create({
     *   data: {
     *     // ... data to create a Instance
     *   }
     * })
     * 
     */
    create<T extends InstanceCreateArgs>(args: SelectSubset<T, InstanceCreateArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Instances.
     * @param {InstanceCreateManyArgs} args - Arguments to create many Instances.
     * @example
     * // Create many Instances
     * const instance = await prisma.instance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InstanceCreateManyArgs>(args?: SelectSubset<T, InstanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Instances and returns the data saved in the database.
     * @param {InstanceCreateManyAndReturnArgs} args - Arguments to create many Instances.
     * @example
     * // Create many Instances
     * const instance = await prisma.instance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Instances and only return the `id`
     * const instanceWithIdOnly = await prisma.instance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InstanceCreateManyAndReturnArgs>(args?: SelectSubset<T, InstanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Instance.
     * @param {InstanceDeleteArgs} args - Arguments to delete one Instance.
     * @example
     * // Delete one Instance
     * const Instance = await prisma.instance.delete({
     *   where: {
     *     // ... filter to delete one Instance
     *   }
     * })
     * 
     */
    delete<T extends InstanceDeleteArgs>(args: SelectSubset<T, InstanceDeleteArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Instance.
     * @param {InstanceUpdateArgs} args - Arguments to update one Instance.
     * @example
     * // Update one Instance
     * const instance = await prisma.instance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InstanceUpdateArgs>(args: SelectSubset<T, InstanceUpdateArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Instances.
     * @param {InstanceDeleteManyArgs} args - Arguments to filter Instances to delete.
     * @example
     * // Delete a few Instances
     * const { count } = await prisma.instance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InstanceDeleteManyArgs>(args?: SelectSubset<T, InstanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Instances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Instances
     * const instance = await prisma.instance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InstanceUpdateManyArgs>(args: SelectSubset<T, InstanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Instances and returns the data updated in the database.
     * @param {InstanceUpdateManyAndReturnArgs} args - Arguments to update many Instances.
     * @example
     * // Update many Instances
     * const instance = await prisma.instance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Instances and only return the `id`
     * const instanceWithIdOnly = await prisma.instance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InstanceUpdateManyAndReturnArgs>(args: SelectSubset<T, InstanceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Instance.
     * @param {InstanceUpsertArgs} args - Arguments to update or create a Instance.
     * @example
     * // Update or create a Instance
     * const instance = await prisma.instance.upsert({
     *   create: {
     *     // ... data to create a Instance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Instance we want to update
     *   }
     * })
     */
    upsert<T extends InstanceUpsertArgs>(args: SelectSubset<T, InstanceUpsertArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Instances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstanceCountArgs} args - Arguments to filter Instances to count.
     * @example
     * // Count the number of Instances
     * const count = await prisma.instance.count({
     *   where: {
     *     // ... the filter for the Instances we want to count
     *   }
     * })
    **/
    count<T extends InstanceCountArgs>(
      args?: Subset<T, InstanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InstanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Instance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InstanceAggregateArgs>(args: Subset<T, InstanceAggregateArgs>): Prisma.PrismaPromise<GetInstanceAggregateType<T>>

    /**
     * Group by Instance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InstanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InstanceGroupByArgs['orderBy'] }
        : { orderBy?: InstanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InstanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInstanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Instance model
   */
  readonly fields: InstanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Instance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InstanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Instance model
   */
  interface InstanceFieldRefs {
    readonly id: FieldRef<"Instance", 'String'>
    readonly name: FieldRef<"Instance", 'String'>
    readonly tenantId: FieldRef<"Instance", 'String'>
    readonly userId: FieldRef<"Instance", 'String'>
    readonly status: FieldRef<"Instance", 'String'>
    readonly createdAt: FieldRef<"Instance", 'DateTime'>
    readonly updatedAt: FieldRef<"Instance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Instance findUnique
   */
  export type InstanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instance
     */
    select?: InstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instance
     */
    omit?: InstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstanceInclude<ExtArgs> | null
    /**
     * Filter, which Instance to fetch.
     */
    where: InstanceWhereUniqueInput
  }

  /**
   * Instance findUniqueOrThrow
   */
  export type InstanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instance
     */
    select?: InstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instance
     */
    omit?: InstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstanceInclude<ExtArgs> | null
    /**
     * Filter, which Instance to fetch.
     */
    where: InstanceWhereUniqueInput
  }

  /**
   * Instance findFirst
   */
  export type InstanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instance
     */
    select?: InstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instance
     */
    omit?: InstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstanceInclude<ExtArgs> | null
    /**
     * Filter, which Instance to fetch.
     */
    where?: InstanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Instances to fetch.
     */
    orderBy?: InstanceOrderByWithRelationInput | InstanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Instances.
     */
    cursor?: InstanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Instances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Instances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Instances.
     */
    distinct?: InstanceScalarFieldEnum | InstanceScalarFieldEnum[]
  }

  /**
   * Instance findFirstOrThrow
   */
  export type InstanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instance
     */
    select?: InstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instance
     */
    omit?: InstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstanceInclude<ExtArgs> | null
    /**
     * Filter, which Instance to fetch.
     */
    where?: InstanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Instances to fetch.
     */
    orderBy?: InstanceOrderByWithRelationInput | InstanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Instances.
     */
    cursor?: InstanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Instances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Instances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Instances.
     */
    distinct?: InstanceScalarFieldEnum | InstanceScalarFieldEnum[]
  }

  /**
   * Instance findMany
   */
  export type InstanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instance
     */
    select?: InstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instance
     */
    omit?: InstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstanceInclude<ExtArgs> | null
    /**
     * Filter, which Instances to fetch.
     */
    where?: InstanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Instances to fetch.
     */
    orderBy?: InstanceOrderByWithRelationInput | InstanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Instances.
     */
    cursor?: InstanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Instances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Instances.
     */
    skip?: number
    distinct?: InstanceScalarFieldEnum | InstanceScalarFieldEnum[]
  }

  /**
   * Instance create
   */
  export type InstanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instance
     */
    select?: InstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instance
     */
    omit?: InstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstanceInclude<ExtArgs> | null
    /**
     * The data needed to create a Instance.
     */
    data: XOR<InstanceCreateInput, InstanceUncheckedCreateInput>
  }

  /**
   * Instance createMany
   */
  export type InstanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Instances.
     */
    data: InstanceCreateManyInput | InstanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Instance createManyAndReturn
   */
  export type InstanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instance
     */
    select?: InstanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Instance
     */
    omit?: InstanceOmit<ExtArgs> | null
    /**
     * The data used to create many Instances.
     */
    data: InstanceCreateManyInput | InstanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Instance update
   */
  export type InstanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instance
     */
    select?: InstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instance
     */
    omit?: InstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstanceInclude<ExtArgs> | null
    /**
     * The data needed to update a Instance.
     */
    data: XOR<InstanceUpdateInput, InstanceUncheckedUpdateInput>
    /**
     * Choose, which Instance to update.
     */
    where: InstanceWhereUniqueInput
  }

  /**
   * Instance updateMany
   */
  export type InstanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Instances.
     */
    data: XOR<InstanceUpdateManyMutationInput, InstanceUncheckedUpdateManyInput>
    /**
     * Filter which Instances to update
     */
    where?: InstanceWhereInput
    /**
     * Limit how many Instances to update.
     */
    limit?: number
  }

  /**
   * Instance updateManyAndReturn
   */
  export type InstanceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instance
     */
    select?: InstanceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Instance
     */
    omit?: InstanceOmit<ExtArgs> | null
    /**
     * The data used to update Instances.
     */
    data: XOR<InstanceUpdateManyMutationInput, InstanceUncheckedUpdateManyInput>
    /**
     * Filter which Instances to update
     */
    where?: InstanceWhereInput
    /**
     * Limit how many Instances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstanceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Instance upsert
   */
  export type InstanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instance
     */
    select?: InstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instance
     */
    omit?: InstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstanceInclude<ExtArgs> | null
    /**
     * The filter to search for the Instance to update in case it exists.
     */
    where: InstanceWhereUniqueInput
    /**
     * In case the Instance found by the `where` argument doesn't exist, create a new Instance with this data.
     */
    create: XOR<InstanceCreateInput, InstanceUncheckedCreateInput>
    /**
     * In case the Instance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InstanceUpdateInput, InstanceUncheckedUpdateInput>
  }

  /**
   * Instance delete
   */
  export type InstanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instance
     */
    select?: InstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instance
     */
    omit?: InstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstanceInclude<ExtArgs> | null
    /**
     * Filter which Instance to delete.
     */
    where: InstanceWhereUniqueInput
  }

  /**
   * Instance deleteMany
   */
  export type InstanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Instances to delete
     */
    where?: InstanceWhereInput
    /**
     * Limit how many Instances to delete.
     */
    limit?: number
  }

  /**
   * Instance without action
   */
  export type InstanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instance
     */
    select?: InstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instance
     */
    omit?: InstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstanceInclude<ExtArgs> | null
  }


  /**
   * Model PrivateDataDisk
   */

  export type AggregatePrivateDataDisk = {
    _count: PrivateDataDiskCountAggregateOutputType | null
    _avg: PrivateDataDiskAvgAggregateOutputType | null
    _sum: PrivateDataDiskSumAggregateOutputType | null
    _min: PrivateDataDiskMinAggregateOutputType | null
    _max: PrivateDataDiskMaxAggregateOutputType | null
  }

  export type PrivateDataDiskAvgAggregateOutputType = {
    sizeGb: number | null
  }

  export type PrivateDataDiskSumAggregateOutputType = {
    sizeGb: number | null
  }

  export type PrivateDataDiskMinAggregateOutputType = {
    id: string | null
    name: string | null
    tenantId: string | null
    userId: string | null
    sizeGb: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PrivateDataDiskMaxAggregateOutputType = {
    id: string | null
    name: string | null
    tenantId: string | null
    userId: string | null
    sizeGb: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PrivateDataDiskCountAggregateOutputType = {
    id: number
    name: number
    tenantId: number
    userId: number
    sizeGb: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PrivateDataDiskAvgAggregateInputType = {
    sizeGb?: true
  }

  export type PrivateDataDiskSumAggregateInputType = {
    sizeGb?: true
  }

  export type PrivateDataDiskMinAggregateInputType = {
    id?: true
    name?: true
    tenantId?: true
    userId?: true
    sizeGb?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PrivateDataDiskMaxAggregateInputType = {
    id?: true
    name?: true
    tenantId?: true
    userId?: true
    sizeGb?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PrivateDataDiskCountAggregateInputType = {
    id?: true
    name?: true
    tenantId?: true
    userId?: true
    sizeGb?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PrivateDataDiskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PrivateDataDisk to aggregate.
     */
    where?: PrivateDataDiskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrivateDataDisks to fetch.
     */
    orderBy?: PrivateDataDiskOrderByWithRelationInput | PrivateDataDiskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PrivateDataDiskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrivateDataDisks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrivateDataDisks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PrivateDataDisks
    **/
    _count?: true | PrivateDataDiskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PrivateDataDiskAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PrivateDataDiskSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PrivateDataDiskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PrivateDataDiskMaxAggregateInputType
  }

  export type GetPrivateDataDiskAggregateType<T extends PrivateDataDiskAggregateArgs> = {
        [P in keyof T & keyof AggregatePrivateDataDisk]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrivateDataDisk[P]>
      : GetScalarType<T[P], AggregatePrivateDataDisk[P]>
  }




  export type PrivateDataDiskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrivateDataDiskWhereInput
    orderBy?: PrivateDataDiskOrderByWithAggregationInput | PrivateDataDiskOrderByWithAggregationInput[]
    by: PrivateDataDiskScalarFieldEnum[] | PrivateDataDiskScalarFieldEnum
    having?: PrivateDataDiskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PrivateDataDiskCountAggregateInputType | true
    _avg?: PrivateDataDiskAvgAggregateInputType
    _sum?: PrivateDataDiskSumAggregateInputType
    _min?: PrivateDataDiskMinAggregateInputType
    _max?: PrivateDataDiskMaxAggregateInputType
  }

  export type PrivateDataDiskGroupByOutputType = {
    id: string
    name: string
    tenantId: string
    userId: string
    sizeGb: number
    status: string
    createdAt: Date
    updatedAt: Date
    _count: PrivateDataDiskCountAggregateOutputType | null
    _avg: PrivateDataDiskAvgAggregateOutputType | null
    _sum: PrivateDataDiskSumAggregateOutputType | null
    _min: PrivateDataDiskMinAggregateOutputType | null
    _max: PrivateDataDiskMaxAggregateOutputType | null
  }

  type GetPrivateDataDiskGroupByPayload<T extends PrivateDataDiskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PrivateDataDiskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PrivateDataDiskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PrivateDataDiskGroupByOutputType[P]>
            : GetScalarType<T[P], PrivateDataDiskGroupByOutputType[P]>
        }
      >
    >


  export type PrivateDataDiskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    tenantId?: boolean
    userId?: boolean
    sizeGb?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["privateDataDisk"]>

  export type PrivateDataDiskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    tenantId?: boolean
    userId?: boolean
    sizeGb?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["privateDataDisk"]>

  export type PrivateDataDiskSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    tenantId?: boolean
    userId?: boolean
    sizeGb?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["privateDataDisk"]>

  export type PrivateDataDiskSelectScalar = {
    id?: boolean
    name?: boolean
    tenantId?: boolean
    userId?: boolean
    sizeGb?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PrivateDataDiskOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "tenantId" | "userId" | "sizeGb" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["privateDataDisk"]>
  export type PrivateDataDiskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PrivateDataDiskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PrivateDataDiskIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PrivateDataDiskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PrivateDataDisk"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      tenantId: string
      userId: string
      sizeGb: number
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["privateDataDisk"]>
    composites: {}
  }

  type PrivateDataDiskGetPayload<S extends boolean | null | undefined | PrivateDataDiskDefaultArgs> = $Result.GetResult<Prisma.$PrivateDataDiskPayload, S>

  type PrivateDataDiskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PrivateDataDiskFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PrivateDataDiskCountAggregateInputType | true
    }

  export interface PrivateDataDiskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PrivateDataDisk'], meta: { name: 'PrivateDataDisk' } }
    /**
     * Find zero or one PrivateDataDisk that matches the filter.
     * @param {PrivateDataDiskFindUniqueArgs} args - Arguments to find a PrivateDataDisk
     * @example
     * // Get one PrivateDataDisk
     * const privateDataDisk = await prisma.privateDataDisk.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PrivateDataDiskFindUniqueArgs>(args: SelectSubset<T, PrivateDataDiskFindUniqueArgs<ExtArgs>>): Prisma__PrivateDataDiskClient<$Result.GetResult<Prisma.$PrivateDataDiskPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PrivateDataDisk that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PrivateDataDiskFindUniqueOrThrowArgs} args - Arguments to find a PrivateDataDisk
     * @example
     * // Get one PrivateDataDisk
     * const privateDataDisk = await prisma.privateDataDisk.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PrivateDataDiskFindUniqueOrThrowArgs>(args: SelectSubset<T, PrivateDataDiskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PrivateDataDiskClient<$Result.GetResult<Prisma.$PrivateDataDiskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PrivateDataDisk that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivateDataDiskFindFirstArgs} args - Arguments to find a PrivateDataDisk
     * @example
     * // Get one PrivateDataDisk
     * const privateDataDisk = await prisma.privateDataDisk.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PrivateDataDiskFindFirstArgs>(args?: SelectSubset<T, PrivateDataDiskFindFirstArgs<ExtArgs>>): Prisma__PrivateDataDiskClient<$Result.GetResult<Prisma.$PrivateDataDiskPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PrivateDataDisk that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivateDataDiskFindFirstOrThrowArgs} args - Arguments to find a PrivateDataDisk
     * @example
     * // Get one PrivateDataDisk
     * const privateDataDisk = await prisma.privateDataDisk.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PrivateDataDiskFindFirstOrThrowArgs>(args?: SelectSubset<T, PrivateDataDiskFindFirstOrThrowArgs<ExtArgs>>): Prisma__PrivateDataDiskClient<$Result.GetResult<Prisma.$PrivateDataDiskPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PrivateDataDisks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivateDataDiskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PrivateDataDisks
     * const privateDataDisks = await prisma.privateDataDisk.findMany()
     * 
     * // Get first 10 PrivateDataDisks
     * const privateDataDisks = await prisma.privateDataDisk.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const privateDataDiskWithIdOnly = await prisma.privateDataDisk.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PrivateDataDiskFindManyArgs>(args?: SelectSubset<T, PrivateDataDiskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrivateDataDiskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PrivateDataDisk.
     * @param {PrivateDataDiskCreateArgs} args - Arguments to create a PrivateDataDisk.
     * @example
     * // Create one PrivateDataDisk
     * const PrivateDataDisk = await prisma.privateDataDisk.create({
     *   data: {
     *     // ... data to create a PrivateDataDisk
     *   }
     * })
     * 
     */
    create<T extends PrivateDataDiskCreateArgs>(args: SelectSubset<T, PrivateDataDiskCreateArgs<ExtArgs>>): Prisma__PrivateDataDiskClient<$Result.GetResult<Prisma.$PrivateDataDiskPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PrivateDataDisks.
     * @param {PrivateDataDiskCreateManyArgs} args - Arguments to create many PrivateDataDisks.
     * @example
     * // Create many PrivateDataDisks
     * const privateDataDisk = await prisma.privateDataDisk.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PrivateDataDiskCreateManyArgs>(args?: SelectSubset<T, PrivateDataDiskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PrivateDataDisks and returns the data saved in the database.
     * @param {PrivateDataDiskCreateManyAndReturnArgs} args - Arguments to create many PrivateDataDisks.
     * @example
     * // Create many PrivateDataDisks
     * const privateDataDisk = await prisma.privateDataDisk.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PrivateDataDisks and only return the `id`
     * const privateDataDiskWithIdOnly = await prisma.privateDataDisk.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PrivateDataDiskCreateManyAndReturnArgs>(args?: SelectSubset<T, PrivateDataDiskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrivateDataDiskPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PrivateDataDisk.
     * @param {PrivateDataDiskDeleteArgs} args - Arguments to delete one PrivateDataDisk.
     * @example
     * // Delete one PrivateDataDisk
     * const PrivateDataDisk = await prisma.privateDataDisk.delete({
     *   where: {
     *     // ... filter to delete one PrivateDataDisk
     *   }
     * })
     * 
     */
    delete<T extends PrivateDataDiskDeleteArgs>(args: SelectSubset<T, PrivateDataDiskDeleteArgs<ExtArgs>>): Prisma__PrivateDataDiskClient<$Result.GetResult<Prisma.$PrivateDataDiskPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PrivateDataDisk.
     * @param {PrivateDataDiskUpdateArgs} args - Arguments to update one PrivateDataDisk.
     * @example
     * // Update one PrivateDataDisk
     * const privateDataDisk = await prisma.privateDataDisk.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PrivateDataDiskUpdateArgs>(args: SelectSubset<T, PrivateDataDiskUpdateArgs<ExtArgs>>): Prisma__PrivateDataDiskClient<$Result.GetResult<Prisma.$PrivateDataDiskPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PrivateDataDisks.
     * @param {PrivateDataDiskDeleteManyArgs} args - Arguments to filter PrivateDataDisks to delete.
     * @example
     * // Delete a few PrivateDataDisks
     * const { count } = await prisma.privateDataDisk.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PrivateDataDiskDeleteManyArgs>(args?: SelectSubset<T, PrivateDataDiskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PrivateDataDisks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivateDataDiskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PrivateDataDisks
     * const privateDataDisk = await prisma.privateDataDisk.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PrivateDataDiskUpdateManyArgs>(args: SelectSubset<T, PrivateDataDiskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PrivateDataDisks and returns the data updated in the database.
     * @param {PrivateDataDiskUpdateManyAndReturnArgs} args - Arguments to update many PrivateDataDisks.
     * @example
     * // Update many PrivateDataDisks
     * const privateDataDisk = await prisma.privateDataDisk.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PrivateDataDisks and only return the `id`
     * const privateDataDiskWithIdOnly = await prisma.privateDataDisk.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PrivateDataDiskUpdateManyAndReturnArgs>(args: SelectSubset<T, PrivateDataDiskUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrivateDataDiskPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PrivateDataDisk.
     * @param {PrivateDataDiskUpsertArgs} args - Arguments to update or create a PrivateDataDisk.
     * @example
     * // Update or create a PrivateDataDisk
     * const privateDataDisk = await prisma.privateDataDisk.upsert({
     *   create: {
     *     // ... data to create a PrivateDataDisk
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PrivateDataDisk we want to update
     *   }
     * })
     */
    upsert<T extends PrivateDataDiskUpsertArgs>(args: SelectSubset<T, PrivateDataDiskUpsertArgs<ExtArgs>>): Prisma__PrivateDataDiskClient<$Result.GetResult<Prisma.$PrivateDataDiskPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PrivateDataDisks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivateDataDiskCountArgs} args - Arguments to filter PrivateDataDisks to count.
     * @example
     * // Count the number of PrivateDataDisks
     * const count = await prisma.privateDataDisk.count({
     *   where: {
     *     // ... the filter for the PrivateDataDisks we want to count
     *   }
     * })
    **/
    count<T extends PrivateDataDiskCountArgs>(
      args?: Subset<T, PrivateDataDiskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PrivateDataDiskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PrivateDataDisk.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivateDataDiskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PrivateDataDiskAggregateArgs>(args: Subset<T, PrivateDataDiskAggregateArgs>): Prisma.PrismaPromise<GetPrivateDataDiskAggregateType<T>>

    /**
     * Group by PrivateDataDisk.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivateDataDiskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PrivateDataDiskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PrivateDataDiskGroupByArgs['orderBy'] }
        : { orderBy?: PrivateDataDiskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PrivateDataDiskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrivateDataDiskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PrivateDataDisk model
   */
  readonly fields: PrivateDataDiskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PrivateDataDisk.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PrivateDataDiskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PrivateDataDisk model
   */
  interface PrivateDataDiskFieldRefs {
    readonly id: FieldRef<"PrivateDataDisk", 'String'>
    readonly name: FieldRef<"PrivateDataDisk", 'String'>
    readonly tenantId: FieldRef<"PrivateDataDisk", 'String'>
    readonly userId: FieldRef<"PrivateDataDisk", 'String'>
    readonly sizeGb: FieldRef<"PrivateDataDisk", 'Int'>
    readonly status: FieldRef<"PrivateDataDisk", 'String'>
    readonly createdAt: FieldRef<"PrivateDataDisk", 'DateTime'>
    readonly updatedAt: FieldRef<"PrivateDataDisk", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PrivateDataDisk findUnique
   */
  export type PrivateDataDiskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateDataDisk
     */
    select?: PrivateDataDiskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateDataDisk
     */
    omit?: PrivateDataDiskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateDataDiskInclude<ExtArgs> | null
    /**
     * Filter, which PrivateDataDisk to fetch.
     */
    where: PrivateDataDiskWhereUniqueInput
  }

  /**
   * PrivateDataDisk findUniqueOrThrow
   */
  export type PrivateDataDiskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateDataDisk
     */
    select?: PrivateDataDiskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateDataDisk
     */
    omit?: PrivateDataDiskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateDataDiskInclude<ExtArgs> | null
    /**
     * Filter, which PrivateDataDisk to fetch.
     */
    where: PrivateDataDiskWhereUniqueInput
  }

  /**
   * PrivateDataDisk findFirst
   */
  export type PrivateDataDiskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateDataDisk
     */
    select?: PrivateDataDiskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateDataDisk
     */
    omit?: PrivateDataDiskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateDataDiskInclude<ExtArgs> | null
    /**
     * Filter, which PrivateDataDisk to fetch.
     */
    where?: PrivateDataDiskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrivateDataDisks to fetch.
     */
    orderBy?: PrivateDataDiskOrderByWithRelationInput | PrivateDataDiskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PrivateDataDisks.
     */
    cursor?: PrivateDataDiskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrivateDataDisks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrivateDataDisks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PrivateDataDisks.
     */
    distinct?: PrivateDataDiskScalarFieldEnum | PrivateDataDiskScalarFieldEnum[]
  }

  /**
   * PrivateDataDisk findFirstOrThrow
   */
  export type PrivateDataDiskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateDataDisk
     */
    select?: PrivateDataDiskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateDataDisk
     */
    omit?: PrivateDataDiskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateDataDiskInclude<ExtArgs> | null
    /**
     * Filter, which PrivateDataDisk to fetch.
     */
    where?: PrivateDataDiskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrivateDataDisks to fetch.
     */
    orderBy?: PrivateDataDiskOrderByWithRelationInput | PrivateDataDiskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PrivateDataDisks.
     */
    cursor?: PrivateDataDiskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrivateDataDisks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrivateDataDisks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PrivateDataDisks.
     */
    distinct?: PrivateDataDiskScalarFieldEnum | PrivateDataDiskScalarFieldEnum[]
  }

  /**
   * PrivateDataDisk findMany
   */
  export type PrivateDataDiskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateDataDisk
     */
    select?: PrivateDataDiskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateDataDisk
     */
    omit?: PrivateDataDiskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateDataDiskInclude<ExtArgs> | null
    /**
     * Filter, which PrivateDataDisks to fetch.
     */
    where?: PrivateDataDiskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrivateDataDisks to fetch.
     */
    orderBy?: PrivateDataDiskOrderByWithRelationInput | PrivateDataDiskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PrivateDataDisks.
     */
    cursor?: PrivateDataDiskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrivateDataDisks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrivateDataDisks.
     */
    skip?: number
    distinct?: PrivateDataDiskScalarFieldEnum | PrivateDataDiskScalarFieldEnum[]
  }

  /**
   * PrivateDataDisk create
   */
  export type PrivateDataDiskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateDataDisk
     */
    select?: PrivateDataDiskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateDataDisk
     */
    omit?: PrivateDataDiskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateDataDiskInclude<ExtArgs> | null
    /**
     * The data needed to create a PrivateDataDisk.
     */
    data: XOR<PrivateDataDiskCreateInput, PrivateDataDiskUncheckedCreateInput>
  }

  /**
   * PrivateDataDisk createMany
   */
  export type PrivateDataDiskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PrivateDataDisks.
     */
    data: PrivateDataDiskCreateManyInput | PrivateDataDiskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PrivateDataDisk createManyAndReturn
   */
  export type PrivateDataDiskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateDataDisk
     */
    select?: PrivateDataDiskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateDataDisk
     */
    omit?: PrivateDataDiskOmit<ExtArgs> | null
    /**
     * The data used to create many PrivateDataDisks.
     */
    data: PrivateDataDiskCreateManyInput | PrivateDataDiskCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateDataDiskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PrivateDataDisk update
   */
  export type PrivateDataDiskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateDataDisk
     */
    select?: PrivateDataDiskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateDataDisk
     */
    omit?: PrivateDataDiskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateDataDiskInclude<ExtArgs> | null
    /**
     * The data needed to update a PrivateDataDisk.
     */
    data: XOR<PrivateDataDiskUpdateInput, PrivateDataDiskUncheckedUpdateInput>
    /**
     * Choose, which PrivateDataDisk to update.
     */
    where: PrivateDataDiskWhereUniqueInput
  }

  /**
   * PrivateDataDisk updateMany
   */
  export type PrivateDataDiskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PrivateDataDisks.
     */
    data: XOR<PrivateDataDiskUpdateManyMutationInput, PrivateDataDiskUncheckedUpdateManyInput>
    /**
     * Filter which PrivateDataDisks to update
     */
    where?: PrivateDataDiskWhereInput
    /**
     * Limit how many PrivateDataDisks to update.
     */
    limit?: number
  }

  /**
   * PrivateDataDisk updateManyAndReturn
   */
  export type PrivateDataDiskUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateDataDisk
     */
    select?: PrivateDataDiskSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateDataDisk
     */
    omit?: PrivateDataDiskOmit<ExtArgs> | null
    /**
     * The data used to update PrivateDataDisks.
     */
    data: XOR<PrivateDataDiskUpdateManyMutationInput, PrivateDataDiskUncheckedUpdateManyInput>
    /**
     * Filter which PrivateDataDisks to update
     */
    where?: PrivateDataDiskWhereInput
    /**
     * Limit how many PrivateDataDisks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateDataDiskIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PrivateDataDisk upsert
   */
  export type PrivateDataDiskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateDataDisk
     */
    select?: PrivateDataDiskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateDataDisk
     */
    omit?: PrivateDataDiskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateDataDiskInclude<ExtArgs> | null
    /**
     * The filter to search for the PrivateDataDisk to update in case it exists.
     */
    where: PrivateDataDiskWhereUniqueInput
    /**
     * In case the PrivateDataDisk found by the `where` argument doesn't exist, create a new PrivateDataDisk with this data.
     */
    create: XOR<PrivateDataDiskCreateInput, PrivateDataDiskUncheckedCreateInput>
    /**
     * In case the PrivateDataDisk was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PrivateDataDiskUpdateInput, PrivateDataDiskUncheckedUpdateInput>
  }

  /**
   * PrivateDataDisk delete
   */
  export type PrivateDataDiskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateDataDisk
     */
    select?: PrivateDataDiskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateDataDisk
     */
    omit?: PrivateDataDiskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateDataDiskInclude<ExtArgs> | null
    /**
     * Filter which PrivateDataDisk to delete.
     */
    where: PrivateDataDiskWhereUniqueInput
  }

  /**
   * PrivateDataDisk deleteMany
   */
  export type PrivateDataDiskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PrivateDataDisks to delete
     */
    where?: PrivateDataDiskWhereInput
    /**
     * Limit how many PrivateDataDisks to delete.
     */
    limit?: number
  }

  /**
   * PrivateDataDisk without action
   */
  export type PrivateDataDiskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateDataDisk
     */
    select?: PrivateDataDiskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateDataDisk
     */
    omit?: PrivateDataDiskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateDataDiskInclude<ExtArgs> | null
  }


  /**
   * Model Vpc
   */

  export type AggregateVpc = {
    _count: VpcCountAggregateOutputType | null
    _avg: VpcAvgAggregateOutputType | null
    _sum: VpcSumAggregateOutputType | null
    _min: VpcMinAggregateOutputType | null
    _max: VpcMaxAggregateOutputType | null
  }

  export type VpcAvgAggregateOutputType = {
    vlanId: number | null
  }

  export type VpcSumAggregateOutputType = {
    vlanId: number | null
  }

  export type VpcMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    tenantId: string | null
    userId: string | null
    cidrBlock: string | null
    edgeDataCenterId: string | null
    vlanId: number | null
    enableDns: boolean | null
    status: $Enums.VpcStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
  }

  export type VpcMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    tenantId: string | null
    userId: string | null
    cidrBlock: string | null
    edgeDataCenterId: string | null
    vlanId: number | null
    enableDns: boolean | null
    status: $Enums.VpcStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
  }

  export type VpcCountAggregateOutputType = {
    id: number
    name: number
    description: number
    tenantId: number
    userId: number
    cidrBlock: number
    edgeDataCenterId: number
    vlanId: number
    enableDns: number
    dnsServers: number
    status: number
    createdAt: number
    updatedAt: number
    createdBy: number
    updatedBy: number
    _all: number
  }


  export type VpcAvgAggregateInputType = {
    vlanId?: true
  }

  export type VpcSumAggregateInputType = {
    vlanId?: true
  }

  export type VpcMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    tenantId?: true
    userId?: true
    cidrBlock?: true
    edgeDataCenterId?: true
    vlanId?: true
    enableDns?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
  }

  export type VpcMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    tenantId?: true
    userId?: true
    cidrBlock?: true
    edgeDataCenterId?: true
    vlanId?: true
    enableDns?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
  }

  export type VpcCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    tenantId?: true
    userId?: true
    cidrBlock?: true
    edgeDataCenterId?: true
    vlanId?: true
    enableDns?: true
    dnsServers?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    _all?: true
  }

  export type VpcAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vpc to aggregate.
     */
    where?: VpcWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vpcs to fetch.
     */
    orderBy?: VpcOrderByWithRelationInput | VpcOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VpcWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vpcs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vpcs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Vpcs
    **/
    _count?: true | VpcCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VpcAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VpcSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VpcMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VpcMaxAggregateInputType
  }

  export type GetVpcAggregateType<T extends VpcAggregateArgs> = {
        [P in keyof T & keyof AggregateVpc]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVpc[P]>
      : GetScalarType<T[P], AggregateVpc[P]>
  }




  export type VpcGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VpcWhereInput
    orderBy?: VpcOrderByWithAggregationInput | VpcOrderByWithAggregationInput[]
    by: VpcScalarFieldEnum[] | VpcScalarFieldEnum
    having?: VpcScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VpcCountAggregateInputType | true
    _avg?: VpcAvgAggregateInputType
    _sum?: VpcSumAggregateInputType
    _min?: VpcMinAggregateInputType
    _max?: VpcMaxAggregateInputType
  }

  export type VpcGroupByOutputType = {
    id: string
    name: string
    description: string | null
    tenantId: string
    userId: string
    cidrBlock: string
    edgeDataCenterId: string | null
    vlanId: number | null
    enableDns: boolean
    dnsServers: JsonValue | null
    status: $Enums.VpcStatus
    createdAt: Date
    updatedAt: Date
    createdBy: string | null
    updatedBy: string | null
    _count: VpcCountAggregateOutputType | null
    _avg: VpcAvgAggregateOutputType | null
    _sum: VpcSumAggregateOutputType | null
    _min: VpcMinAggregateOutputType | null
    _max: VpcMaxAggregateOutputType | null
  }

  type GetVpcGroupByPayload<T extends VpcGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VpcGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VpcGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VpcGroupByOutputType[P]>
            : GetScalarType<T[P], VpcGroupByOutputType[P]>
        }
      >
    >


  export type VpcSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    tenantId?: boolean
    userId?: boolean
    cidrBlock?: boolean
    edgeDataCenterId?: boolean
    vlanId?: boolean
    enableDns?: boolean
    dnsServers?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    subnets?: boolean | Vpc$subnetsArgs<ExtArgs>
    creator?: boolean | Vpc$creatorArgs<ExtArgs>
    updater?: boolean | Vpc$updaterArgs<ExtArgs>
    _count?: boolean | VpcCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vpc"]>

  export type VpcSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    tenantId?: boolean
    userId?: boolean
    cidrBlock?: boolean
    edgeDataCenterId?: boolean
    vlanId?: boolean
    enableDns?: boolean
    dnsServers?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    creator?: boolean | Vpc$creatorArgs<ExtArgs>
    updater?: boolean | Vpc$updaterArgs<ExtArgs>
  }, ExtArgs["result"]["vpc"]>

  export type VpcSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    tenantId?: boolean
    userId?: boolean
    cidrBlock?: boolean
    edgeDataCenterId?: boolean
    vlanId?: boolean
    enableDns?: boolean
    dnsServers?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    creator?: boolean | Vpc$creatorArgs<ExtArgs>
    updater?: boolean | Vpc$updaterArgs<ExtArgs>
  }, ExtArgs["result"]["vpc"]>

  export type VpcSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    tenantId?: boolean
    userId?: boolean
    cidrBlock?: boolean
    edgeDataCenterId?: boolean
    vlanId?: boolean
    enableDns?: boolean
    dnsServers?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
  }

  export type VpcOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "tenantId" | "userId" | "cidrBlock" | "edgeDataCenterId" | "vlanId" | "enableDns" | "dnsServers" | "status" | "createdAt" | "updatedAt" | "createdBy" | "updatedBy", ExtArgs["result"]["vpc"]>
  export type VpcInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    subnets?: boolean | Vpc$subnetsArgs<ExtArgs>
    creator?: boolean | Vpc$creatorArgs<ExtArgs>
    updater?: boolean | Vpc$updaterArgs<ExtArgs>
    _count?: boolean | VpcCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VpcIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    creator?: boolean | Vpc$creatorArgs<ExtArgs>
    updater?: boolean | Vpc$updaterArgs<ExtArgs>
  }
  export type VpcIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    creator?: boolean | Vpc$creatorArgs<ExtArgs>
    updater?: boolean | Vpc$updaterArgs<ExtArgs>
  }

  export type $VpcPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Vpc"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      subnets: Prisma.$SubnetPayload<ExtArgs>[]
      creator: Prisma.$UserPayload<ExtArgs> | null
      updater: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      tenantId: string
      userId: string
      cidrBlock: string
      edgeDataCenterId: string | null
      vlanId: number | null
      enableDns: boolean
      dnsServers: Prisma.JsonValue | null
      status: $Enums.VpcStatus
      createdAt: Date
      updatedAt: Date
      createdBy: string | null
      updatedBy: string | null
    }, ExtArgs["result"]["vpc"]>
    composites: {}
  }

  type VpcGetPayload<S extends boolean | null | undefined | VpcDefaultArgs> = $Result.GetResult<Prisma.$VpcPayload, S>

  type VpcCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VpcFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VpcCountAggregateInputType | true
    }

  export interface VpcDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Vpc'], meta: { name: 'Vpc' } }
    /**
     * Find zero or one Vpc that matches the filter.
     * @param {VpcFindUniqueArgs} args - Arguments to find a Vpc
     * @example
     * // Get one Vpc
     * const vpc = await prisma.vpc.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VpcFindUniqueArgs>(args: SelectSubset<T, VpcFindUniqueArgs<ExtArgs>>): Prisma__VpcClient<$Result.GetResult<Prisma.$VpcPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Vpc that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VpcFindUniqueOrThrowArgs} args - Arguments to find a Vpc
     * @example
     * // Get one Vpc
     * const vpc = await prisma.vpc.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VpcFindUniqueOrThrowArgs>(args: SelectSubset<T, VpcFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VpcClient<$Result.GetResult<Prisma.$VpcPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vpc that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VpcFindFirstArgs} args - Arguments to find a Vpc
     * @example
     * // Get one Vpc
     * const vpc = await prisma.vpc.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VpcFindFirstArgs>(args?: SelectSubset<T, VpcFindFirstArgs<ExtArgs>>): Prisma__VpcClient<$Result.GetResult<Prisma.$VpcPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vpc that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VpcFindFirstOrThrowArgs} args - Arguments to find a Vpc
     * @example
     * // Get one Vpc
     * const vpc = await prisma.vpc.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VpcFindFirstOrThrowArgs>(args?: SelectSubset<T, VpcFindFirstOrThrowArgs<ExtArgs>>): Prisma__VpcClient<$Result.GetResult<Prisma.$VpcPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Vpcs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VpcFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vpcs
     * const vpcs = await prisma.vpc.findMany()
     * 
     * // Get first 10 Vpcs
     * const vpcs = await prisma.vpc.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vpcWithIdOnly = await prisma.vpc.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VpcFindManyArgs>(args?: SelectSubset<T, VpcFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VpcPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Vpc.
     * @param {VpcCreateArgs} args - Arguments to create a Vpc.
     * @example
     * // Create one Vpc
     * const Vpc = await prisma.vpc.create({
     *   data: {
     *     // ... data to create a Vpc
     *   }
     * })
     * 
     */
    create<T extends VpcCreateArgs>(args: SelectSubset<T, VpcCreateArgs<ExtArgs>>): Prisma__VpcClient<$Result.GetResult<Prisma.$VpcPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Vpcs.
     * @param {VpcCreateManyArgs} args - Arguments to create many Vpcs.
     * @example
     * // Create many Vpcs
     * const vpc = await prisma.vpc.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VpcCreateManyArgs>(args?: SelectSubset<T, VpcCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Vpcs and returns the data saved in the database.
     * @param {VpcCreateManyAndReturnArgs} args - Arguments to create many Vpcs.
     * @example
     * // Create many Vpcs
     * const vpc = await prisma.vpc.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Vpcs and only return the `id`
     * const vpcWithIdOnly = await prisma.vpc.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VpcCreateManyAndReturnArgs>(args?: SelectSubset<T, VpcCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VpcPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Vpc.
     * @param {VpcDeleteArgs} args - Arguments to delete one Vpc.
     * @example
     * // Delete one Vpc
     * const Vpc = await prisma.vpc.delete({
     *   where: {
     *     // ... filter to delete one Vpc
     *   }
     * })
     * 
     */
    delete<T extends VpcDeleteArgs>(args: SelectSubset<T, VpcDeleteArgs<ExtArgs>>): Prisma__VpcClient<$Result.GetResult<Prisma.$VpcPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Vpc.
     * @param {VpcUpdateArgs} args - Arguments to update one Vpc.
     * @example
     * // Update one Vpc
     * const vpc = await prisma.vpc.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VpcUpdateArgs>(args: SelectSubset<T, VpcUpdateArgs<ExtArgs>>): Prisma__VpcClient<$Result.GetResult<Prisma.$VpcPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Vpcs.
     * @param {VpcDeleteManyArgs} args - Arguments to filter Vpcs to delete.
     * @example
     * // Delete a few Vpcs
     * const { count } = await prisma.vpc.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VpcDeleteManyArgs>(args?: SelectSubset<T, VpcDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vpcs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VpcUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vpcs
     * const vpc = await prisma.vpc.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VpcUpdateManyArgs>(args: SelectSubset<T, VpcUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vpcs and returns the data updated in the database.
     * @param {VpcUpdateManyAndReturnArgs} args - Arguments to update many Vpcs.
     * @example
     * // Update many Vpcs
     * const vpc = await prisma.vpc.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Vpcs and only return the `id`
     * const vpcWithIdOnly = await prisma.vpc.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VpcUpdateManyAndReturnArgs>(args: SelectSubset<T, VpcUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VpcPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Vpc.
     * @param {VpcUpsertArgs} args - Arguments to update or create a Vpc.
     * @example
     * // Update or create a Vpc
     * const vpc = await prisma.vpc.upsert({
     *   create: {
     *     // ... data to create a Vpc
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vpc we want to update
     *   }
     * })
     */
    upsert<T extends VpcUpsertArgs>(args: SelectSubset<T, VpcUpsertArgs<ExtArgs>>): Prisma__VpcClient<$Result.GetResult<Prisma.$VpcPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Vpcs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VpcCountArgs} args - Arguments to filter Vpcs to count.
     * @example
     * // Count the number of Vpcs
     * const count = await prisma.vpc.count({
     *   where: {
     *     // ... the filter for the Vpcs we want to count
     *   }
     * })
    **/
    count<T extends VpcCountArgs>(
      args?: Subset<T, VpcCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VpcCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vpc.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VpcAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VpcAggregateArgs>(args: Subset<T, VpcAggregateArgs>): Prisma.PrismaPromise<GetVpcAggregateType<T>>

    /**
     * Group by Vpc.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VpcGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VpcGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VpcGroupByArgs['orderBy'] }
        : { orderBy?: VpcGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VpcGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVpcGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Vpc model
   */
  readonly fields: VpcFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Vpc.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VpcClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    subnets<T extends Vpc$subnetsArgs<ExtArgs> = {}>(args?: Subset<T, Vpc$subnetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubnetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    creator<T extends Vpc$creatorArgs<ExtArgs> = {}>(args?: Subset<T, Vpc$creatorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    updater<T extends Vpc$updaterArgs<ExtArgs> = {}>(args?: Subset<T, Vpc$updaterArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Vpc model
   */
  interface VpcFieldRefs {
    readonly id: FieldRef<"Vpc", 'String'>
    readonly name: FieldRef<"Vpc", 'String'>
    readonly description: FieldRef<"Vpc", 'String'>
    readonly tenantId: FieldRef<"Vpc", 'String'>
    readonly userId: FieldRef<"Vpc", 'String'>
    readonly cidrBlock: FieldRef<"Vpc", 'String'>
    readonly edgeDataCenterId: FieldRef<"Vpc", 'String'>
    readonly vlanId: FieldRef<"Vpc", 'Int'>
    readonly enableDns: FieldRef<"Vpc", 'Boolean'>
    readonly dnsServers: FieldRef<"Vpc", 'Json'>
    readonly status: FieldRef<"Vpc", 'VpcStatus'>
    readonly createdAt: FieldRef<"Vpc", 'DateTime'>
    readonly updatedAt: FieldRef<"Vpc", 'DateTime'>
    readonly createdBy: FieldRef<"Vpc", 'String'>
    readonly updatedBy: FieldRef<"Vpc", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Vpc findUnique
   */
  export type VpcFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vpc
     */
    select?: VpcSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vpc
     */
    omit?: VpcOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VpcInclude<ExtArgs> | null
    /**
     * Filter, which Vpc to fetch.
     */
    where: VpcWhereUniqueInput
  }

  /**
   * Vpc findUniqueOrThrow
   */
  export type VpcFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vpc
     */
    select?: VpcSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vpc
     */
    omit?: VpcOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VpcInclude<ExtArgs> | null
    /**
     * Filter, which Vpc to fetch.
     */
    where: VpcWhereUniqueInput
  }

  /**
   * Vpc findFirst
   */
  export type VpcFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vpc
     */
    select?: VpcSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vpc
     */
    omit?: VpcOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VpcInclude<ExtArgs> | null
    /**
     * Filter, which Vpc to fetch.
     */
    where?: VpcWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vpcs to fetch.
     */
    orderBy?: VpcOrderByWithRelationInput | VpcOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vpcs.
     */
    cursor?: VpcWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vpcs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vpcs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vpcs.
     */
    distinct?: VpcScalarFieldEnum | VpcScalarFieldEnum[]
  }

  /**
   * Vpc findFirstOrThrow
   */
  export type VpcFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vpc
     */
    select?: VpcSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vpc
     */
    omit?: VpcOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VpcInclude<ExtArgs> | null
    /**
     * Filter, which Vpc to fetch.
     */
    where?: VpcWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vpcs to fetch.
     */
    orderBy?: VpcOrderByWithRelationInput | VpcOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vpcs.
     */
    cursor?: VpcWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vpcs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vpcs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vpcs.
     */
    distinct?: VpcScalarFieldEnum | VpcScalarFieldEnum[]
  }

  /**
   * Vpc findMany
   */
  export type VpcFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vpc
     */
    select?: VpcSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vpc
     */
    omit?: VpcOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VpcInclude<ExtArgs> | null
    /**
     * Filter, which Vpcs to fetch.
     */
    where?: VpcWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vpcs to fetch.
     */
    orderBy?: VpcOrderByWithRelationInput | VpcOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Vpcs.
     */
    cursor?: VpcWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vpcs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vpcs.
     */
    skip?: number
    distinct?: VpcScalarFieldEnum | VpcScalarFieldEnum[]
  }

  /**
   * Vpc create
   */
  export type VpcCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vpc
     */
    select?: VpcSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vpc
     */
    omit?: VpcOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VpcInclude<ExtArgs> | null
    /**
     * The data needed to create a Vpc.
     */
    data: XOR<VpcCreateInput, VpcUncheckedCreateInput>
  }

  /**
   * Vpc createMany
   */
  export type VpcCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Vpcs.
     */
    data: VpcCreateManyInput | VpcCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Vpc createManyAndReturn
   */
  export type VpcCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vpc
     */
    select?: VpcSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Vpc
     */
    omit?: VpcOmit<ExtArgs> | null
    /**
     * The data used to create many Vpcs.
     */
    data: VpcCreateManyInput | VpcCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VpcIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Vpc update
   */
  export type VpcUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vpc
     */
    select?: VpcSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vpc
     */
    omit?: VpcOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VpcInclude<ExtArgs> | null
    /**
     * The data needed to update a Vpc.
     */
    data: XOR<VpcUpdateInput, VpcUncheckedUpdateInput>
    /**
     * Choose, which Vpc to update.
     */
    where: VpcWhereUniqueInput
  }

  /**
   * Vpc updateMany
   */
  export type VpcUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Vpcs.
     */
    data: XOR<VpcUpdateManyMutationInput, VpcUncheckedUpdateManyInput>
    /**
     * Filter which Vpcs to update
     */
    where?: VpcWhereInput
    /**
     * Limit how many Vpcs to update.
     */
    limit?: number
  }

  /**
   * Vpc updateManyAndReturn
   */
  export type VpcUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vpc
     */
    select?: VpcSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Vpc
     */
    omit?: VpcOmit<ExtArgs> | null
    /**
     * The data used to update Vpcs.
     */
    data: XOR<VpcUpdateManyMutationInput, VpcUncheckedUpdateManyInput>
    /**
     * Filter which Vpcs to update
     */
    where?: VpcWhereInput
    /**
     * Limit how many Vpcs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VpcIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Vpc upsert
   */
  export type VpcUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vpc
     */
    select?: VpcSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vpc
     */
    omit?: VpcOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VpcInclude<ExtArgs> | null
    /**
     * The filter to search for the Vpc to update in case it exists.
     */
    where: VpcWhereUniqueInput
    /**
     * In case the Vpc found by the `where` argument doesn't exist, create a new Vpc with this data.
     */
    create: XOR<VpcCreateInput, VpcUncheckedCreateInput>
    /**
     * In case the Vpc was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VpcUpdateInput, VpcUncheckedUpdateInput>
  }

  /**
   * Vpc delete
   */
  export type VpcDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vpc
     */
    select?: VpcSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vpc
     */
    omit?: VpcOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VpcInclude<ExtArgs> | null
    /**
     * Filter which Vpc to delete.
     */
    where: VpcWhereUniqueInput
  }

  /**
   * Vpc deleteMany
   */
  export type VpcDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vpcs to delete
     */
    where?: VpcWhereInput
    /**
     * Limit how many Vpcs to delete.
     */
    limit?: number
  }

  /**
   * Vpc.subnets
   */
  export type Vpc$subnetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subnet
     */
    select?: SubnetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subnet
     */
    omit?: SubnetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubnetInclude<ExtArgs> | null
    where?: SubnetWhereInput
    orderBy?: SubnetOrderByWithRelationInput | SubnetOrderByWithRelationInput[]
    cursor?: SubnetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubnetScalarFieldEnum | SubnetScalarFieldEnum[]
  }

  /**
   * Vpc.creator
   */
  export type Vpc$creatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Vpc.updater
   */
  export type Vpc$updaterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Vpc without action
   */
  export type VpcDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vpc
     */
    select?: VpcSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vpc
     */
    omit?: VpcOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VpcInclude<ExtArgs> | null
  }


  /**
   * Model Place
   */

  export type AggregatePlace = {
    _count: PlaceCountAggregateOutputType | null
    _min: PlaceMinAggregateOutputType | null
    _max: PlaceMaxAggregateOutputType | null
  }

  export type PlaceMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    tenantId: string | null
    subnetId: string | null
    location: string | null
    status: $Enums.PlaceStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
  }

  export type PlaceMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    tenantId: string | null
    subnetId: string | null
    location: string | null
    status: $Enums.PlaceStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
  }

  export type PlaceCountAggregateOutputType = {
    id: number
    name: number
    description: number
    tenantId: number
    subnetId: number
    location: number
    status: number
    createdAt: number
    updatedAt: number
    createdBy: number
    updatedBy: number
    _all: number
  }


  export type PlaceMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    tenantId?: true
    subnetId?: true
    location?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
  }

  export type PlaceMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    tenantId?: true
    subnetId?: true
    location?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
  }

  export type PlaceCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    tenantId?: true
    subnetId?: true
    location?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    _all?: true
  }

  export type PlaceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Place to aggregate.
     */
    where?: PlaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Places to fetch.
     */
    orderBy?: PlaceOrderByWithRelationInput | PlaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Places from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Places.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Places
    **/
    _count?: true | PlaceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlaceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlaceMaxAggregateInputType
  }

  export type GetPlaceAggregateType<T extends PlaceAggregateArgs> = {
        [P in keyof T & keyof AggregatePlace]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlace[P]>
      : GetScalarType<T[P], AggregatePlace[P]>
  }




  export type PlaceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlaceWhereInput
    orderBy?: PlaceOrderByWithAggregationInput | PlaceOrderByWithAggregationInput[]
    by: PlaceScalarFieldEnum[] | PlaceScalarFieldEnum
    having?: PlaceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlaceCountAggregateInputType | true
    _min?: PlaceMinAggregateInputType
    _max?: PlaceMaxAggregateInputType
  }

  export type PlaceGroupByOutputType = {
    id: string
    name: string
    description: string | null
    tenantId: string
    subnetId: string | null
    location: string | null
    status: $Enums.PlaceStatus
    createdAt: Date
    updatedAt: Date
    createdBy: string | null
    updatedBy: string | null
    _count: PlaceCountAggregateOutputType | null
    _min: PlaceMinAggregateOutputType | null
    _max: PlaceMaxAggregateOutputType | null
  }

  type GetPlaceGroupByPayload<T extends PlaceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlaceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlaceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlaceGroupByOutputType[P]>
            : GetScalarType<T[P], PlaceGroupByOutputType[P]>
        }
      >
    >


  export type PlaceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    tenantId?: boolean
    subnetId?: boolean
    location?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    subnet?: boolean | Place$subnetArgs<ExtArgs>
    creator?: boolean | Place$creatorArgs<ExtArgs>
    updater?: boolean | Place$updaterArgs<ExtArgs>
  }, ExtArgs["result"]["place"]>

  export type PlaceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    tenantId?: boolean
    subnetId?: boolean
    location?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    subnet?: boolean | Place$subnetArgs<ExtArgs>
    creator?: boolean | Place$creatorArgs<ExtArgs>
    updater?: boolean | Place$updaterArgs<ExtArgs>
  }, ExtArgs["result"]["place"]>

  export type PlaceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    tenantId?: boolean
    subnetId?: boolean
    location?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    subnet?: boolean | Place$subnetArgs<ExtArgs>
    creator?: boolean | Place$creatorArgs<ExtArgs>
    updater?: boolean | Place$updaterArgs<ExtArgs>
  }, ExtArgs["result"]["place"]>

  export type PlaceSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    tenantId?: boolean
    subnetId?: boolean
    location?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
  }

  export type PlaceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "tenantId" | "subnetId" | "location" | "status" | "createdAt" | "updatedAt" | "createdBy" | "updatedBy", ExtArgs["result"]["place"]>
  export type PlaceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    subnet?: boolean | Place$subnetArgs<ExtArgs>
    creator?: boolean | Place$creatorArgs<ExtArgs>
    updater?: boolean | Place$updaterArgs<ExtArgs>
  }
  export type PlaceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    subnet?: boolean | Place$subnetArgs<ExtArgs>
    creator?: boolean | Place$creatorArgs<ExtArgs>
    updater?: boolean | Place$updaterArgs<ExtArgs>
  }
  export type PlaceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    subnet?: boolean | Place$subnetArgs<ExtArgs>
    creator?: boolean | Place$creatorArgs<ExtArgs>
    updater?: boolean | Place$updaterArgs<ExtArgs>
  }

  export type $PlacePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Place"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      subnet: Prisma.$SubnetPayload<ExtArgs> | null
      creator: Prisma.$UserPayload<ExtArgs> | null
      updater: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      tenantId: string
      subnetId: string | null
      location: string | null
      status: $Enums.PlaceStatus
      createdAt: Date
      updatedAt: Date
      createdBy: string | null
      updatedBy: string | null
    }, ExtArgs["result"]["place"]>
    composites: {}
  }

  type PlaceGetPayload<S extends boolean | null | undefined | PlaceDefaultArgs> = $Result.GetResult<Prisma.$PlacePayload, S>

  type PlaceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlaceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlaceCountAggregateInputType | true
    }

  export interface PlaceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Place'], meta: { name: 'Place' } }
    /**
     * Find zero or one Place that matches the filter.
     * @param {PlaceFindUniqueArgs} args - Arguments to find a Place
     * @example
     * // Get one Place
     * const place = await prisma.place.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlaceFindUniqueArgs>(args: SelectSubset<T, PlaceFindUniqueArgs<ExtArgs>>): Prisma__PlaceClient<$Result.GetResult<Prisma.$PlacePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Place that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlaceFindUniqueOrThrowArgs} args - Arguments to find a Place
     * @example
     * // Get one Place
     * const place = await prisma.place.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlaceFindUniqueOrThrowArgs>(args: SelectSubset<T, PlaceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlaceClient<$Result.GetResult<Prisma.$PlacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Place that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceFindFirstArgs} args - Arguments to find a Place
     * @example
     * // Get one Place
     * const place = await prisma.place.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlaceFindFirstArgs>(args?: SelectSubset<T, PlaceFindFirstArgs<ExtArgs>>): Prisma__PlaceClient<$Result.GetResult<Prisma.$PlacePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Place that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceFindFirstOrThrowArgs} args - Arguments to find a Place
     * @example
     * // Get one Place
     * const place = await prisma.place.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlaceFindFirstOrThrowArgs>(args?: SelectSubset<T, PlaceFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlaceClient<$Result.GetResult<Prisma.$PlacePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Places that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Places
     * const places = await prisma.place.findMany()
     * 
     * // Get first 10 Places
     * const places = await prisma.place.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const placeWithIdOnly = await prisma.place.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlaceFindManyArgs>(args?: SelectSubset<T, PlaceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlacePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Place.
     * @param {PlaceCreateArgs} args - Arguments to create a Place.
     * @example
     * // Create one Place
     * const Place = await prisma.place.create({
     *   data: {
     *     // ... data to create a Place
     *   }
     * })
     * 
     */
    create<T extends PlaceCreateArgs>(args: SelectSubset<T, PlaceCreateArgs<ExtArgs>>): Prisma__PlaceClient<$Result.GetResult<Prisma.$PlacePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Places.
     * @param {PlaceCreateManyArgs} args - Arguments to create many Places.
     * @example
     * // Create many Places
     * const place = await prisma.place.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlaceCreateManyArgs>(args?: SelectSubset<T, PlaceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Places and returns the data saved in the database.
     * @param {PlaceCreateManyAndReturnArgs} args - Arguments to create many Places.
     * @example
     * // Create many Places
     * const place = await prisma.place.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Places and only return the `id`
     * const placeWithIdOnly = await prisma.place.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlaceCreateManyAndReturnArgs>(args?: SelectSubset<T, PlaceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlacePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Place.
     * @param {PlaceDeleteArgs} args - Arguments to delete one Place.
     * @example
     * // Delete one Place
     * const Place = await prisma.place.delete({
     *   where: {
     *     // ... filter to delete one Place
     *   }
     * })
     * 
     */
    delete<T extends PlaceDeleteArgs>(args: SelectSubset<T, PlaceDeleteArgs<ExtArgs>>): Prisma__PlaceClient<$Result.GetResult<Prisma.$PlacePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Place.
     * @param {PlaceUpdateArgs} args - Arguments to update one Place.
     * @example
     * // Update one Place
     * const place = await prisma.place.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlaceUpdateArgs>(args: SelectSubset<T, PlaceUpdateArgs<ExtArgs>>): Prisma__PlaceClient<$Result.GetResult<Prisma.$PlacePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Places.
     * @param {PlaceDeleteManyArgs} args - Arguments to filter Places to delete.
     * @example
     * // Delete a few Places
     * const { count } = await prisma.place.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlaceDeleteManyArgs>(args?: SelectSubset<T, PlaceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Places.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Places
     * const place = await prisma.place.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlaceUpdateManyArgs>(args: SelectSubset<T, PlaceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Places and returns the data updated in the database.
     * @param {PlaceUpdateManyAndReturnArgs} args - Arguments to update many Places.
     * @example
     * // Update many Places
     * const place = await prisma.place.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Places and only return the `id`
     * const placeWithIdOnly = await prisma.place.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlaceUpdateManyAndReturnArgs>(args: SelectSubset<T, PlaceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlacePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Place.
     * @param {PlaceUpsertArgs} args - Arguments to update or create a Place.
     * @example
     * // Update or create a Place
     * const place = await prisma.place.upsert({
     *   create: {
     *     // ... data to create a Place
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Place we want to update
     *   }
     * })
     */
    upsert<T extends PlaceUpsertArgs>(args: SelectSubset<T, PlaceUpsertArgs<ExtArgs>>): Prisma__PlaceClient<$Result.GetResult<Prisma.$PlacePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Places.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceCountArgs} args - Arguments to filter Places to count.
     * @example
     * // Count the number of Places
     * const count = await prisma.place.count({
     *   where: {
     *     // ... the filter for the Places we want to count
     *   }
     * })
    **/
    count<T extends PlaceCountArgs>(
      args?: Subset<T, PlaceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlaceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Place.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlaceAggregateArgs>(args: Subset<T, PlaceAggregateArgs>): Prisma.PrismaPromise<GetPlaceAggregateType<T>>

    /**
     * Group by Place.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlaceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlaceGroupByArgs['orderBy'] }
        : { orderBy?: PlaceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlaceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlaceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Place model
   */
  readonly fields: PlaceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Place.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlaceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    subnet<T extends Place$subnetArgs<ExtArgs> = {}>(args?: Subset<T, Place$subnetArgs<ExtArgs>>): Prisma__SubnetClient<$Result.GetResult<Prisma.$SubnetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    creator<T extends Place$creatorArgs<ExtArgs> = {}>(args?: Subset<T, Place$creatorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    updater<T extends Place$updaterArgs<ExtArgs> = {}>(args?: Subset<T, Place$updaterArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Place model
   */
  interface PlaceFieldRefs {
    readonly id: FieldRef<"Place", 'String'>
    readonly name: FieldRef<"Place", 'String'>
    readonly description: FieldRef<"Place", 'String'>
    readonly tenantId: FieldRef<"Place", 'String'>
    readonly subnetId: FieldRef<"Place", 'String'>
    readonly location: FieldRef<"Place", 'String'>
    readonly status: FieldRef<"Place", 'PlaceStatus'>
    readonly createdAt: FieldRef<"Place", 'DateTime'>
    readonly updatedAt: FieldRef<"Place", 'DateTime'>
    readonly createdBy: FieldRef<"Place", 'String'>
    readonly updatedBy: FieldRef<"Place", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Place findUnique
   */
  export type PlaceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Place
     */
    select?: PlaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Place
     */
    omit?: PlaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceInclude<ExtArgs> | null
    /**
     * Filter, which Place to fetch.
     */
    where: PlaceWhereUniqueInput
  }

  /**
   * Place findUniqueOrThrow
   */
  export type PlaceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Place
     */
    select?: PlaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Place
     */
    omit?: PlaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceInclude<ExtArgs> | null
    /**
     * Filter, which Place to fetch.
     */
    where: PlaceWhereUniqueInput
  }

  /**
   * Place findFirst
   */
  export type PlaceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Place
     */
    select?: PlaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Place
     */
    omit?: PlaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceInclude<ExtArgs> | null
    /**
     * Filter, which Place to fetch.
     */
    where?: PlaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Places to fetch.
     */
    orderBy?: PlaceOrderByWithRelationInput | PlaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Places.
     */
    cursor?: PlaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Places from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Places.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Places.
     */
    distinct?: PlaceScalarFieldEnum | PlaceScalarFieldEnum[]
  }

  /**
   * Place findFirstOrThrow
   */
  export type PlaceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Place
     */
    select?: PlaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Place
     */
    omit?: PlaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceInclude<ExtArgs> | null
    /**
     * Filter, which Place to fetch.
     */
    where?: PlaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Places to fetch.
     */
    orderBy?: PlaceOrderByWithRelationInput | PlaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Places.
     */
    cursor?: PlaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Places from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Places.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Places.
     */
    distinct?: PlaceScalarFieldEnum | PlaceScalarFieldEnum[]
  }

  /**
   * Place findMany
   */
  export type PlaceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Place
     */
    select?: PlaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Place
     */
    omit?: PlaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceInclude<ExtArgs> | null
    /**
     * Filter, which Places to fetch.
     */
    where?: PlaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Places to fetch.
     */
    orderBy?: PlaceOrderByWithRelationInput | PlaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Places.
     */
    cursor?: PlaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Places from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Places.
     */
    skip?: number
    distinct?: PlaceScalarFieldEnum | PlaceScalarFieldEnum[]
  }

  /**
   * Place create
   */
  export type PlaceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Place
     */
    select?: PlaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Place
     */
    omit?: PlaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceInclude<ExtArgs> | null
    /**
     * The data needed to create a Place.
     */
    data: XOR<PlaceCreateInput, PlaceUncheckedCreateInput>
  }

  /**
   * Place createMany
   */
  export type PlaceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Places.
     */
    data: PlaceCreateManyInput | PlaceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Place createManyAndReturn
   */
  export type PlaceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Place
     */
    select?: PlaceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Place
     */
    omit?: PlaceOmit<ExtArgs> | null
    /**
     * The data used to create many Places.
     */
    data: PlaceCreateManyInput | PlaceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Place update
   */
  export type PlaceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Place
     */
    select?: PlaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Place
     */
    omit?: PlaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceInclude<ExtArgs> | null
    /**
     * The data needed to update a Place.
     */
    data: XOR<PlaceUpdateInput, PlaceUncheckedUpdateInput>
    /**
     * Choose, which Place to update.
     */
    where: PlaceWhereUniqueInput
  }

  /**
   * Place updateMany
   */
  export type PlaceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Places.
     */
    data: XOR<PlaceUpdateManyMutationInput, PlaceUncheckedUpdateManyInput>
    /**
     * Filter which Places to update
     */
    where?: PlaceWhereInput
    /**
     * Limit how many Places to update.
     */
    limit?: number
  }

  /**
   * Place updateManyAndReturn
   */
  export type PlaceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Place
     */
    select?: PlaceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Place
     */
    omit?: PlaceOmit<ExtArgs> | null
    /**
     * The data used to update Places.
     */
    data: XOR<PlaceUpdateManyMutationInput, PlaceUncheckedUpdateManyInput>
    /**
     * Filter which Places to update
     */
    where?: PlaceWhereInput
    /**
     * Limit how many Places to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Place upsert
   */
  export type PlaceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Place
     */
    select?: PlaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Place
     */
    omit?: PlaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceInclude<ExtArgs> | null
    /**
     * The filter to search for the Place to update in case it exists.
     */
    where: PlaceWhereUniqueInput
    /**
     * In case the Place found by the `where` argument doesn't exist, create a new Place with this data.
     */
    create: XOR<PlaceCreateInput, PlaceUncheckedCreateInput>
    /**
     * In case the Place was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlaceUpdateInput, PlaceUncheckedUpdateInput>
  }

  /**
   * Place delete
   */
  export type PlaceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Place
     */
    select?: PlaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Place
     */
    omit?: PlaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceInclude<ExtArgs> | null
    /**
     * Filter which Place to delete.
     */
    where: PlaceWhereUniqueInput
  }

  /**
   * Place deleteMany
   */
  export type PlaceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Places to delete
     */
    where?: PlaceWhereInput
    /**
     * Limit how many Places to delete.
     */
    limit?: number
  }

  /**
   * Place.subnet
   */
  export type Place$subnetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subnet
     */
    select?: SubnetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subnet
     */
    omit?: SubnetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubnetInclude<ExtArgs> | null
    where?: SubnetWhereInput
  }

  /**
   * Place.creator
   */
  export type Place$creatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Place.updater
   */
  export type Place$updaterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Place without action
   */
  export type PlaceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Place
     */
    select?: PlaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Place
     */
    omit?: PlaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceInclude<ExtArgs> | null
  }


  /**
   * Model Subnet
   */

  export type AggregateSubnet = {
    _count: SubnetCountAggregateOutputType | null
    _avg: SubnetAvgAggregateOutputType | null
    _sum: SubnetSumAggregateOutputType | null
    _min: SubnetMinAggregateOutputType | null
    _max: SubnetMaxAggregateOutputType | null
  }

  export type SubnetAvgAggregateOutputType = {
    vlanId: number | null
  }

  export type SubnetSumAggregateOutputType = {
    vlanId: number | null
  }

  export type SubnetMinAggregateOutputType = {
    id: string | null
    name: string | null
    vpcId: string | null
    cidrBlock: string | null
    availabilityZone: string | null
    gateway: string | null
    vlanId: number | null
    isPublic: boolean | null
    autoAssignIp: boolean | null
    status: $Enums.SubnetStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
  }

  export type SubnetMaxAggregateOutputType = {
    id: string | null
    name: string | null
    vpcId: string | null
    cidrBlock: string | null
    availabilityZone: string | null
    gateway: string | null
    vlanId: number | null
    isPublic: boolean | null
    autoAssignIp: boolean | null
    status: $Enums.SubnetStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
  }

  export type SubnetCountAggregateOutputType = {
    id: number
    name: number
    vpcId: number
    cidrBlock: number
    availabilityZone: number
    gateway: number
    vlanId: number
    isPublic: number
    autoAssignIp: number
    status: number
    createdAt: number
    updatedAt: number
    createdBy: number
    updatedBy: number
    _all: number
  }


  export type SubnetAvgAggregateInputType = {
    vlanId?: true
  }

  export type SubnetSumAggregateInputType = {
    vlanId?: true
  }

  export type SubnetMinAggregateInputType = {
    id?: true
    name?: true
    vpcId?: true
    cidrBlock?: true
    availabilityZone?: true
    gateway?: true
    vlanId?: true
    isPublic?: true
    autoAssignIp?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
  }

  export type SubnetMaxAggregateInputType = {
    id?: true
    name?: true
    vpcId?: true
    cidrBlock?: true
    availabilityZone?: true
    gateway?: true
    vlanId?: true
    isPublic?: true
    autoAssignIp?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
  }

  export type SubnetCountAggregateInputType = {
    id?: true
    name?: true
    vpcId?: true
    cidrBlock?: true
    availabilityZone?: true
    gateway?: true
    vlanId?: true
    isPublic?: true
    autoAssignIp?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    _all?: true
  }

  export type SubnetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subnet to aggregate.
     */
    where?: SubnetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subnets to fetch.
     */
    orderBy?: SubnetOrderByWithRelationInput | SubnetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubnetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subnets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subnets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subnets
    **/
    _count?: true | SubnetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubnetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubnetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubnetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubnetMaxAggregateInputType
  }

  export type GetSubnetAggregateType<T extends SubnetAggregateArgs> = {
        [P in keyof T & keyof AggregateSubnet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubnet[P]>
      : GetScalarType<T[P], AggregateSubnet[P]>
  }




  export type SubnetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubnetWhereInput
    orderBy?: SubnetOrderByWithAggregationInput | SubnetOrderByWithAggregationInput[]
    by: SubnetScalarFieldEnum[] | SubnetScalarFieldEnum
    having?: SubnetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubnetCountAggregateInputType | true
    _avg?: SubnetAvgAggregateInputType
    _sum?: SubnetSumAggregateInputType
    _min?: SubnetMinAggregateInputType
    _max?: SubnetMaxAggregateInputType
  }

  export type SubnetGroupByOutputType = {
    id: string
    name: string
    vpcId: string
    cidrBlock: string
    availabilityZone: string | null
    gateway: string | null
    vlanId: number | null
    isPublic: boolean
    autoAssignIp: boolean
    status: $Enums.SubnetStatus
    createdAt: Date
    updatedAt: Date
    createdBy: string | null
    updatedBy: string | null
    _count: SubnetCountAggregateOutputType | null
    _avg: SubnetAvgAggregateOutputType | null
    _sum: SubnetSumAggregateOutputType | null
    _min: SubnetMinAggregateOutputType | null
    _max: SubnetMaxAggregateOutputType | null
  }

  type GetSubnetGroupByPayload<T extends SubnetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubnetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubnetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubnetGroupByOutputType[P]>
            : GetScalarType<T[P], SubnetGroupByOutputType[P]>
        }
      >
    >


  export type SubnetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    vpcId?: boolean
    cidrBlock?: boolean
    availabilityZone?: boolean
    gateway?: boolean
    vlanId?: boolean
    isPublic?: boolean
    autoAssignIp?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    vpc?: boolean | VpcDefaultArgs<ExtArgs>
    place?: boolean | Subnet$placeArgs<ExtArgs>
    creator?: boolean | Subnet$creatorArgs<ExtArgs>
    updater?: boolean | Subnet$updaterArgs<ExtArgs>
  }, ExtArgs["result"]["subnet"]>

  export type SubnetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    vpcId?: boolean
    cidrBlock?: boolean
    availabilityZone?: boolean
    gateway?: boolean
    vlanId?: boolean
    isPublic?: boolean
    autoAssignIp?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    vpc?: boolean | VpcDefaultArgs<ExtArgs>
    creator?: boolean | Subnet$creatorArgs<ExtArgs>
    updater?: boolean | Subnet$updaterArgs<ExtArgs>
  }, ExtArgs["result"]["subnet"]>

  export type SubnetSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    vpcId?: boolean
    cidrBlock?: boolean
    availabilityZone?: boolean
    gateway?: boolean
    vlanId?: boolean
    isPublic?: boolean
    autoAssignIp?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    vpc?: boolean | VpcDefaultArgs<ExtArgs>
    creator?: boolean | Subnet$creatorArgs<ExtArgs>
    updater?: boolean | Subnet$updaterArgs<ExtArgs>
  }, ExtArgs["result"]["subnet"]>

  export type SubnetSelectScalar = {
    id?: boolean
    name?: boolean
    vpcId?: boolean
    cidrBlock?: boolean
    availabilityZone?: boolean
    gateway?: boolean
    vlanId?: boolean
    isPublic?: boolean
    autoAssignIp?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
  }

  export type SubnetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "vpcId" | "cidrBlock" | "availabilityZone" | "gateway" | "vlanId" | "isPublic" | "autoAssignIp" | "status" | "createdAt" | "updatedAt" | "createdBy" | "updatedBy", ExtArgs["result"]["subnet"]>
  export type SubnetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vpc?: boolean | VpcDefaultArgs<ExtArgs>
    place?: boolean | Subnet$placeArgs<ExtArgs>
    creator?: boolean | Subnet$creatorArgs<ExtArgs>
    updater?: boolean | Subnet$updaterArgs<ExtArgs>
  }
  export type SubnetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vpc?: boolean | VpcDefaultArgs<ExtArgs>
    creator?: boolean | Subnet$creatorArgs<ExtArgs>
    updater?: boolean | Subnet$updaterArgs<ExtArgs>
  }
  export type SubnetIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vpc?: boolean | VpcDefaultArgs<ExtArgs>
    creator?: boolean | Subnet$creatorArgs<ExtArgs>
    updater?: boolean | Subnet$updaterArgs<ExtArgs>
  }

  export type $SubnetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subnet"
    objects: {
      vpc: Prisma.$VpcPayload<ExtArgs>
      place: Prisma.$PlacePayload<ExtArgs> | null
      creator: Prisma.$UserPayload<ExtArgs> | null
      updater: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      vpcId: string
      cidrBlock: string
      availabilityZone: string | null
      gateway: string | null
      vlanId: number | null
      isPublic: boolean
      autoAssignIp: boolean
      status: $Enums.SubnetStatus
      createdAt: Date
      updatedAt: Date
      createdBy: string | null
      updatedBy: string | null
    }, ExtArgs["result"]["subnet"]>
    composites: {}
  }

  type SubnetGetPayload<S extends boolean | null | undefined | SubnetDefaultArgs> = $Result.GetResult<Prisma.$SubnetPayload, S>

  type SubnetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubnetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubnetCountAggregateInputType | true
    }

  export interface SubnetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subnet'], meta: { name: 'Subnet' } }
    /**
     * Find zero or one Subnet that matches the filter.
     * @param {SubnetFindUniqueArgs} args - Arguments to find a Subnet
     * @example
     * // Get one Subnet
     * const subnet = await prisma.subnet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubnetFindUniqueArgs>(args: SelectSubset<T, SubnetFindUniqueArgs<ExtArgs>>): Prisma__SubnetClient<$Result.GetResult<Prisma.$SubnetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Subnet that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubnetFindUniqueOrThrowArgs} args - Arguments to find a Subnet
     * @example
     * // Get one Subnet
     * const subnet = await prisma.subnet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubnetFindUniqueOrThrowArgs>(args: SelectSubset<T, SubnetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubnetClient<$Result.GetResult<Prisma.$SubnetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subnet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubnetFindFirstArgs} args - Arguments to find a Subnet
     * @example
     * // Get one Subnet
     * const subnet = await prisma.subnet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubnetFindFirstArgs>(args?: SelectSubset<T, SubnetFindFirstArgs<ExtArgs>>): Prisma__SubnetClient<$Result.GetResult<Prisma.$SubnetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subnet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubnetFindFirstOrThrowArgs} args - Arguments to find a Subnet
     * @example
     * // Get one Subnet
     * const subnet = await prisma.subnet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubnetFindFirstOrThrowArgs>(args?: SelectSubset<T, SubnetFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubnetClient<$Result.GetResult<Prisma.$SubnetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subnets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubnetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subnets
     * const subnets = await prisma.subnet.findMany()
     * 
     * // Get first 10 Subnets
     * const subnets = await prisma.subnet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subnetWithIdOnly = await prisma.subnet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubnetFindManyArgs>(args?: SelectSubset<T, SubnetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubnetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Subnet.
     * @param {SubnetCreateArgs} args - Arguments to create a Subnet.
     * @example
     * // Create one Subnet
     * const Subnet = await prisma.subnet.create({
     *   data: {
     *     // ... data to create a Subnet
     *   }
     * })
     * 
     */
    create<T extends SubnetCreateArgs>(args: SelectSubset<T, SubnetCreateArgs<ExtArgs>>): Prisma__SubnetClient<$Result.GetResult<Prisma.$SubnetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Subnets.
     * @param {SubnetCreateManyArgs} args - Arguments to create many Subnets.
     * @example
     * // Create many Subnets
     * const subnet = await prisma.subnet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubnetCreateManyArgs>(args?: SelectSubset<T, SubnetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subnets and returns the data saved in the database.
     * @param {SubnetCreateManyAndReturnArgs} args - Arguments to create many Subnets.
     * @example
     * // Create many Subnets
     * const subnet = await prisma.subnet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subnets and only return the `id`
     * const subnetWithIdOnly = await prisma.subnet.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubnetCreateManyAndReturnArgs>(args?: SelectSubset<T, SubnetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubnetPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Subnet.
     * @param {SubnetDeleteArgs} args - Arguments to delete one Subnet.
     * @example
     * // Delete one Subnet
     * const Subnet = await prisma.subnet.delete({
     *   where: {
     *     // ... filter to delete one Subnet
     *   }
     * })
     * 
     */
    delete<T extends SubnetDeleteArgs>(args: SelectSubset<T, SubnetDeleteArgs<ExtArgs>>): Prisma__SubnetClient<$Result.GetResult<Prisma.$SubnetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Subnet.
     * @param {SubnetUpdateArgs} args - Arguments to update one Subnet.
     * @example
     * // Update one Subnet
     * const subnet = await prisma.subnet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubnetUpdateArgs>(args: SelectSubset<T, SubnetUpdateArgs<ExtArgs>>): Prisma__SubnetClient<$Result.GetResult<Prisma.$SubnetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Subnets.
     * @param {SubnetDeleteManyArgs} args - Arguments to filter Subnets to delete.
     * @example
     * // Delete a few Subnets
     * const { count } = await prisma.subnet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubnetDeleteManyArgs>(args?: SelectSubset<T, SubnetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subnets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubnetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subnets
     * const subnet = await prisma.subnet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubnetUpdateManyArgs>(args: SelectSubset<T, SubnetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subnets and returns the data updated in the database.
     * @param {SubnetUpdateManyAndReturnArgs} args - Arguments to update many Subnets.
     * @example
     * // Update many Subnets
     * const subnet = await prisma.subnet.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Subnets and only return the `id`
     * const subnetWithIdOnly = await prisma.subnet.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubnetUpdateManyAndReturnArgs>(args: SelectSubset<T, SubnetUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubnetPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Subnet.
     * @param {SubnetUpsertArgs} args - Arguments to update or create a Subnet.
     * @example
     * // Update or create a Subnet
     * const subnet = await prisma.subnet.upsert({
     *   create: {
     *     // ... data to create a Subnet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subnet we want to update
     *   }
     * })
     */
    upsert<T extends SubnetUpsertArgs>(args: SelectSubset<T, SubnetUpsertArgs<ExtArgs>>): Prisma__SubnetClient<$Result.GetResult<Prisma.$SubnetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Subnets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubnetCountArgs} args - Arguments to filter Subnets to count.
     * @example
     * // Count the number of Subnets
     * const count = await prisma.subnet.count({
     *   where: {
     *     // ... the filter for the Subnets we want to count
     *   }
     * })
    **/
    count<T extends SubnetCountArgs>(
      args?: Subset<T, SubnetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubnetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subnet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubnetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubnetAggregateArgs>(args: Subset<T, SubnetAggregateArgs>): Prisma.PrismaPromise<GetSubnetAggregateType<T>>

    /**
     * Group by Subnet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubnetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubnetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubnetGroupByArgs['orderBy'] }
        : { orderBy?: SubnetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubnetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubnetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subnet model
   */
  readonly fields: SubnetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subnet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubnetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vpc<T extends VpcDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VpcDefaultArgs<ExtArgs>>): Prisma__VpcClient<$Result.GetResult<Prisma.$VpcPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    place<T extends Subnet$placeArgs<ExtArgs> = {}>(args?: Subset<T, Subnet$placeArgs<ExtArgs>>): Prisma__PlaceClient<$Result.GetResult<Prisma.$PlacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    creator<T extends Subnet$creatorArgs<ExtArgs> = {}>(args?: Subset<T, Subnet$creatorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    updater<T extends Subnet$updaterArgs<ExtArgs> = {}>(args?: Subset<T, Subnet$updaterArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subnet model
   */
  interface SubnetFieldRefs {
    readonly id: FieldRef<"Subnet", 'String'>
    readonly name: FieldRef<"Subnet", 'String'>
    readonly vpcId: FieldRef<"Subnet", 'String'>
    readonly cidrBlock: FieldRef<"Subnet", 'String'>
    readonly availabilityZone: FieldRef<"Subnet", 'String'>
    readonly gateway: FieldRef<"Subnet", 'String'>
    readonly vlanId: FieldRef<"Subnet", 'Int'>
    readonly isPublic: FieldRef<"Subnet", 'Boolean'>
    readonly autoAssignIp: FieldRef<"Subnet", 'Boolean'>
    readonly status: FieldRef<"Subnet", 'SubnetStatus'>
    readonly createdAt: FieldRef<"Subnet", 'DateTime'>
    readonly updatedAt: FieldRef<"Subnet", 'DateTime'>
    readonly createdBy: FieldRef<"Subnet", 'String'>
    readonly updatedBy: FieldRef<"Subnet", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Subnet findUnique
   */
  export type SubnetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subnet
     */
    select?: SubnetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subnet
     */
    omit?: SubnetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubnetInclude<ExtArgs> | null
    /**
     * Filter, which Subnet to fetch.
     */
    where: SubnetWhereUniqueInput
  }

  /**
   * Subnet findUniqueOrThrow
   */
  export type SubnetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subnet
     */
    select?: SubnetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subnet
     */
    omit?: SubnetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubnetInclude<ExtArgs> | null
    /**
     * Filter, which Subnet to fetch.
     */
    where: SubnetWhereUniqueInput
  }

  /**
   * Subnet findFirst
   */
  export type SubnetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subnet
     */
    select?: SubnetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subnet
     */
    omit?: SubnetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubnetInclude<ExtArgs> | null
    /**
     * Filter, which Subnet to fetch.
     */
    where?: SubnetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subnets to fetch.
     */
    orderBy?: SubnetOrderByWithRelationInput | SubnetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subnets.
     */
    cursor?: SubnetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subnets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subnets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subnets.
     */
    distinct?: SubnetScalarFieldEnum | SubnetScalarFieldEnum[]
  }

  /**
   * Subnet findFirstOrThrow
   */
  export type SubnetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subnet
     */
    select?: SubnetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subnet
     */
    omit?: SubnetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubnetInclude<ExtArgs> | null
    /**
     * Filter, which Subnet to fetch.
     */
    where?: SubnetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subnets to fetch.
     */
    orderBy?: SubnetOrderByWithRelationInput | SubnetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subnets.
     */
    cursor?: SubnetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subnets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subnets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subnets.
     */
    distinct?: SubnetScalarFieldEnum | SubnetScalarFieldEnum[]
  }

  /**
   * Subnet findMany
   */
  export type SubnetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subnet
     */
    select?: SubnetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subnet
     */
    omit?: SubnetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubnetInclude<ExtArgs> | null
    /**
     * Filter, which Subnets to fetch.
     */
    where?: SubnetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subnets to fetch.
     */
    orderBy?: SubnetOrderByWithRelationInput | SubnetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subnets.
     */
    cursor?: SubnetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subnets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subnets.
     */
    skip?: number
    distinct?: SubnetScalarFieldEnum | SubnetScalarFieldEnum[]
  }

  /**
   * Subnet create
   */
  export type SubnetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subnet
     */
    select?: SubnetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subnet
     */
    omit?: SubnetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubnetInclude<ExtArgs> | null
    /**
     * The data needed to create a Subnet.
     */
    data: XOR<SubnetCreateInput, SubnetUncheckedCreateInput>
  }

  /**
   * Subnet createMany
   */
  export type SubnetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subnets.
     */
    data: SubnetCreateManyInput | SubnetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subnet createManyAndReturn
   */
  export type SubnetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subnet
     */
    select?: SubnetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subnet
     */
    omit?: SubnetOmit<ExtArgs> | null
    /**
     * The data used to create many Subnets.
     */
    data: SubnetCreateManyInput | SubnetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubnetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subnet update
   */
  export type SubnetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subnet
     */
    select?: SubnetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subnet
     */
    omit?: SubnetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubnetInclude<ExtArgs> | null
    /**
     * The data needed to update a Subnet.
     */
    data: XOR<SubnetUpdateInput, SubnetUncheckedUpdateInput>
    /**
     * Choose, which Subnet to update.
     */
    where: SubnetWhereUniqueInput
  }

  /**
   * Subnet updateMany
   */
  export type SubnetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subnets.
     */
    data: XOR<SubnetUpdateManyMutationInput, SubnetUncheckedUpdateManyInput>
    /**
     * Filter which Subnets to update
     */
    where?: SubnetWhereInput
    /**
     * Limit how many Subnets to update.
     */
    limit?: number
  }

  /**
   * Subnet updateManyAndReturn
   */
  export type SubnetUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subnet
     */
    select?: SubnetSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subnet
     */
    omit?: SubnetOmit<ExtArgs> | null
    /**
     * The data used to update Subnets.
     */
    data: XOR<SubnetUpdateManyMutationInput, SubnetUncheckedUpdateManyInput>
    /**
     * Filter which Subnets to update
     */
    where?: SubnetWhereInput
    /**
     * Limit how many Subnets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubnetIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subnet upsert
   */
  export type SubnetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subnet
     */
    select?: SubnetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subnet
     */
    omit?: SubnetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubnetInclude<ExtArgs> | null
    /**
     * The filter to search for the Subnet to update in case it exists.
     */
    where: SubnetWhereUniqueInput
    /**
     * In case the Subnet found by the `where` argument doesn't exist, create a new Subnet with this data.
     */
    create: XOR<SubnetCreateInput, SubnetUncheckedCreateInput>
    /**
     * In case the Subnet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubnetUpdateInput, SubnetUncheckedUpdateInput>
  }

  /**
   * Subnet delete
   */
  export type SubnetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subnet
     */
    select?: SubnetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subnet
     */
    omit?: SubnetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubnetInclude<ExtArgs> | null
    /**
     * Filter which Subnet to delete.
     */
    where: SubnetWhereUniqueInput
  }

  /**
   * Subnet deleteMany
   */
  export type SubnetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subnets to delete
     */
    where?: SubnetWhereInput
    /**
     * Limit how many Subnets to delete.
     */
    limit?: number
  }

  /**
   * Subnet.place
   */
  export type Subnet$placeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Place
     */
    select?: PlaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Place
     */
    omit?: PlaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceInclude<ExtArgs> | null
    where?: PlaceWhereInput
  }

  /**
   * Subnet.creator
   */
  export type Subnet$creatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Subnet.updater
   */
  export type Subnet$updaterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Subnet without action
   */
  export type SubnetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subnet
     */
    select?: SubnetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subnet
     */
    omit?: SubnetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubnetInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    resourceType: string | null
    resourceId: string | null
    ipAddress: string | null
    userAgent: string | null
    status: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    resourceType: string | null
    resourceId: string | null
    ipAddress: string | null
    userAgent: string | null
    status: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    userId: number
    action: number
    resourceType: number
    resourceId: number
    details: number
    ipAddress: number
    userAgent: number
    status: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    resourceType?: true
    resourceId?: true
    ipAddress?: true
    userAgent?: true
    status?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    resourceType?: true
    resourceId?: true
    ipAddress?: true
    userAgent?: true
    status?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    resourceType?: true
    resourceId?: true
    details?: true
    ipAddress?: true
    userAgent?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    userId: string
    action: string
    resourceType: string
    resourceId: string | null
    details: JsonValue | null
    ipAddress: string | null
    userAgent: string | null
    status: string
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    resourceType?: boolean
    resourceId?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    status?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    resourceType?: boolean
    resourceId?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    status?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    resourceType?: boolean
    resourceId?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    status?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    userId?: boolean
    action?: boolean
    resourceType?: boolean
    resourceId?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "action" | "resourceType" | "resourceId" | "details" | "ipAddress" | "userAgent" | "status" | "createdAt", ExtArgs["result"]["auditLog"]>
  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      action: string
      resourceType: string
      resourceId: string | null
      details: Prisma.JsonValue | null
      ipAddress: string | null
      userAgent: string | null
      status: string
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly resourceType: FieldRef<"AuditLog", 'String'>
    readonly resourceId: FieldRef<"AuditLog", 'String'>
    readonly details: FieldRef<"AuditLog", 'Json'>
    readonly ipAddress: FieldRef<"AuditLog", 'String'>
    readonly userAgent: FieldRef<"AuditLog", 'String'>
    readonly status: FieldRef<"AuditLog", 'String'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const TenantScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    status: 'status',
    adminUserId: 'adminUserId',
    vlanId: 'vlanId',
    quotaConfig: 'quotaConfig',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy'
  };

  export type TenantScalarFieldEnum = (typeof TenantScalarFieldEnum)[keyof typeof TenantScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    email: 'email',
    passwordHash: 'passwordHash',
    role: 'role',
    status: 'status',
    tenantId: 'tenantId',
    quotaConfig: 'quotaConfig',
    lastLoginAt: 'lastLoginAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserGroupScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    tenantId: 'tenantId',
    parentGroupId: 'parentGroupId',
    quotaConfig: 'quotaConfig',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserGroupScalarFieldEnum = (typeof UserGroupScalarFieldEnum)[keyof typeof UserGroupScalarFieldEnum]


  export const UserGroupMemberScalarFieldEnum: {
    id: 'id',
    groupId: 'groupId',
    userId: 'userId',
    joinedAt: 'joinedAt',
    addedBy: 'addedBy'
  };

  export type UserGroupMemberScalarFieldEnum = (typeof UserGroupMemberScalarFieldEnum)[keyof typeof UserGroupMemberScalarFieldEnum]


  export const PermissionScalarFieldEnum: {
    id: 'id',
    resourceType: 'resourceType',
    action: 'action',
    permissionName: 'permissionName',
    description: 'description',
    createdAt: 'createdAt'
  };

  export type PermissionScalarFieldEnum = (typeof PermissionScalarFieldEnum)[keyof typeof PermissionScalarFieldEnum]


  export const RolePermissionScalarFieldEnum: {
    id: 'id',
    role: 'role',
    permissionId: 'permissionId'
  };

  export type RolePermissionScalarFieldEnum = (typeof RolePermissionScalarFieldEnum)[keyof typeof RolePermissionScalarFieldEnum]


  export const InstanceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    tenantId: 'tenantId',
    userId: 'userId',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InstanceScalarFieldEnum = (typeof InstanceScalarFieldEnum)[keyof typeof InstanceScalarFieldEnum]


  export const PrivateDataDiskScalarFieldEnum: {
    id: 'id',
    name: 'name',
    tenantId: 'tenantId',
    userId: 'userId',
    sizeGb: 'sizeGb',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PrivateDataDiskScalarFieldEnum = (typeof PrivateDataDiskScalarFieldEnum)[keyof typeof PrivateDataDiskScalarFieldEnum]


  export const VpcScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    tenantId: 'tenantId',
    userId: 'userId',
    cidrBlock: 'cidrBlock',
    edgeDataCenterId: 'edgeDataCenterId',
    vlanId: 'vlanId',
    enableDns: 'enableDns',
    dnsServers: 'dnsServers',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy'
  };

  export type VpcScalarFieldEnum = (typeof VpcScalarFieldEnum)[keyof typeof VpcScalarFieldEnum]


  export const PlaceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    tenantId: 'tenantId',
    subnetId: 'subnetId',
    location: 'location',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy'
  };

  export type PlaceScalarFieldEnum = (typeof PlaceScalarFieldEnum)[keyof typeof PlaceScalarFieldEnum]


  export const SubnetScalarFieldEnum: {
    id: 'id',
    name: 'name',
    vpcId: 'vpcId',
    cidrBlock: 'cidrBlock',
    availabilityZone: 'availabilityZone',
    gateway: 'gateway',
    vlanId: 'vlanId',
    isPublic: 'isPublic',
    autoAssignIp: 'autoAssignIp',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy'
  };

  export type SubnetScalarFieldEnum = (typeof SubnetScalarFieldEnum)[keyof typeof SubnetScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    action: 'action',
    resourceType: 'resourceType',
    resourceId: 'resourceId',
    details: 'details',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'TenantStatus'
   */
  export type EnumTenantStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TenantStatus'>
    


  /**
   * Reference to a field of type 'TenantStatus[]'
   */
  export type ListEnumTenantStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TenantStatus[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'UserStatus'
   */
  export type EnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus'>
    


  /**
   * Reference to a field of type 'UserStatus[]'
   */
  export type ListEnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus[]'>
    


  /**
   * Reference to a field of type 'ResourceType'
   */
  export type EnumResourceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ResourceType'>
    


  /**
   * Reference to a field of type 'ResourceType[]'
   */
  export type ListEnumResourceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ResourceType[]'>
    


  /**
   * Reference to a field of type 'PermissionAction'
   */
  export type EnumPermissionActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PermissionAction'>
    


  /**
   * Reference to a field of type 'PermissionAction[]'
   */
  export type ListEnumPermissionActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PermissionAction[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'VpcStatus'
   */
  export type EnumVpcStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VpcStatus'>
    


  /**
   * Reference to a field of type 'VpcStatus[]'
   */
  export type ListEnumVpcStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VpcStatus[]'>
    


  /**
   * Reference to a field of type 'PlaceStatus'
   */
  export type EnumPlaceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PlaceStatus'>
    


  /**
   * Reference to a field of type 'PlaceStatus[]'
   */
  export type ListEnumPlaceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PlaceStatus[]'>
    


  /**
   * Reference to a field of type 'SubnetStatus'
   */
  export type EnumSubnetStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubnetStatus'>
    


  /**
   * Reference to a field of type 'SubnetStatus[]'
   */
  export type ListEnumSubnetStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubnetStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type TenantWhereInput = {
    AND?: TenantWhereInput | TenantWhereInput[]
    OR?: TenantWhereInput[]
    NOT?: TenantWhereInput | TenantWhereInput[]
    id?: UuidFilter<"Tenant"> | string
    name?: StringFilter<"Tenant"> | string
    description?: StringNullableFilter<"Tenant"> | string | null
    status?: EnumTenantStatusFilter<"Tenant"> | $Enums.TenantStatus
    adminUserId?: UuidNullableFilter<"Tenant"> | string | null
    vlanId?: IntNullableFilter<"Tenant"> | number | null
    quotaConfig?: JsonNullableFilter<"Tenant">
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeFilter<"Tenant"> | Date | string
    createdBy?: UuidNullableFilter<"Tenant"> | string | null
    users?: UserListRelationFilter
    userGroups?: UserGroupListRelationFilter
    instances?: InstanceListRelationFilter
    privateDataDisks?: PrivateDataDiskListRelationFilter
    vpcs?: VpcListRelationFilter
    places?: PlaceListRelationFilter
    creator?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type TenantOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    adminUserId?: SortOrderInput | SortOrder
    vlanId?: SortOrderInput | SortOrder
    quotaConfig?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    users?: UserOrderByRelationAggregateInput
    userGroups?: UserGroupOrderByRelationAggregateInput
    instances?: InstanceOrderByRelationAggregateInput
    privateDataDisks?: PrivateDataDiskOrderByRelationAggregateInput
    vpcs?: VpcOrderByRelationAggregateInput
    places?: PlaceOrderByRelationAggregateInput
    creator?: UserOrderByWithRelationInput
  }

  export type TenantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    vlanId?: number
    AND?: TenantWhereInput | TenantWhereInput[]
    OR?: TenantWhereInput[]
    NOT?: TenantWhereInput | TenantWhereInput[]
    description?: StringNullableFilter<"Tenant"> | string | null
    status?: EnumTenantStatusFilter<"Tenant"> | $Enums.TenantStatus
    adminUserId?: UuidNullableFilter<"Tenant"> | string | null
    quotaConfig?: JsonNullableFilter<"Tenant">
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeFilter<"Tenant"> | Date | string
    createdBy?: UuidNullableFilter<"Tenant"> | string | null
    users?: UserListRelationFilter
    userGroups?: UserGroupListRelationFilter
    instances?: InstanceListRelationFilter
    privateDataDisks?: PrivateDataDiskListRelationFilter
    vpcs?: VpcListRelationFilter
    places?: PlaceListRelationFilter
    creator?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "name" | "vlanId">

  export type TenantOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    adminUserId?: SortOrderInput | SortOrder
    vlanId?: SortOrderInput | SortOrder
    quotaConfig?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    _count?: TenantCountOrderByAggregateInput
    _avg?: TenantAvgOrderByAggregateInput
    _max?: TenantMaxOrderByAggregateInput
    _min?: TenantMinOrderByAggregateInput
    _sum?: TenantSumOrderByAggregateInput
  }

  export type TenantScalarWhereWithAggregatesInput = {
    AND?: TenantScalarWhereWithAggregatesInput | TenantScalarWhereWithAggregatesInput[]
    OR?: TenantScalarWhereWithAggregatesInput[]
    NOT?: TenantScalarWhereWithAggregatesInput | TenantScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Tenant"> | string
    name?: StringWithAggregatesFilter<"Tenant"> | string
    description?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    status?: EnumTenantStatusWithAggregatesFilter<"Tenant"> | $Enums.TenantStatus
    adminUserId?: UuidNullableWithAggregatesFilter<"Tenant"> | string | null
    vlanId?: IntNullableWithAggregatesFilter<"Tenant"> | number | null
    quotaConfig?: JsonNullableWithAggregatesFilter<"Tenant">
    createdAt?: DateTimeWithAggregatesFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Tenant"> | Date | string
    createdBy?: UuidNullableWithAggregatesFilter<"Tenant"> | string | null
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: UuidFilter<"User"> | string
    username?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    tenantId?: UuidNullableFilter<"User"> | string | null
    quotaConfig?: JsonNullableFilter<"User">
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    tenant?: XOR<TenantNullableScalarRelationFilter, TenantWhereInput> | null
    groupMemberships?: UserGroupMemberListRelationFilter
    instances?: InstanceListRelationFilter
    privateDataDisks?: PrivateDataDiskListRelationFilter
    createdTenants?: TenantListRelationFilter
    vpcs?: VpcListRelationFilter
    createdVpcs?: VpcListRelationFilter
    updatedVpcs?: VpcListRelationFilter
    createdPlaces?: PlaceListRelationFilter
    updatedPlaces?: PlaceListRelationFilter
    createdSubnets?: SubnetListRelationFilter
    updatedSubnets?: SubnetListRelationFilter
    auditLogs?: AuditLogListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    status?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    quotaConfig?: SortOrderInput | SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    groupMemberships?: UserGroupMemberOrderByRelationAggregateInput
    instances?: InstanceOrderByRelationAggregateInput
    privateDataDisks?: PrivateDataDiskOrderByRelationAggregateInput
    createdTenants?: TenantOrderByRelationAggregateInput
    vpcs?: VpcOrderByRelationAggregateInput
    createdVpcs?: VpcOrderByRelationAggregateInput
    updatedVpcs?: VpcOrderByRelationAggregateInput
    createdPlaces?: PlaceOrderByRelationAggregateInput
    updatedPlaces?: PlaceOrderByRelationAggregateInput
    createdSubnets?: SubnetOrderByRelationAggregateInput
    updatedSubnets?: SubnetOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    username?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    passwordHash?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    tenantId?: UuidNullableFilter<"User"> | string | null
    quotaConfig?: JsonNullableFilter<"User">
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    tenant?: XOR<TenantNullableScalarRelationFilter, TenantWhereInput> | null
    groupMemberships?: UserGroupMemberListRelationFilter
    instances?: InstanceListRelationFilter
    privateDataDisks?: PrivateDataDiskListRelationFilter
    createdTenants?: TenantListRelationFilter
    vpcs?: VpcListRelationFilter
    createdVpcs?: VpcListRelationFilter
    updatedVpcs?: VpcListRelationFilter
    createdPlaces?: PlaceListRelationFilter
    updatedPlaces?: PlaceListRelationFilter
    createdSubnets?: SubnetListRelationFilter
    updatedSubnets?: SubnetListRelationFilter
    auditLogs?: AuditLogListRelationFilter
  }, "id" | "username" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    status?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    quotaConfig?: SortOrderInput | SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"User"> | string
    username?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    status?: EnumUserStatusWithAggregatesFilter<"User"> | $Enums.UserStatus
    tenantId?: UuidNullableWithAggregatesFilter<"User"> | string | null
    quotaConfig?: JsonNullableWithAggregatesFilter<"User">
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type UserGroupWhereInput = {
    AND?: UserGroupWhereInput | UserGroupWhereInput[]
    OR?: UserGroupWhereInput[]
    NOT?: UserGroupWhereInput | UserGroupWhereInput[]
    id?: UuidFilter<"UserGroup"> | string
    name?: StringFilter<"UserGroup"> | string
    description?: StringNullableFilter<"UserGroup"> | string | null
    tenantId?: UuidFilter<"UserGroup"> | string
    parentGroupId?: UuidNullableFilter<"UserGroup"> | string | null
    quotaConfig?: JsonNullableFilter<"UserGroup">
    createdAt?: DateTimeFilter<"UserGroup"> | Date | string
    updatedAt?: DateTimeFilter<"UserGroup"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    parentGroup?: XOR<UserGroupNullableScalarRelationFilter, UserGroupWhereInput> | null
    childGroups?: UserGroupListRelationFilter
    members?: UserGroupMemberListRelationFilter
  }

  export type UserGroupOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    tenantId?: SortOrder
    parentGroupId?: SortOrderInput | SortOrder
    quotaConfig?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    parentGroup?: UserGroupOrderByWithRelationInput
    childGroups?: UserGroupOrderByRelationAggregateInput
    members?: UserGroupMemberOrderByRelationAggregateInput
  }

  export type UserGroupWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId_name?: UserGroupTenantIdNameCompoundUniqueInput
    AND?: UserGroupWhereInput | UserGroupWhereInput[]
    OR?: UserGroupWhereInput[]
    NOT?: UserGroupWhereInput | UserGroupWhereInput[]
    name?: StringFilter<"UserGroup"> | string
    description?: StringNullableFilter<"UserGroup"> | string | null
    tenantId?: UuidFilter<"UserGroup"> | string
    parentGroupId?: UuidNullableFilter<"UserGroup"> | string | null
    quotaConfig?: JsonNullableFilter<"UserGroup">
    createdAt?: DateTimeFilter<"UserGroup"> | Date | string
    updatedAt?: DateTimeFilter<"UserGroup"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    parentGroup?: XOR<UserGroupNullableScalarRelationFilter, UserGroupWhereInput> | null
    childGroups?: UserGroupListRelationFilter
    members?: UserGroupMemberListRelationFilter
  }, "id" | "tenantId_name">

  export type UserGroupOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    tenantId?: SortOrder
    parentGroupId?: SortOrderInput | SortOrder
    quotaConfig?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserGroupCountOrderByAggregateInput
    _max?: UserGroupMaxOrderByAggregateInput
    _min?: UserGroupMinOrderByAggregateInput
  }

  export type UserGroupScalarWhereWithAggregatesInput = {
    AND?: UserGroupScalarWhereWithAggregatesInput | UserGroupScalarWhereWithAggregatesInput[]
    OR?: UserGroupScalarWhereWithAggregatesInput[]
    NOT?: UserGroupScalarWhereWithAggregatesInput | UserGroupScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"UserGroup"> | string
    name?: StringWithAggregatesFilter<"UserGroup"> | string
    description?: StringNullableWithAggregatesFilter<"UserGroup"> | string | null
    tenantId?: UuidWithAggregatesFilter<"UserGroup"> | string
    parentGroupId?: UuidNullableWithAggregatesFilter<"UserGroup"> | string | null
    quotaConfig?: JsonNullableWithAggregatesFilter<"UserGroup">
    createdAt?: DateTimeWithAggregatesFilter<"UserGroup"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserGroup"> | Date | string
  }

  export type UserGroupMemberWhereInput = {
    AND?: UserGroupMemberWhereInput | UserGroupMemberWhereInput[]
    OR?: UserGroupMemberWhereInput[]
    NOT?: UserGroupMemberWhereInput | UserGroupMemberWhereInput[]
    id?: UuidFilter<"UserGroupMember"> | string
    groupId?: UuidFilter<"UserGroupMember"> | string
    userId?: UuidFilter<"UserGroupMember"> | string
    joinedAt?: DateTimeFilter<"UserGroupMember"> | Date | string
    addedBy?: UuidNullableFilter<"UserGroupMember"> | string | null
    group?: XOR<UserGroupScalarRelationFilter, UserGroupWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserGroupMemberOrderByWithRelationInput = {
    id?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
    joinedAt?: SortOrder
    addedBy?: SortOrderInput | SortOrder
    group?: UserGroupOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type UserGroupMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    groupId_userId?: UserGroupMemberGroupIdUserIdCompoundUniqueInput
    AND?: UserGroupMemberWhereInput | UserGroupMemberWhereInput[]
    OR?: UserGroupMemberWhereInput[]
    NOT?: UserGroupMemberWhereInput | UserGroupMemberWhereInput[]
    groupId?: UuidFilter<"UserGroupMember"> | string
    userId?: UuidFilter<"UserGroupMember"> | string
    joinedAt?: DateTimeFilter<"UserGroupMember"> | Date | string
    addedBy?: UuidNullableFilter<"UserGroupMember"> | string | null
    group?: XOR<UserGroupScalarRelationFilter, UserGroupWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "groupId_userId">

  export type UserGroupMemberOrderByWithAggregationInput = {
    id?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
    joinedAt?: SortOrder
    addedBy?: SortOrderInput | SortOrder
    _count?: UserGroupMemberCountOrderByAggregateInput
    _max?: UserGroupMemberMaxOrderByAggregateInput
    _min?: UserGroupMemberMinOrderByAggregateInput
  }

  export type UserGroupMemberScalarWhereWithAggregatesInput = {
    AND?: UserGroupMemberScalarWhereWithAggregatesInput | UserGroupMemberScalarWhereWithAggregatesInput[]
    OR?: UserGroupMemberScalarWhereWithAggregatesInput[]
    NOT?: UserGroupMemberScalarWhereWithAggregatesInput | UserGroupMemberScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"UserGroupMember"> | string
    groupId?: UuidWithAggregatesFilter<"UserGroupMember"> | string
    userId?: UuidWithAggregatesFilter<"UserGroupMember"> | string
    joinedAt?: DateTimeWithAggregatesFilter<"UserGroupMember"> | Date | string
    addedBy?: UuidNullableWithAggregatesFilter<"UserGroupMember"> | string | null
  }

  export type PermissionWhereInput = {
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    id?: UuidFilter<"Permission"> | string
    resourceType?: EnumResourceTypeFilter<"Permission"> | $Enums.ResourceType
    action?: EnumPermissionActionFilter<"Permission"> | $Enums.PermissionAction
    permissionName?: StringFilter<"Permission"> | string
    description?: StringNullableFilter<"Permission"> | string | null
    createdAt?: DateTimeFilter<"Permission"> | Date | string
    rolePermissions?: RolePermissionListRelationFilter
  }

  export type PermissionOrderByWithRelationInput = {
    id?: SortOrder
    resourceType?: SortOrder
    action?: SortOrder
    permissionName?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    rolePermissions?: RolePermissionOrderByRelationAggregateInput
  }

  export type PermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    permissionName?: string
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    resourceType?: EnumResourceTypeFilter<"Permission"> | $Enums.ResourceType
    action?: EnumPermissionActionFilter<"Permission"> | $Enums.PermissionAction
    description?: StringNullableFilter<"Permission"> | string | null
    createdAt?: DateTimeFilter<"Permission"> | Date | string
    rolePermissions?: RolePermissionListRelationFilter
  }, "id" | "permissionName">

  export type PermissionOrderByWithAggregationInput = {
    id?: SortOrder
    resourceType?: SortOrder
    action?: SortOrder
    permissionName?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PermissionCountOrderByAggregateInput
    _max?: PermissionMaxOrderByAggregateInput
    _min?: PermissionMinOrderByAggregateInput
  }

  export type PermissionScalarWhereWithAggregatesInput = {
    AND?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    OR?: PermissionScalarWhereWithAggregatesInput[]
    NOT?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Permission"> | string
    resourceType?: EnumResourceTypeWithAggregatesFilter<"Permission"> | $Enums.ResourceType
    action?: EnumPermissionActionWithAggregatesFilter<"Permission"> | $Enums.PermissionAction
    permissionName?: StringWithAggregatesFilter<"Permission"> | string
    description?: StringNullableWithAggregatesFilter<"Permission"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Permission"> | Date | string
  }

  export type RolePermissionWhereInput = {
    AND?: RolePermissionWhereInput | RolePermissionWhereInput[]
    OR?: RolePermissionWhereInput[]
    NOT?: RolePermissionWhereInput | RolePermissionWhereInput[]
    id?: UuidFilter<"RolePermission"> | string
    role?: EnumUserRoleFilter<"RolePermission"> | $Enums.UserRole
    permissionId?: UuidFilter<"RolePermission"> | string
    permission?: XOR<PermissionScalarRelationFilter, PermissionWhereInput>
  }

  export type RolePermissionOrderByWithRelationInput = {
    id?: SortOrder
    role?: SortOrder
    permissionId?: SortOrder
    permission?: PermissionOrderByWithRelationInput
  }

  export type RolePermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    role_permissionId?: RolePermissionRolePermissionIdCompoundUniqueInput
    AND?: RolePermissionWhereInput | RolePermissionWhereInput[]
    OR?: RolePermissionWhereInput[]
    NOT?: RolePermissionWhereInput | RolePermissionWhereInput[]
    role?: EnumUserRoleFilter<"RolePermission"> | $Enums.UserRole
    permissionId?: UuidFilter<"RolePermission"> | string
    permission?: XOR<PermissionScalarRelationFilter, PermissionWhereInput>
  }, "id" | "role_permissionId">

  export type RolePermissionOrderByWithAggregationInput = {
    id?: SortOrder
    role?: SortOrder
    permissionId?: SortOrder
    _count?: RolePermissionCountOrderByAggregateInput
    _max?: RolePermissionMaxOrderByAggregateInput
    _min?: RolePermissionMinOrderByAggregateInput
  }

  export type RolePermissionScalarWhereWithAggregatesInput = {
    AND?: RolePermissionScalarWhereWithAggregatesInput | RolePermissionScalarWhereWithAggregatesInput[]
    OR?: RolePermissionScalarWhereWithAggregatesInput[]
    NOT?: RolePermissionScalarWhereWithAggregatesInput | RolePermissionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"RolePermission"> | string
    role?: EnumUserRoleWithAggregatesFilter<"RolePermission"> | $Enums.UserRole
    permissionId?: UuidWithAggregatesFilter<"RolePermission"> | string
  }

  export type InstanceWhereInput = {
    AND?: InstanceWhereInput | InstanceWhereInput[]
    OR?: InstanceWhereInput[]
    NOT?: InstanceWhereInput | InstanceWhereInput[]
    id?: UuidFilter<"Instance"> | string
    name?: StringFilter<"Instance"> | string
    tenantId?: UuidFilter<"Instance"> | string
    userId?: UuidFilter<"Instance"> | string
    status?: StringFilter<"Instance"> | string
    createdAt?: DateTimeFilter<"Instance"> | Date | string
    updatedAt?: DateTimeFilter<"Instance"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type InstanceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type InstanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InstanceWhereInput | InstanceWhereInput[]
    OR?: InstanceWhereInput[]
    NOT?: InstanceWhereInput | InstanceWhereInput[]
    name?: StringFilter<"Instance"> | string
    tenantId?: UuidFilter<"Instance"> | string
    userId?: UuidFilter<"Instance"> | string
    status?: StringFilter<"Instance"> | string
    createdAt?: DateTimeFilter<"Instance"> | Date | string
    updatedAt?: DateTimeFilter<"Instance"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type InstanceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InstanceCountOrderByAggregateInput
    _max?: InstanceMaxOrderByAggregateInput
    _min?: InstanceMinOrderByAggregateInput
  }

  export type InstanceScalarWhereWithAggregatesInput = {
    AND?: InstanceScalarWhereWithAggregatesInput | InstanceScalarWhereWithAggregatesInput[]
    OR?: InstanceScalarWhereWithAggregatesInput[]
    NOT?: InstanceScalarWhereWithAggregatesInput | InstanceScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Instance"> | string
    name?: StringWithAggregatesFilter<"Instance"> | string
    tenantId?: UuidWithAggregatesFilter<"Instance"> | string
    userId?: UuidWithAggregatesFilter<"Instance"> | string
    status?: StringWithAggregatesFilter<"Instance"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Instance"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Instance"> | Date | string
  }

  export type PrivateDataDiskWhereInput = {
    AND?: PrivateDataDiskWhereInput | PrivateDataDiskWhereInput[]
    OR?: PrivateDataDiskWhereInput[]
    NOT?: PrivateDataDiskWhereInput | PrivateDataDiskWhereInput[]
    id?: UuidFilter<"PrivateDataDisk"> | string
    name?: StringFilter<"PrivateDataDisk"> | string
    tenantId?: UuidFilter<"PrivateDataDisk"> | string
    userId?: UuidFilter<"PrivateDataDisk"> | string
    sizeGb?: IntFilter<"PrivateDataDisk"> | number
    status?: StringFilter<"PrivateDataDisk"> | string
    createdAt?: DateTimeFilter<"PrivateDataDisk"> | Date | string
    updatedAt?: DateTimeFilter<"PrivateDataDisk"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PrivateDataDiskOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    sizeGb?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type PrivateDataDiskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PrivateDataDiskWhereInput | PrivateDataDiskWhereInput[]
    OR?: PrivateDataDiskWhereInput[]
    NOT?: PrivateDataDiskWhereInput | PrivateDataDiskWhereInput[]
    name?: StringFilter<"PrivateDataDisk"> | string
    tenantId?: UuidFilter<"PrivateDataDisk"> | string
    userId?: UuidFilter<"PrivateDataDisk"> | string
    sizeGb?: IntFilter<"PrivateDataDisk"> | number
    status?: StringFilter<"PrivateDataDisk"> | string
    createdAt?: DateTimeFilter<"PrivateDataDisk"> | Date | string
    updatedAt?: DateTimeFilter<"PrivateDataDisk"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type PrivateDataDiskOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    sizeGb?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PrivateDataDiskCountOrderByAggregateInput
    _avg?: PrivateDataDiskAvgOrderByAggregateInput
    _max?: PrivateDataDiskMaxOrderByAggregateInput
    _min?: PrivateDataDiskMinOrderByAggregateInput
    _sum?: PrivateDataDiskSumOrderByAggregateInput
  }

  export type PrivateDataDiskScalarWhereWithAggregatesInput = {
    AND?: PrivateDataDiskScalarWhereWithAggregatesInput | PrivateDataDiskScalarWhereWithAggregatesInput[]
    OR?: PrivateDataDiskScalarWhereWithAggregatesInput[]
    NOT?: PrivateDataDiskScalarWhereWithAggregatesInput | PrivateDataDiskScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"PrivateDataDisk"> | string
    name?: StringWithAggregatesFilter<"PrivateDataDisk"> | string
    tenantId?: UuidWithAggregatesFilter<"PrivateDataDisk"> | string
    userId?: UuidWithAggregatesFilter<"PrivateDataDisk"> | string
    sizeGb?: IntWithAggregatesFilter<"PrivateDataDisk"> | number
    status?: StringWithAggregatesFilter<"PrivateDataDisk"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PrivateDataDisk"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PrivateDataDisk"> | Date | string
  }

  export type VpcWhereInput = {
    AND?: VpcWhereInput | VpcWhereInput[]
    OR?: VpcWhereInput[]
    NOT?: VpcWhereInput | VpcWhereInput[]
    id?: UuidFilter<"Vpc"> | string
    name?: StringFilter<"Vpc"> | string
    description?: StringNullableFilter<"Vpc"> | string | null
    tenantId?: UuidFilter<"Vpc"> | string
    userId?: UuidFilter<"Vpc"> | string
    cidrBlock?: StringFilter<"Vpc"> | string
    edgeDataCenterId?: UuidNullableFilter<"Vpc"> | string | null
    vlanId?: IntNullableFilter<"Vpc"> | number | null
    enableDns?: BoolFilter<"Vpc"> | boolean
    dnsServers?: JsonNullableFilter<"Vpc">
    status?: EnumVpcStatusFilter<"Vpc"> | $Enums.VpcStatus
    createdAt?: DateTimeFilter<"Vpc"> | Date | string
    updatedAt?: DateTimeFilter<"Vpc"> | Date | string
    createdBy?: UuidNullableFilter<"Vpc"> | string | null
    updatedBy?: UuidNullableFilter<"Vpc"> | string | null
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    subnets?: SubnetListRelationFilter
    creator?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    updater?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type VpcOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    cidrBlock?: SortOrder
    edgeDataCenterId?: SortOrderInput | SortOrder
    vlanId?: SortOrderInput | SortOrder
    enableDns?: SortOrder
    dnsServers?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    tenant?: TenantOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    subnets?: SubnetOrderByRelationAggregateInput
    creator?: UserOrderByWithRelationInput
    updater?: UserOrderByWithRelationInput
  }

  export type VpcWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId_name?: VpcTenantIdNameCompoundUniqueInput
    AND?: VpcWhereInput | VpcWhereInput[]
    OR?: VpcWhereInput[]
    NOT?: VpcWhereInput | VpcWhereInput[]
    name?: StringFilter<"Vpc"> | string
    description?: StringNullableFilter<"Vpc"> | string | null
    tenantId?: UuidFilter<"Vpc"> | string
    userId?: UuidFilter<"Vpc"> | string
    cidrBlock?: StringFilter<"Vpc"> | string
    edgeDataCenterId?: UuidNullableFilter<"Vpc"> | string | null
    vlanId?: IntNullableFilter<"Vpc"> | number | null
    enableDns?: BoolFilter<"Vpc"> | boolean
    dnsServers?: JsonNullableFilter<"Vpc">
    status?: EnumVpcStatusFilter<"Vpc"> | $Enums.VpcStatus
    createdAt?: DateTimeFilter<"Vpc"> | Date | string
    updatedAt?: DateTimeFilter<"Vpc"> | Date | string
    createdBy?: UuidNullableFilter<"Vpc"> | string | null
    updatedBy?: UuidNullableFilter<"Vpc"> | string | null
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    subnets?: SubnetListRelationFilter
    creator?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    updater?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "tenantId_name">

  export type VpcOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    cidrBlock?: SortOrder
    edgeDataCenterId?: SortOrderInput | SortOrder
    vlanId?: SortOrderInput | SortOrder
    enableDns?: SortOrder
    dnsServers?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: VpcCountOrderByAggregateInput
    _avg?: VpcAvgOrderByAggregateInput
    _max?: VpcMaxOrderByAggregateInput
    _min?: VpcMinOrderByAggregateInput
    _sum?: VpcSumOrderByAggregateInput
  }

  export type VpcScalarWhereWithAggregatesInput = {
    AND?: VpcScalarWhereWithAggregatesInput | VpcScalarWhereWithAggregatesInput[]
    OR?: VpcScalarWhereWithAggregatesInput[]
    NOT?: VpcScalarWhereWithAggregatesInput | VpcScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Vpc"> | string
    name?: StringWithAggregatesFilter<"Vpc"> | string
    description?: StringNullableWithAggregatesFilter<"Vpc"> | string | null
    tenantId?: UuidWithAggregatesFilter<"Vpc"> | string
    userId?: UuidWithAggregatesFilter<"Vpc"> | string
    cidrBlock?: StringWithAggregatesFilter<"Vpc"> | string
    edgeDataCenterId?: UuidNullableWithAggregatesFilter<"Vpc"> | string | null
    vlanId?: IntNullableWithAggregatesFilter<"Vpc"> | number | null
    enableDns?: BoolWithAggregatesFilter<"Vpc"> | boolean
    dnsServers?: JsonNullableWithAggregatesFilter<"Vpc">
    status?: EnumVpcStatusWithAggregatesFilter<"Vpc"> | $Enums.VpcStatus
    createdAt?: DateTimeWithAggregatesFilter<"Vpc"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Vpc"> | Date | string
    createdBy?: UuidNullableWithAggregatesFilter<"Vpc"> | string | null
    updatedBy?: UuidNullableWithAggregatesFilter<"Vpc"> | string | null
  }

  export type PlaceWhereInput = {
    AND?: PlaceWhereInput | PlaceWhereInput[]
    OR?: PlaceWhereInput[]
    NOT?: PlaceWhereInput | PlaceWhereInput[]
    id?: UuidFilter<"Place"> | string
    name?: StringFilter<"Place"> | string
    description?: StringNullableFilter<"Place"> | string | null
    tenantId?: UuidFilter<"Place"> | string
    subnetId?: UuidNullableFilter<"Place"> | string | null
    location?: StringNullableFilter<"Place"> | string | null
    status?: EnumPlaceStatusFilter<"Place"> | $Enums.PlaceStatus
    createdAt?: DateTimeFilter<"Place"> | Date | string
    updatedAt?: DateTimeFilter<"Place"> | Date | string
    createdBy?: UuidNullableFilter<"Place"> | string | null
    updatedBy?: UuidNullableFilter<"Place"> | string | null
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    subnet?: XOR<SubnetNullableScalarRelationFilter, SubnetWhereInput> | null
    creator?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    updater?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type PlaceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    tenantId?: SortOrder
    subnetId?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    tenant?: TenantOrderByWithRelationInput
    subnet?: SubnetOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
    updater?: UserOrderByWithRelationInput
  }

  export type PlaceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    subnetId?: string
    tenantId_name?: PlaceTenantIdNameCompoundUniqueInput
    AND?: PlaceWhereInput | PlaceWhereInput[]
    OR?: PlaceWhereInput[]
    NOT?: PlaceWhereInput | PlaceWhereInput[]
    name?: StringFilter<"Place"> | string
    description?: StringNullableFilter<"Place"> | string | null
    tenantId?: UuidFilter<"Place"> | string
    location?: StringNullableFilter<"Place"> | string | null
    status?: EnumPlaceStatusFilter<"Place"> | $Enums.PlaceStatus
    createdAt?: DateTimeFilter<"Place"> | Date | string
    updatedAt?: DateTimeFilter<"Place"> | Date | string
    createdBy?: UuidNullableFilter<"Place"> | string | null
    updatedBy?: UuidNullableFilter<"Place"> | string | null
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    subnet?: XOR<SubnetNullableScalarRelationFilter, SubnetWhereInput> | null
    creator?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    updater?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "subnetId" | "tenantId_name">

  export type PlaceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    tenantId?: SortOrder
    subnetId?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: PlaceCountOrderByAggregateInput
    _max?: PlaceMaxOrderByAggregateInput
    _min?: PlaceMinOrderByAggregateInput
  }

  export type PlaceScalarWhereWithAggregatesInput = {
    AND?: PlaceScalarWhereWithAggregatesInput | PlaceScalarWhereWithAggregatesInput[]
    OR?: PlaceScalarWhereWithAggregatesInput[]
    NOT?: PlaceScalarWhereWithAggregatesInput | PlaceScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Place"> | string
    name?: StringWithAggregatesFilter<"Place"> | string
    description?: StringNullableWithAggregatesFilter<"Place"> | string | null
    tenantId?: UuidWithAggregatesFilter<"Place"> | string
    subnetId?: UuidNullableWithAggregatesFilter<"Place"> | string | null
    location?: StringNullableWithAggregatesFilter<"Place"> | string | null
    status?: EnumPlaceStatusWithAggregatesFilter<"Place"> | $Enums.PlaceStatus
    createdAt?: DateTimeWithAggregatesFilter<"Place"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Place"> | Date | string
    createdBy?: UuidNullableWithAggregatesFilter<"Place"> | string | null
    updatedBy?: UuidNullableWithAggregatesFilter<"Place"> | string | null
  }

  export type SubnetWhereInput = {
    AND?: SubnetWhereInput | SubnetWhereInput[]
    OR?: SubnetWhereInput[]
    NOT?: SubnetWhereInput | SubnetWhereInput[]
    id?: UuidFilter<"Subnet"> | string
    name?: StringFilter<"Subnet"> | string
    vpcId?: UuidFilter<"Subnet"> | string
    cidrBlock?: StringFilter<"Subnet"> | string
    availabilityZone?: StringNullableFilter<"Subnet"> | string | null
    gateway?: StringNullableFilter<"Subnet"> | string | null
    vlanId?: IntNullableFilter<"Subnet"> | number | null
    isPublic?: BoolFilter<"Subnet"> | boolean
    autoAssignIp?: BoolFilter<"Subnet"> | boolean
    status?: EnumSubnetStatusFilter<"Subnet"> | $Enums.SubnetStatus
    createdAt?: DateTimeFilter<"Subnet"> | Date | string
    updatedAt?: DateTimeFilter<"Subnet"> | Date | string
    createdBy?: UuidNullableFilter<"Subnet"> | string | null
    updatedBy?: UuidNullableFilter<"Subnet"> | string | null
    vpc?: XOR<VpcScalarRelationFilter, VpcWhereInput>
    place?: XOR<PlaceNullableScalarRelationFilter, PlaceWhereInput> | null
    creator?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    updater?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type SubnetOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    vpcId?: SortOrder
    cidrBlock?: SortOrder
    availabilityZone?: SortOrderInput | SortOrder
    gateway?: SortOrderInput | SortOrder
    vlanId?: SortOrderInput | SortOrder
    isPublic?: SortOrder
    autoAssignIp?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    vpc?: VpcOrderByWithRelationInput
    place?: PlaceOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
    updater?: UserOrderByWithRelationInput
  }

  export type SubnetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    vpcId_cidrBlock?: SubnetVpcIdCidrBlockCompoundUniqueInput
    AND?: SubnetWhereInput | SubnetWhereInput[]
    OR?: SubnetWhereInput[]
    NOT?: SubnetWhereInput | SubnetWhereInput[]
    name?: StringFilter<"Subnet"> | string
    vpcId?: UuidFilter<"Subnet"> | string
    cidrBlock?: StringFilter<"Subnet"> | string
    availabilityZone?: StringNullableFilter<"Subnet"> | string | null
    gateway?: StringNullableFilter<"Subnet"> | string | null
    vlanId?: IntNullableFilter<"Subnet"> | number | null
    isPublic?: BoolFilter<"Subnet"> | boolean
    autoAssignIp?: BoolFilter<"Subnet"> | boolean
    status?: EnumSubnetStatusFilter<"Subnet"> | $Enums.SubnetStatus
    createdAt?: DateTimeFilter<"Subnet"> | Date | string
    updatedAt?: DateTimeFilter<"Subnet"> | Date | string
    createdBy?: UuidNullableFilter<"Subnet"> | string | null
    updatedBy?: UuidNullableFilter<"Subnet"> | string | null
    vpc?: XOR<VpcScalarRelationFilter, VpcWhereInput>
    place?: XOR<PlaceNullableScalarRelationFilter, PlaceWhereInput> | null
    creator?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    updater?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "vpcId_cidrBlock">

  export type SubnetOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    vpcId?: SortOrder
    cidrBlock?: SortOrder
    availabilityZone?: SortOrderInput | SortOrder
    gateway?: SortOrderInput | SortOrder
    vlanId?: SortOrderInput | SortOrder
    isPublic?: SortOrder
    autoAssignIp?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: SubnetCountOrderByAggregateInput
    _avg?: SubnetAvgOrderByAggregateInput
    _max?: SubnetMaxOrderByAggregateInput
    _min?: SubnetMinOrderByAggregateInput
    _sum?: SubnetSumOrderByAggregateInput
  }

  export type SubnetScalarWhereWithAggregatesInput = {
    AND?: SubnetScalarWhereWithAggregatesInput | SubnetScalarWhereWithAggregatesInput[]
    OR?: SubnetScalarWhereWithAggregatesInput[]
    NOT?: SubnetScalarWhereWithAggregatesInput | SubnetScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Subnet"> | string
    name?: StringWithAggregatesFilter<"Subnet"> | string
    vpcId?: UuidWithAggregatesFilter<"Subnet"> | string
    cidrBlock?: StringWithAggregatesFilter<"Subnet"> | string
    availabilityZone?: StringNullableWithAggregatesFilter<"Subnet"> | string | null
    gateway?: StringNullableWithAggregatesFilter<"Subnet"> | string | null
    vlanId?: IntNullableWithAggregatesFilter<"Subnet"> | number | null
    isPublic?: BoolWithAggregatesFilter<"Subnet"> | boolean
    autoAssignIp?: BoolWithAggregatesFilter<"Subnet"> | boolean
    status?: EnumSubnetStatusWithAggregatesFilter<"Subnet"> | $Enums.SubnetStatus
    createdAt?: DateTimeWithAggregatesFilter<"Subnet"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Subnet"> | Date | string
    createdBy?: UuidNullableWithAggregatesFilter<"Subnet"> | string | null
    updatedBy?: UuidNullableWithAggregatesFilter<"Subnet"> | string | null
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: UuidFilter<"AuditLog"> | string
    userId?: UuidFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    resourceType?: StringFilter<"AuditLog"> | string
    resourceId?: UuidNullableFilter<"AuditLog"> | string | null
    details?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    status?: StringFilter<"AuditLog"> | string
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resourceType?: SortOrder
    resourceId?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    userId?: UuidFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    resourceType?: StringFilter<"AuditLog"> | string
    resourceId?: UuidNullableFilter<"AuditLog"> | string | null
    details?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    status?: StringFilter<"AuditLog"> | string
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resourceType?: SortOrder
    resourceId?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"AuditLog"> | string
    userId?: UuidWithAggregatesFilter<"AuditLog"> | string
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    resourceType?: StringWithAggregatesFilter<"AuditLog"> | string
    resourceId?: UuidNullableWithAggregatesFilter<"AuditLog"> | string | null
    details?: JsonNullableWithAggregatesFilter<"AuditLog">
    ipAddress?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    status?: StringWithAggregatesFilter<"AuditLog"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type TenantCreateInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.TenantStatus
    adminUserId?: string | null
    vlanId?: number | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    userGroups?: UserGroupCreateNestedManyWithoutTenantInput
    instances?: InstanceCreateNestedManyWithoutTenantInput
    privateDataDisks?: PrivateDataDiskCreateNestedManyWithoutTenantInput
    vpcs?: VpcCreateNestedManyWithoutTenantInput
    places?: PlaceCreateNestedManyWithoutTenantInput
    creator?: UserCreateNestedOneWithoutCreatedTenantsInput
  }

  export type TenantUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.TenantStatus
    adminUserId?: string | null
    vlanId?: number | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    userGroups?: UserGroupUncheckedCreateNestedManyWithoutTenantInput
    instances?: InstanceUncheckedCreateNestedManyWithoutTenantInput
    privateDataDisks?: PrivateDataDiskUncheckedCreateNestedManyWithoutTenantInput
    vpcs?: VpcUncheckedCreateNestedManyWithoutTenantInput
    places?: PlaceUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    vlanId?: NullableIntFieldUpdateOperationsInput | number | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    userGroups?: UserGroupUpdateManyWithoutTenantNestedInput
    instances?: InstanceUpdateManyWithoutTenantNestedInput
    privateDataDisks?: PrivateDataDiskUpdateManyWithoutTenantNestedInput
    vpcs?: VpcUpdateManyWithoutTenantNestedInput
    places?: PlaceUpdateManyWithoutTenantNestedInput
    creator?: UserUpdateOneWithoutCreatedTenantsNestedInput
  }

  export type TenantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    vlanId?: NullableIntFieldUpdateOperationsInput | number | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    userGroups?: UserGroupUncheckedUpdateManyWithoutTenantNestedInput
    instances?: InstanceUncheckedUpdateManyWithoutTenantNestedInput
    privateDataDisks?: PrivateDataDiskUncheckedUpdateManyWithoutTenantNestedInput
    vpcs?: VpcUncheckedUpdateManyWithoutTenantNestedInput
    places?: PlaceUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.TenantStatus
    adminUserId?: string | null
    vlanId?: number | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
  }

  export type TenantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    vlanId?: NullableIntFieldUpdateOperationsInput | number | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    vlanId?: NullableIntFieldUpdateOperationsInput | number | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateInput = {
    id?: string
    username: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant?: TenantCreateNestedOneWithoutUsersInput
    groupMemberships?: UserGroupMemberCreateNestedManyWithoutUserInput
    instances?: InstanceCreateNestedManyWithoutUserInput
    privateDataDisks?: PrivateDataDiskCreateNestedManyWithoutUserInput
    createdTenants?: TenantCreateNestedManyWithoutCreatorInput
    vpcs?: VpcCreateNestedManyWithoutUserInput
    createdVpcs?: VpcCreateNestedManyWithoutCreatorInput
    updatedVpcs?: VpcCreateNestedManyWithoutUpdaterInput
    createdPlaces?: PlaceCreateNestedManyWithoutCreatorInput
    updatedPlaces?: PlaceCreateNestedManyWithoutUpdaterInput
    createdSubnets?: SubnetCreateNestedManyWithoutCreatorInput
    updatedSubnets?: SubnetCreateNestedManyWithoutUpdaterInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    username: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    tenantId?: string | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    groupMemberships?: UserGroupMemberUncheckedCreateNestedManyWithoutUserInput
    instances?: InstanceUncheckedCreateNestedManyWithoutUserInput
    privateDataDisks?: PrivateDataDiskUncheckedCreateNestedManyWithoutUserInput
    createdTenants?: TenantUncheckedCreateNestedManyWithoutCreatorInput
    vpcs?: VpcUncheckedCreateNestedManyWithoutUserInput
    createdVpcs?: VpcUncheckedCreateNestedManyWithoutCreatorInput
    updatedVpcs?: VpcUncheckedCreateNestedManyWithoutUpdaterInput
    createdPlaces?: PlaceUncheckedCreateNestedManyWithoutCreatorInput
    updatedPlaces?: PlaceUncheckedCreateNestedManyWithoutUpdaterInput
    createdSubnets?: SubnetUncheckedCreateNestedManyWithoutCreatorInput
    updatedSubnets?: SubnetUncheckedCreateNestedManyWithoutUpdaterInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutUsersNestedInput
    groupMemberships?: UserGroupMemberUpdateManyWithoutUserNestedInput
    instances?: InstanceUpdateManyWithoutUserNestedInput
    privateDataDisks?: PrivateDataDiskUpdateManyWithoutUserNestedInput
    createdTenants?: TenantUpdateManyWithoutCreatorNestedInput
    vpcs?: VpcUpdateManyWithoutUserNestedInput
    createdVpcs?: VpcUpdateManyWithoutCreatorNestedInput
    updatedVpcs?: VpcUpdateManyWithoutUpdaterNestedInput
    createdPlaces?: PlaceUpdateManyWithoutCreatorNestedInput
    updatedPlaces?: PlaceUpdateManyWithoutUpdaterNestedInput
    createdSubnets?: SubnetUpdateManyWithoutCreatorNestedInput
    updatedSubnets?: SubnetUpdateManyWithoutUpdaterNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groupMemberships?: UserGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    instances?: InstanceUncheckedUpdateManyWithoutUserNestedInput
    privateDataDisks?: PrivateDataDiskUncheckedUpdateManyWithoutUserNestedInput
    createdTenants?: TenantUncheckedUpdateManyWithoutCreatorNestedInput
    vpcs?: VpcUncheckedUpdateManyWithoutUserNestedInput
    createdVpcs?: VpcUncheckedUpdateManyWithoutCreatorNestedInput
    updatedVpcs?: VpcUncheckedUpdateManyWithoutUpdaterNestedInput
    createdPlaces?: PlaceUncheckedUpdateManyWithoutCreatorNestedInput
    updatedPlaces?: PlaceUncheckedUpdateManyWithoutUpdaterNestedInput
    createdSubnets?: SubnetUncheckedUpdateManyWithoutCreatorNestedInput
    updatedSubnets?: SubnetUncheckedUpdateManyWithoutUpdaterNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    username: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    tenantId?: string | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserGroupCreateInput = {
    id?: string
    name: string
    description?: string | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutUserGroupsInput
    parentGroup?: UserGroupCreateNestedOneWithoutChildGroupsInput
    childGroups?: UserGroupCreateNestedManyWithoutParentGroupInput
    members?: UserGroupMemberCreateNestedManyWithoutGroupInput
  }

  export type UserGroupUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    tenantId: string
    parentGroupId?: string | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    childGroups?: UserGroupUncheckedCreateNestedManyWithoutParentGroupInput
    members?: UserGroupMemberUncheckedCreateNestedManyWithoutGroupInput
  }

  export type UserGroupUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutUserGroupsNestedInput
    parentGroup?: UserGroupUpdateOneWithoutChildGroupsNestedInput
    childGroups?: UserGroupUpdateManyWithoutParentGroupNestedInput
    members?: UserGroupMemberUpdateManyWithoutGroupNestedInput
  }

  export type UserGroupUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    parentGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    childGroups?: UserGroupUncheckedUpdateManyWithoutParentGroupNestedInput
    members?: UserGroupMemberUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type UserGroupCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    tenantId: string
    parentGroupId?: string | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserGroupUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserGroupUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    parentGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserGroupMemberCreateInput = {
    id?: string
    joinedAt?: Date | string
    addedBy?: string | null
    group: UserGroupCreateNestedOneWithoutMembersInput
    user: UserCreateNestedOneWithoutGroupMembershipsInput
  }

  export type UserGroupMemberUncheckedCreateInput = {
    id?: string
    groupId: string
    userId: string
    joinedAt?: Date | string
    addedBy?: string | null
  }

  export type UserGroupMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addedBy?: NullableStringFieldUpdateOperationsInput | string | null
    group?: UserGroupUpdateOneRequiredWithoutMembersNestedInput
    user?: UserUpdateOneRequiredWithoutGroupMembershipsNestedInput
  }

  export type UserGroupMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserGroupMemberCreateManyInput = {
    id?: string
    groupId: string
    userId: string
    joinedAt?: Date | string
    addedBy?: string | null
  }

  export type UserGroupMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserGroupMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PermissionCreateInput = {
    id?: string
    resourceType: $Enums.ResourceType
    action: $Enums.PermissionAction
    permissionName: string
    description?: string | null
    createdAt?: Date | string
    rolePermissions?: RolePermissionCreateNestedManyWithoutPermissionInput
  }

  export type PermissionUncheckedCreateInput = {
    id?: string
    resourceType: $Enums.ResourceType
    action: $Enums.PermissionAction
    permissionName: string
    description?: string | null
    createdAt?: Date | string
    rolePermissions?: RolePermissionUncheckedCreateNestedManyWithoutPermissionInput
  }

  export type PermissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    resourceType?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    action?: EnumPermissionActionFieldUpdateOperationsInput | $Enums.PermissionAction
    permissionName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rolePermissions?: RolePermissionUpdateManyWithoutPermissionNestedInput
  }

  export type PermissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    resourceType?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    action?: EnumPermissionActionFieldUpdateOperationsInput | $Enums.PermissionAction
    permissionName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rolePermissions?: RolePermissionUncheckedUpdateManyWithoutPermissionNestedInput
  }

  export type PermissionCreateManyInput = {
    id?: string
    resourceType: $Enums.ResourceType
    action: $Enums.PermissionAction
    permissionName: string
    description?: string | null
    createdAt?: Date | string
  }

  export type PermissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    resourceType?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    action?: EnumPermissionActionFieldUpdateOperationsInput | $Enums.PermissionAction
    permissionName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    resourceType?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    action?: EnumPermissionActionFieldUpdateOperationsInput | $Enums.PermissionAction
    permissionName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionCreateInput = {
    id?: string
    role: $Enums.UserRole
    permission: PermissionCreateNestedOneWithoutRolePermissionsInput
  }

  export type RolePermissionUncheckedCreateInput = {
    id?: string
    role: $Enums.UserRole
    permissionId: string
  }

  export type RolePermissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    permission?: PermissionUpdateOneRequiredWithoutRolePermissionsNestedInput
  }

  export type RolePermissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    permissionId?: StringFieldUpdateOperationsInput | string
  }

  export type RolePermissionCreateManyInput = {
    id?: string
    role: $Enums.UserRole
    permissionId: string
  }

  export type RolePermissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
  }

  export type RolePermissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    permissionId?: StringFieldUpdateOperationsInput | string
  }

  export type InstanceCreateInput = {
    id?: string
    name: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutInstancesInput
    user: UserCreateNestedOneWithoutInstancesInput
  }

  export type InstanceUncheckedCreateInput = {
    id?: string
    name: string
    tenantId: string
    userId: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InstanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutInstancesNestedInput
    user?: UserUpdateOneRequiredWithoutInstancesNestedInput
  }

  export type InstanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstanceCreateManyInput = {
    id?: string
    name: string
    tenantId: string
    userId: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InstanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrivateDataDiskCreateInput = {
    id?: string
    name: string
    sizeGb: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutPrivateDataDisksInput
    user: UserCreateNestedOneWithoutPrivateDataDisksInput
  }

  export type PrivateDataDiskUncheckedCreateInput = {
    id?: string
    name: string
    tenantId: string
    userId: string
    sizeGb: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PrivateDataDiskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sizeGb?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutPrivateDataDisksNestedInput
    user?: UserUpdateOneRequiredWithoutPrivateDataDisksNestedInput
  }

  export type PrivateDataDiskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sizeGb?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrivateDataDiskCreateManyInput = {
    id?: string
    name: string
    tenantId: string
    userId: string
    sizeGb: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PrivateDataDiskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sizeGb?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrivateDataDiskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sizeGb?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VpcCreateInput = {
    id?: string
    name: string
    description?: string | null
    cidrBlock: string
    edgeDataCenterId?: string | null
    vlanId?: number | null
    enableDns?: boolean
    dnsServers?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.VpcStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutVpcsInput
    user: UserCreateNestedOneWithoutVpcsInput
    subnets?: SubnetCreateNestedManyWithoutVpcInput
    creator?: UserCreateNestedOneWithoutCreatedVpcsInput
    updater?: UserCreateNestedOneWithoutUpdatedVpcsInput
  }

  export type VpcUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    tenantId: string
    userId: string
    cidrBlock: string
    edgeDataCenterId?: string | null
    vlanId?: number | null
    enableDns?: boolean
    dnsServers?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.VpcStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    subnets?: SubnetUncheckedCreateNestedManyWithoutVpcInput
  }

  export type VpcUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cidrBlock?: StringFieldUpdateOperationsInput | string
    edgeDataCenterId?: NullableStringFieldUpdateOperationsInput | string | null
    vlanId?: NullableIntFieldUpdateOperationsInput | number | null
    enableDns?: BoolFieldUpdateOperationsInput | boolean
    dnsServers?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumVpcStatusFieldUpdateOperationsInput | $Enums.VpcStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutVpcsNestedInput
    user?: UserUpdateOneRequiredWithoutVpcsNestedInput
    subnets?: SubnetUpdateManyWithoutVpcNestedInput
    creator?: UserUpdateOneWithoutCreatedVpcsNestedInput
    updater?: UserUpdateOneWithoutUpdatedVpcsNestedInput
  }

  export type VpcUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    cidrBlock?: StringFieldUpdateOperationsInput | string
    edgeDataCenterId?: NullableStringFieldUpdateOperationsInput | string | null
    vlanId?: NullableIntFieldUpdateOperationsInput | number | null
    enableDns?: BoolFieldUpdateOperationsInput | boolean
    dnsServers?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumVpcStatusFieldUpdateOperationsInput | $Enums.VpcStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    subnets?: SubnetUncheckedUpdateManyWithoutVpcNestedInput
  }

  export type VpcCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    tenantId: string
    userId: string
    cidrBlock: string
    edgeDataCenterId?: string | null
    vlanId?: number | null
    enableDns?: boolean
    dnsServers?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.VpcStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
  }

  export type VpcUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cidrBlock?: StringFieldUpdateOperationsInput | string
    edgeDataCenterId?: NullableStringFieldUpdateOperationsInput | string | null
    vlanId?: NullableIntFieldUpdateOperationsInput | number | null
    enableDns?: BoolFieldUpdateOperationsInput | boolean
    dnsServers?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumVpcStatusFieldUpdateOperationsInput | $Enums.VpcStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VpcUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    cidrBlock?: StringFieldUpdateOperationsInput | string
    edgeDataCenterId?: NullableStringFieldUpdateOperationsInput | string | null
    vlanId?: NullableIntFieldUpdateOperationsInput | number | null
    enableDns?: BoolFieldUpdateOperationsInput | boolean
    dnsServers?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumVpcStatusFieldUpdateOperationsInput | $Enums.VpcStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PlaceCreateInput = {
    id?: string
    name: string
    description?: string | null
    location?: string | null
    status?: $Enums.PlaceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutPlacesInput
    subnet?: SubnetCreateNestedOneWithoutPlaceInput
    creator?: UserCreateNestedOneWithoutCreatedPlacesInput
    updater?: UserCreateNestedOneWithoutUpdatedPlacesInput
  }

  export type PlaceUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    tenantId: string
    subnetId?: string | null
    location?: string | null
    status?: $Enums.PlaceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
  }

  export type PlaceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPlaceStatusFieldUpdateOperationsInput | $Enums.PlaceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutPlacesNestedInput
    subnet?: SubnetUpdateOneWithoutPlaceNestedInput
    creator?: UserUpdateOneWithoutCreatedPlacesNestedInput
    updater?: UserUpdateOneWithoutUpdatedPlacesNestedInput
  }

  export type PlaceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    subnetId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPlaceStatusFieldUpdateOperationsInput | $Enums.PlaceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PlaceCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    tenantId: string
    subnetId?: string | null
    location?: string | null
    status?: $Enums.PlaceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
  }

  export type PlaceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPlaceStatusFieldUpdateOperationsInput | $Enums.PlaceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlaceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    subnetId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPlaceStatusFieldUpdateOperationsInput | $Enums.PlaceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SubnetCreateInput = {
    id?: string
    name: string
    cidrBlock: string
    availabilityZone?: string | null
    gateway?: string | null
    vlanId?: number | null
    isPublic?: boolean
    autoAssignIp?: boolean
    status?: $Enums.SubnetStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    vpc: VpcCreateNestedOneWithoutSubnetsInput
    place?: PlaceCreateNestedOneWithoutSubnetInput
    creator?: UserCreateNestedOneWithoutCreatedSubnetsInput
    updater?: UserCreateNestedOneWithoutUpdatedSubnetsInput
  }

  export type SubnetUncheckedCreateInput = {
    id?: string
    name: string
    vpcId: string
    cidrBlock: string
    availabilityZone?: string | null
    gateway?: string | null
    vlanId?: number | null
    isPublic?: boolean
    autoAssignIp?: boolean
    status?: $Enums.SubnetStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    place?: PlaceUncheckedCreateNestedOneWithoutSubnetInput
  }

  export type SubnetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cidrBlock?: StringFieldUpdateOperationsInput | string
    availabilityZone?: NullableStringFieldUpdateOperationsInput | string | null
    gateway?: NullableStringFieldUpdateOperationsInput | string | null
    vlanId?: NullableIntFieldUpdateOperationsInput | number | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    autoAssignIp?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumSubnetStatusFieldUpdateOperationsInput | $Enums.SubnetStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vpc?: VpcUpdateOneRequiredWithoutSubnetsNestedInput
    place?: PlaceUpdateOneWithoutSubnetNestedInput
    creator?: UserUpdateOneWithoutCreatedSubnetsNestedInput
    updater?: UserUpdateOneWithoutUpdatedSubnetsNestedInput
  }

  export type SubnetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    vpcId?: StringFieldUpdateOperationsInput | string
    cidrBlock?: StringFieldUpdateOperationsInput | string
    availabilityZone?: NullableStringFieldUpdateOperationsInput | string | null
    gateway?: NullableStringFieldUpdateOperationsInput | string | null
    vlanId?: NullableIntFieldUpdateOperationsInput | number | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    autoAssignIp?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumSubnetStatusFieldUpdateOperationsInput | $Enums.SubnetStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    place?: PlaceUncheckedUpdateOneWithoutSubnetNestedInput
  }

  export type SubnetCreateManyInput = {
    id?: string
    name: string
    vpcId: string
    cidrBlock: string
    availabilityZone?: string | null
    gateway?: string | null
    vlanId?: number | null
    isPublic?: boolean
    autoAssignIp?: boolean
    status?: $Enums.SubnetStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
  }

  export type SubnetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cidrBlock?: StringFieldUpdateOperationsInput | string
    availabilityZone?: NullableStringFieldUpdateOperationsInput | string | null
    gateway?: NullableStringFieldUpdateOperationsInput | string | null
    vlanId?: NullableIntFieldUpdateOperationsInput | number | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    autoAssignIp?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumSubnetStatusFieldUpdateOperationsInput | $Enums.SubnetStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubnetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    vpcId?: StringFieldUpdateOperationsInput | string
    cidrBlock?: StringFieldUpdateOperationsInput | string
    availabilityZone?: NullableStringFieldUpdateOperationsInput | string | null
    gateway?: NullableStringFieldUpdateOperationsInput | string | null
    vlanId?: NullableIntFieldUpdateOperationsInput | number | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    autoAssignIp?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumSubnetStatusFieldUpdateOperationsInput | $Enums.SubnetStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditLogCreateInput = {
    id?: string
    action: string
    resourceType: string
    resourceId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    status: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    userId: string
    action: string
    resourceType: string
    resourceId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    status: string
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resourceType?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resourceType?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    userId: string
    action: string
    resourceType: string
    resourceId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    status: string
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resourceType?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resourceType?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumTenantStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TenantStatus | EnumTenantStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TenantStatus[] | ListEnumTenantStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TenantStatus[] | ListEnumTenantStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTenantStatusFilter<$PrismaModel> | $Enums.TenantStatus
  }

  export type UuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type UserGroupListRelationFilter = {
    every?: UserGroupWhereInput
    some?: UserGroupWhereInput
    none?: UserGroupWhereInput
  }

  export type InstanceListRelationFilter = {
    every?: InstanceWhereInput
    some?: InstanceWhereInput
    none?: InstanceWhereInput
  }

  export type PrivateDataDiskListRelationFilter = {
    every?: PrivateDataDiskWhereInput
    some?: PrivateDataDiskWhereInput
    none?: PrivateDataDiskWhereInput
  }

  export type VpcListRelationFilter = {
    every?: VpcWhereInput
    some?: VpcWhereInput
    none?: VpcWhereInput
  }

  export type PlaceListRelationFilter = {
    every?: PlaceWhereInput
    some?: PlaceWhereInput
    none?: PlaceWhereInput
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserGroupOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InstanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PrivateDataDiskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VpcOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlaceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TenantCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    adminUserId?: SortOrder
    vlanId?: SortOrder
    quotaConfig?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type TenantAvgOrderByAggregateInput = {
    vlanId?: SortOrder
  }

  export type TenantMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    adminUserId?: SortOrder
    vlanId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type TenantMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    adminUserId?: SortOrder
    vlanId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type TenantSumOrderByAggregateInput = {
    vlanId?: SortOrder
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumTenantStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TenantStatus | EnumTenantStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TenantStatus[] | ListEnumTenantStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TenantStatus[] | ListEnumTenantStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTenantStatusWithAggregatesFilter<$PrismaModel> | $Enums.TenantStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTenantStatusFilter<$PrismaModel>
    _max?: NestedEnumTenantStatusFilter<$PrismaModel>
  }

  export type UuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type EnumUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusFilter<$PrismaModel> | $Enums.UserStatus
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type TenantNullableScalarRelationFilter = {
    is?: TenantWhereInput | null
    isNot?: TenantWhereInput | null
  }

  export type UserGroupMemberListRelationFilter = {
    every?: UserGroupMemberWhereInput
    some?: UserGroupMemberWhereInput
    none?: UserGroupMemberWhereInput
  }

  export type TenantListRelationFilter = {
    every?: TenantWhereInput
    some?: TenantWhereInput
    none?: TenantWhereInput
  }

  export type SubnetListRelationFilter = {
    every?: SubnetWhereInput
    some?: SubnetWhereInput
    none?: SubnetWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type UserGroupMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TenantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubnetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    status?: SortOrder
    tenantId?: SortOrder
    quotaConfig?: SortOrder
    lastLoginAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    status?: SortOrder
    tenantId?: SortOrder
    lastLoginAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    status?: SortOrder
    tenantId?: SortOrder
    lastLoginAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type EnumUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserStatusFilter<$PrismaModel>
    _max?: NestedEnumUserStatusFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type TenantScalarRelationFilter = {
    is?: TenantWhereInput
    isNot?: TenantWhereInput
  }

  export type UserGroupNullableScalarRelationFilter = {
    is?: UserGroupWhereInput | null
    isNot?: UserGroupWhereInput | null
  }

  export type UserGroupTenantIdNameCompoundUniqueInput = {
    tenantId: string
    name: string
  }

  export type UserGroupCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    tenantId?: SortOrder
    parentGroupId?: SortOrder
    quotaConfig?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserGroupMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    tenantId?: SortOrder
    parentGroupId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserGroupMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    tenantId?: SortOrder
    parentGroupId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserGroupScalarRelationFilter = {
    is?: UserGroupWhereInput
    isNot?: UserGroupWhereInput
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type UserGroupMemberGroupIdUserIdCompoundUniqueInput = {
    groupId: string
    userId: string
  }

  export type UserGroupMemberCountOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
    joinedAt?: SortOrder
    addedBy?: SortOrder
  }

  export type UserGroupMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
    joinedAt?: SortOrder
    addedBy?: SortOrder
  }

  export type UserGroupMemberMinOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
    joinedAt?: SortOrder
    addedBy?: SortOrder
  }

  export type EnumResourceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ResourceType | EnumResourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ResourceType[] | ListEnumResourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ResourceType[] | ListEnumResourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumResourceTypeFilter<$PrismaModel> | $Enums.ResourceType
  }

  export type EnumPermissionActionFilter<$PrismaModel = never> = {
    equals?: $Enums.PermissionAction | EnumPermissionActionFieldRefInput<$PrismaModel>
    in?: $Enums.PermissionAction[] | ListEnumPermissionActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.PermissionAction[] | ListEnumPermissionActionFieldRefInput<$PrismaModel>
    not?: NestedEnumPermissionActionFilter<$PrismaModel> | $Enums.PermissionAction
  }

  export type RolePermissionListRelationFilter = {
    every?: RolePermissionWhereInput
    some?: RolePermissionWhereInput
    none?: RolePermissionWhereInput
  }

  export type RolePermissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PermissionCountOrderByAggregateInput = {
    id?: SortOrder
    resourceType?: SortOrder
    action?: SortOrder
    permissionName?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type PermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    resourceType?: SortOrder
    action?: SortOrder
    permissionName?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type PermissionMinOrderByAggregateInput = {
    id?: SortOrder
    resourceType?: SortOrder
    action?: SortOrder
    permissionName?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumResourceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ResourceType | EnumResourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ResourceType[] | ListEnumResourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ResourceType[] | ListEnumResourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumResourceTypeWithAggregatesFilter<$PrismaModel> | $Enums.ResourceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumResourceTypeFilter<$PrismaModel>
    _max?: NestedEnumResourceTypeFilter<$PrismaModel>
  }

  export type EnumPermissionActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PermissionAction | EnumPermissionActionFieldRefInput<$PrismaModel>
    in?: $Enums.PermissionAction[] | ListEnumPermissionActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.PermissionAction[] | ListEnumPermissionActionFieldRefInput<$PrismaModel>
    not?: NestedEnumPermissionActionWithAggregatesFilter<$PrismaModel> | $Enums.PermissionAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPermissionActionFilter<$PrismaModel>
    _max?: NestedEnumPermissionActionFilter<$PrismaModel>
  }

  export type PermissionScalarRelationFilter = {
    is?: PermissionWhereInput
    isNot?: PermissionWhereInput
  }

  export type RolePermissionRolePermissionIdCompoundUniqueInput = {
    role: $Enums.UserRole
    permissionId: string
  }

  export type RolePermissionCountOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    permissionId?: SortOrder
  }

  export type RolePermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    permissionId?: SortOrder
  }

  export type RolePermissionMinOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    permissionId?: SortOrder
  }

  export type InstanceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InstanceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InstanceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type PrivateDataDiskCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    sizeGb?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PrivateDataDiskAvgOrderByAggregateInput = {
    sizeGb?: SortOrder
  }

  export type PrivateDataDiskMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    sizeGb?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PrivateDataDiskMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    sizeGb?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PrivateDataDiskSumOrderByAggregateInput = {
    sizeGb?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type EnumVpcStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VpcStatus | EnumVpcStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VpcStatus[] | ListEnumVpcStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VpcStatus[] | ListEnumVpcStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVpcStatusFilter<$PrismaModel> | $Enums.VpcStatus
  }

  export type VpcTenantIdNameCompoundUniqueInput = {
    tenantId: string
    name: string
  }

  export type VpcCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    cidrBlock?: SortOrder
    edgeDataCenterId?: SortOrder
    vlanId?: SortOrder
    enableDns?: SortOrder
    dnsServers?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type VpcAvgOrderByAggregateInput = {
    vlanId?: SortOrder
  }

  export type VpcMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    cidrBlock?: SortOrder
    edgeDataCenterId?: SortOrder
    vlanId?: SortOrder
    enableDns?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type VpcMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    cidrBlock?: SortOrder
    edgeDataCenterId?: SortOrder
    vlanId?: SortOrder
    enableDns?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type VpcSumOrderByAggregateInput = {
    vlanId?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumVpcStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VpcStatus | EnumVpcStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VpcStatus[] | ListEnumVpcStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VpcStatus[] | ListEnumVpcStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVpcStatusWithAggregatesFilter<$PrismaModel> | $Enums.VpcStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVpcStatusFilter<$PrismaModel>
    _max?: NestedEnumVpcStatusFilter<$PrismaModel>
  }

  export type EnumPlaceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PlaceStatus | EnumPlaceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PlaceStatus[] | ListEnumPlaceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlaceStatus[] | ListEnumPlaceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPlaceStatusFilter<$PrismaModel> | $Enums.PlaceStatus
  }

  export type SubnetNullableScalarRelationFilter = {
    is?: SubnetWhereInput | null
    isNot?: SubnetWhereInput | null
  }

  export type PlaceTenantIdNameCompoundUniqueInput = {
    tenantId: string
    name: string
  }

  export type PlaceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    tenantId?: SortOrder
    subnetId?: SortOrder
    location?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type PlaceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    tenantId?: SortOrder
    subnetId?: SortOrder
    location?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type PlaceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    tenantId?: SortOrder
    subnetId?: SortOrder
    location?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type EnumPlaceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PlaceStatus | EnumPlaceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PlaceStatus[] | ListEnumPlaceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlaceStatus[] | ListEnumPlaceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPlaceStatusWithAggregatesFilter<$PrismaModel> | $Enums.PlaceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPlaceStatusFilter<$PrismaModel>
    _max?: NestedEnumPlaceStatusFilter<$PrismaModel>
  }

  export type EnumSubnetStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubnetStatus | EnumSubnetStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubnetStatus[] | ListEnumSubnetStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubnetStatus[] | ListEnumSubnetStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubnetStatusFilter<$PrismaModel> | $Enums.SubnetStatus
  }

  export type VpcScalarRelationFilter = {
    is?: VpcWhereInput
    isNot?: VpcWhereInput
  }

  export type PlaceNullableScalarRelationFilter = {
    is?: PlaceWhereInput | null
    isNot?: PlaceWhereInput | null
  }

  export type SubnetVpcIdCidrBlockCompoundUniqueInput = {
    vpcId: string
    cidrBlock: string
  }

  export type SubnetCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    vpcId?: SortOrder
    cidrBlock?: SortOrder
    availabilityZone?: SortOrder
    gateway?: SortOrder
    vlanId?: SortOrder
    isPublic?: SortOrder
    autoAssignIp?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type SubnetAvgOrderByAggregateInput = {
    vlanId?: SortOrder
  }

  export type SubnetMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    vpcId?: SortOrder
    cidrBlock?: SortOrder
    availabilityZone?: SortOrder
    gateway?: SortOrder
    vlanId?: SortOrder
    isPublic?: SortOrder
    autoAssignIp?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type SubnetMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    vpcId?: SortOrder
    cidrBlock?: SortOrder
    availabilityZone?: SortOrder
    gateway?: SortOrder
    vlanId?: SortOrder
    isPublic?: SortOrder
    autoAssignIp?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type SubnetSumOrderByAggregateInput = {
    vlanId?: SortOrder
  }

  export type EnumSubnetStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubnetStatus | EnumSubnetStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubnetStatus[] | ListEnumSubnetStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubnetStatus[] | ListEnumSubnetStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubnetStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubnetStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubnetStatusFilter<$PrismaModel>
    _max?: NestedEnumSubnetStatusFilter<$PrismaModel>
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resourceType?: SortOrder
    resourceId?: SortOrder
    details?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resourceType?: SortOrder
    resourceId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resourceType?: SortOrder
    resourceId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type UserCreateNestedManyWithoutTenantInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserGroupCreateNestedManyWithoutTenantInput = {
    create?: XOR<UserGroupCreateWithoutTenantInput, UserGroupUncheckedCreateWithoutTenantInput> | UserGroupCreateWithoutTenantInput[] | UserGroupUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserGroupCreateOrConnectWithoutTenantInput | UserGroupCreateOrConnectWithoutTenantInput[]
    createMany?: UserGroupCreateManyTenantInputEnvelope
    connect?: UserGroupWhereUniqueInput | UserGroupWhereUniqueInput[]
  }

  export type InstanceCreateNestedManyWithoutTenantInput = {
    create?: XOR<InstanceCreateWithoutTenantInput, InstanceUncheckedCreateWithoutTenantInput> | InstanceCreateWithoutTenantInput[] | InstanceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InstanceCreateOrConnectWithoutTenantInput | InstanceCreateOrConnectWithoutTenantInput[]
    createMany?: InstanceCreateManyTenantInputEnvelope
    connect?: InstanceWhereUniqueInput | InstanceWhereUniqueInput[]
  }

  export type PrivateDataDiskCreateNestedManyWithoutTenantInput = {
    create?: XOR<PrivateDataDiskCreateWithoutTenantInput, PrivateDataDiskUncheckedCreateWithoutTenantInput> | PrivateDataDiskCreateWithoutTenantInput[] | PrivateDataDiskUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PrivateDataDiskCreateOrConnectWithoutTenantInput | PrivateDataDiskCreateOrConnectWithoutTenantInput[]
    createMany?: PrivateDataDiskCreateManyTenantInputEnvelope
    connect?: PrivateDataDiskWhereUniqueInput | PrivateDataDiskWhereUniqueInput[]
  }

  export type VpcCreateNestedManyWithoutTenantInput = {
    create?: XOR<VpcCreateWithoutTenantInput, VpcUncheckedCreateWithoutTenantInput> | VpcCreateWithoutTenantInput[] | VpcUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: VpcCreateOrConnectWithoutTenantInput | VpcCreateOrConnectWithoutTenantInput[]
    createMany?: VpcCreateManyTenantInputEnvelope
    connect?: VpcWhereUniqueInput | VpcWhereUniqueInput[]
  }

  export type PlaceCreateNestedManyWithoutTenantInput = {
    create?: XOR<PlaceCreateWithoutTenantInput, PlaceUncheckedCreateWithoutTenantInput> | PlaceCreateWithoutTenantInput[] | PlaceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PlaceCreateOrConnectWithoutTenantInput | PlaceCreateOrConnectWithoutTenantInput[]
    createMany?: PlaceCreateManyTenantInputEnvelope
    connect?: PlaceWhereUniqueInput | PlaceWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutCreatedTenantsInput = {
    create?: XOR<UserCreateWithoutCreatedTenantsInput, UserUncheckedCreateWithoutCreatedTenantsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedTenantsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserGroupUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<UserGroupCreateWithoutTenantInput, UserGroupUncheckedCreateWithoutTenantInput> | UserGroupCreateWithoutTenantInput[] | UserGroupUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserGroupCreateOrConnectWithoutTenantInput | UserGroupCreateOrConnectWithoutTenantInput[]
    createMany?: UserGroupCreateManyTenantInputEnvelope
    connect?: UserGroupWhereUniqueInput | UserGroupWhereUniqueInput[]
  }

  export type InstanceUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<InstanceCreateWithoutTenantInput, InstanceUncheckedCreateWithoutTenantInput> | InstanceCreateWithoutTenantInput[] | InstanceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InstanceCreateOrConnectWithoutTenantInput | InstanceCreateOrConnectWithoutTenantInput[]
    createMany?: InstanceCreateManyTenantInputEnvelope
    connect?: InstanceWhereUniqueInput | InstanceWhereUniqueInput[]
  }

  export type PrivateDataDiskUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<PrivateDataDiskCreateWithoutTenantInput, PrivateDataDiskUncheckedCreateWithoutTenantInput> | PrivateDataDiskCreateWithoutTenantInput[] | PrivateDataDiskUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PrivateDataDiskCreateOrConnectWithoutTenantInput | PrivateDataDiskCreateOrConnectWithoutTenantInput[]
    createMany?: PrivateDataDiskCreateManyTenantInputEnvelope
    connect?: PrivateDataDiskWhereUniqueInput | PrivateDataDiskWhereUniqueInput[]
  }

  export type VpcUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<VpcCreateWithoutTenantInput, VpcUncheckedCreateWithoutTenantInput> | VpcCreateWithoutTenantInput[] | VpcUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: VpcCreateOrConnectWithoutTenantInput | VpcCreateOrConnectWithoutTenantInput[]
    createMany?: VpcCreateManyTenantInputEnvelope
    connect?: VpcWhereUniqueInput | VpcWhereUniqueInput[]
  }

  export type PlaceUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<PlaceCreateWithoutTenantInput, PlaceUncheckedCreateWithoutTenantInput> | PlaceCreateWithoutTenantInput[] | PlaceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PlaceCreateOrConnectWithoutTenantInput | PlaceCreateOrConnectWithoutTenantInput[]
    createMany?: PlaceCreateManyTenantInputEnvelope
    connect?: PlaceWhereUniqueInput | PlaceWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumTenantStatusFieldUpdateOperationsInput = {
    set?: $Enums.TenantStatus
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateManyWithoutTenantNestedInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutTenantInput | UserUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutTenantInput | UserUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: UserUpdateManyWithWhereWithoutTenantInput | UserUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserGroupUpdateManyWithoutTenantNestedInput = {
    create?: XOR<UserGroupCreateWithoutTenantInput, UserGroupUncheckedCreateWithoutTenantInput> | UserGroupCreateWithoutTenantInput[] | UserGroupUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserGroupCreateOrConnectWithoutTenantInput | UserGroupCreateOrConnectWithoutTenantInput[]
    upsert?: UserGroupUpsertWithWhereUniqueWithoutTenantInput | UserGroupUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: UserGroupCreateManyTenantInputEnvelope
    set?: UserGroupWhereUniqueInput | UserGroupWhereUniqueInput[]
    disconnect?: UserGroupWhereUniqueInput | UserGroupWhereUniqueInput[]
    delete?: UserGroupWhereUniqueInput | UserGroupWhereUniqueInput[]
    connect?: UserGroupWhereUniqueInput | UserGroupWhereUniqueInput[]
    update?: UserGroupUpdateWithWhereUniqueWithoutTenantInput | UserGroupUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: UserGroupUpdateManyWithWhereWithoutTenantInput | UserGroupUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: UserGroupScalarWhereInput | UserGroupScalarWhereInput[]
  }

  export type InstanceUpdateManyWithoutTenantNestedInput = {
    create?: XOR<InstanceCreateWithoutTenantInput, InstanceUncheckedCreateWithoutTenantInput> | InstanceCreateWithoutTenantInput[] | InstanceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InstanceCreateOrConnectWithoutTenantInput | InstanceCreateOrConnectWithoutTenantInput[]
    upsert?: InstanceUpsertWithWhereUniqueWithoutTenantInput | InstanceUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: InstanceCreateManyTenantInputEnvelope
    set?: InstanceWhereUniqueInput | InstanceWhereUniqueInput[]
    disconnect?: InstanceWhereUniqueInput | InstanceWhereUniqueInput[]
    delete?: InstanceWhereUniqueInput | InstanceWhereUniqueInput[]
    connect?: InstanceWhereUniqueInput | InstanceWhereUniqueInput[]
    update?: InstanceUpdateWithWhereUniqueWithoutTenantInput | InstanceUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: InstanceUpdateManyWithWhereWithoutTenantInput | InstanceUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: InstanceScalarWhereInput | InstanceScalarWhereInput[]
  }

  export type PrivateDataDiskUpdateManyWithoutTenantNestedInput = {
    create?: XOR<PrivateDataDiskCreateWithoutTenantInput, PrivateDataDiskUncheckedCreateWithoutTenantInput> | PrivateDataDiskCreateWithoutTenantInput[] | PrivateDataDiskUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PrivateDataDiskCreateOrConnectWithoutTenantInput | PrivateDataDiskCreateOrConnectWithoutTenantInput[]
    upsert?: PrivateDataDiskUpsertWithWhereUniqueWithoutTenantInput | PrivateDataDiskUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: PrivateDataDiskCreateManyTenantInputEnvelope
    set?: PrivateDataDiskWhereUniqueInput | PrivateDataDiskWhereUniqueInput[]
    disconnect?: PrivateDataDiskWhereUniqueInput | PrivateDataDiskWhereUniqueInput[]
    delete?: PrivateDataDiskWhereUniqueInput | PrivateDataDiskWhereUniqueInput[]
    connect?: PrivateDataDiskWhereUniqueInput | PrivateDataDiskWhereUniqueInput[]
    update?: PrivateDataDiskUpdateWithWhereUniqueWithoutTenantInput | PrivateDataDiskUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: PrivateDataDiskUpdateManyWithWhereWithoutTenantInput | PrivateDataDiskUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: PrivateDataDiskScalarWhereInput | PrivateDataDiskScalarWhereInput[]
  }

  export type VpcUpdateManyWithoutTenantNestedInput = {
    create?: XOR<VpcCreateWithoutTenantInput, VpcUncheckedCreateWithoutTenantInput> | VpcCreateWithoutTenantInput[] | VpcUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: VpcCreateOrConnectWithoutTenantInput | VpcCreateOrConnectWithoutTenantInput[]
    upsert?: VpcUpsertWithWhereUniqueWithoutTenantInput | VpcUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: VpcCreateManyTenantInputEnvelope
    set?: VpcWhereUniqueInput | VpcWhereUniqueInput[]
    disconnect?: VpcWhereUniqueInput | VpcWhereUniqueInput[]
    delete?: VpcWhereUniqueInput | VpcWhereUniqueInput[]
    connect?: VpcWhereUniqueInput | VpcWhereUniqueInput[]
    update?: VpcUpdateWithWhereUniqueWithoutTenantInput | VpcUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: VpcUpdateManyWithWhereWithoutTenantInput | VpcUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: VpcScalarWhereInput | VpcScalarWhereInput[]
  }

  export type PlaceUpdateManyWithoutTenantNestedInput = {
    create?: XOR<PlaceCreateWithoutTenantInput, PlaceUncheckedCreateWithoutTenantInput> | PlaceCreateWithoutTenantInput[] | PlaceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PlaceCreateOrConnectWithoutTenantInput | PlaceCreateOrConnectWithoutTenantInput[]
    upsert?: PlaceUpsertWithWhereUniqueWithoutTenantInput | PlaceUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: PlaceCreateManyTenantInputEnvelope
    set?: PlaceWhereUniqueInput | PlaceWhereUniqueInput[]
    disconnect?: PlaceWhereUniqueInput | PlaceWhereUniqueInput[]
    delete?: PlaceWhereUniqueInput | PlaceWhereUniqueInput[]
    connect?: PlaceWhereUniqueInput | PlaceWhereUniqueInput[]
    update?: PlaceUpdateWithWhereUniqueWithoutTenantInput | PlaceUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: PlaceUpdateManyWithWhereWithoutTenantInput | PlaceUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: PlaceScalarWhereInput | PlaceScalarWhereInput[]
  }

  export type UserUpdateOneWithoutCreatedTenantsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedTenantsInput, UserUncheckedCreateWithoutCreatedTenantsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedTenantsInput
    upsert?: UserUpsertWithoutCreatedTenantsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedTenantsInput, UserUpdateWithoutCreatedTenantsInput>, UserUncheckedUpdateWithoutCreatedTenantsInput>
  }

  export type UserUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutTenantInput | UserUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutTenantInput | UserUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: UserUpdateManyWithWhereWithoutTenantInput | UserUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserGroupUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<UserGroupCreateWithoutTenantInput, UserGroupUncheckedCreateWithoutTenantInput> | UserGroupCreateWithoutTenantInput[] | UserGroupUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserGroupCreateOrConnectWithoutTenantInput | UserGroupCreateOrConnectWithoutTenantInput[]
    upsert?: UserGroupUpsertWithWhereUniqueWithoutTenantInput | UserGroupUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: UserGroupCreateManyTenantInputEnvelope
    set?: UserGroupWhereUniqueInput | UserGroupWhereUniqueInput[]
    disconnect?: UserGroupWhereUniqueInput | UserGroupWhereUniqueInput[]
    delete?: UserGroupWhereUniqueInput | UserGroupWhereUniqueInput[]
    connect?: UserGroupWhereUniqueInput | UserGroupWhereUniqueInput[]
    update?: UserGroupUpdateWithWhereUniqueWithoutTenantInput | UserGroupUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: UserGroupUpdateManyWithWhereWithoutTenantInput | UserGroupUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: UserGroupScalarWhereInput | UserGroupScalarWhereInput[]
  }

  export type InstanceUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<InstanceCreateWithoutTenantInput, InstanceUncheckedCreateWithoutTenantInput> | InstanceCreateWithoutTenantInput[] | InstanceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InstanceCreateOrConnectWithoutTenantInput | InstanceCreateOrConnectWithoutTenantInput[]
    upsert?: InstanceUpsertWithWhereUniqueWithoutTenantInput | InstanceUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: InstanceCreateManyTenantInputEnvelope
    set?: InstanceWhereUniqueInput | InstanceWhereUniqueInput[]
    disconnect?: InstanceWhereUniqueInput | InstanceWhereUniqueInput[]
    delete?: InstanceWhereUniqueInput | InstanceWhereUniqueInput[]
    connect?: InstanceWhereUniqueInput | InstanceWhereUniqueInput[]
    update?: InstanceUpdateWithWhereUniqueWithoutTenantInput | InstanceUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: InstanceUpdateManyWithWhereWithoutTenantInput | InstanceUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: InstanceScalarWhereInput | InstanceScalarWhereInput[]
  }

  export type PrivateDataDiskUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<PrivateDataDiskCreateWithoutTenantInput, PrivateDataDiskUncheckedCreateWithoutTenantInput> | PrivateDataDiskCreateWithoutTenantInput[] | PrivateDataDiskUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PrivateDataDiskCreateOrConnectWithoutTenantInput | PrivateDataDiskCreateOrConnectWithoutTenantInput[]
    upsert?: PrivateDataDiskUpsertWithWhereUniqueWithoutTenantInput | PrivateDataDiskUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: PrivateDataDiskCreateManyTenantInputEnvelope
    set?: PrivateDataDiskWhereUniqueInput | PrivateDataDiskWhereUniqueInput[]
    disconnect?: PrivateDataDiskWhereUniqueInput | PrivateDataDiskWhereUniqueInput[]
    delete?: PrivateDataDiskWhereUniqueInput | PrivateDataDiskWhereUniqueInput[]
    connect?: PrivateDataDiskWhereUniqueInput | PrivateDataDiskWhereUniqueInput[]
    update?: PrivateDataDiskUpdateWithWhereUniqueWithoutTenantInput | PrivateDataDiskUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: PrivateDataDiskUpdateManyWithWhereWithoutTenantInput | PrivateDataDiskUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: PrivateDataDiskScalarWhereInput | PrivateDataDiskScalarWhereInput[]
  }

  export type VpcUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<VpcCreateWithoutTenantInput, VpcUncheckedCreateWithoutTenantInput> | VpcCreateWithoutTenantInput[] | VpcUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: VpcCreateOrConnectWithoutTenantInput | VpcCreateOrConnectWithoutTenantInput[]
    upsert?: VpcUpsertWithWhereUniqueWithoutTenantInput | VpcUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: VpcCreateManyTenantInputEnvelope
    set?: VpcWhereUniqueInput | VpcWhereUniqueInput[]
    disconnect?: VpcWhereUniqueInput | VpcWhereUniqueInput[]
    delete?: VpcWhereUniqueInput | VpcWhereUniqueInput[]
    connect?: VpcWhereUniqueInput | VpcWhereUniqueInput[]
    update?: VpcUpdateWithWhereUniqueWithoutTenantInput | VpcUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: VpcUpdateManyWithWhereWithoutTenantInput | VpcUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: VpcScalarWhereInput | VpcScalarWhereInput[]
  }

  export type PlaceUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<PlaceCreateWithoutTenantInput, PlaceUncheckedCreateWithoutTenantInput> | PlaceCreateWithoutTenantInput[] | PlaceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PlaceCreateOrConnectWithoutTenantInput | PlaceCreateOrConnectWithoutTenantInput[]
    upsert?: PlaceUpsertWithWhereUniqueWithoutTenantInput | PlaceUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: PlaceCreateManyTenantInputEnvelope
    set?: PlaceWhereUniqueInput | PlaceWhereUniqueInput[]
    disconnect?: PlaceWhereUniqueInput | PlaceWhereUniqueInput[]
    delete?: PlaceWhereUniqueInput | PlaceWhereUniqueInput[]
    connect?: PlaceWhereUniqueInput | PlaceWhereUniqueInput[]
    update?: PlaceUpdateWithWhereUniqueWithoutTenantInput | PlaceUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: PlaceUpdateManyWithWhereWithoutTenantInput | PlaceUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: PlaceScalarWhereInput | PlaceScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutUsersInput = {
    create?: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutUsersInput
    connect?: TenantWhereUniqueInput
  }

  export type UserGroupMemberCreateNestedManyWithoutUserInput = {
    create?: XOR<UserGroupMemberCreateWithoutUserInput, UserGroupMemberUncheckedCreateWithoutUserInput> | UserGroupMemberCreateWithoutUserInput[] | UserGroupMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserGroupMemberCreateOrConnectWithoutUserInput | UserGroupMemberCreateOrConnectWithoutUserInput[]
    createMany?: UserGroupMemberCreateManyUserInputEnvelope
    connect?: UserGroupMemberWhereUniqueInput | UserGroupMemberWhereUniqueInput[]
  }

  export type InstanceCreateNestedManyWithoutUserInput = {
    create?: XOR<InstanceCreateWithoutUserInput, InstanceUncheckedCreateWithoutUserInput> | InstanceCreateWithoutUserInput[] | InstanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InstanceCreateOrConnectWithoutUserInput | InstanceCreateOrConnectWithoutUserInput[]
    createMany?: InstanceCreateManyUserInputEnvelope
    connect?: InstanceWhereUniqueInput | InstanceWhereUniqueInput[]
  }

  export type PrivateDataDiskCreateNestedManyWithoutUserInput = {
    create?: XOR<PrivateDataDiskCreateWithoutUserInput, PrivateDataDiskUncheckedCreateWithoutUserInput> | PrivateDataDiskCreateWithoutUserInput[] | PrivateDataDiskUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PrivateDataDiskCreateOrConnectWithoutUserInput | PrivateDataDiskCreateOrConnectWithoutUserInput[]
    createMany?: PrivateDataDiskCreateManyUserInputEnvelope
    connect?: PrivateDataDiskWhereUniqueInput | PrivateDataDiskWhereUniqueInput[]
  }

  export type TenantCreateNestedManyWithoutCreatorInput = {
    create?: XOR<TenantCreateWithoutCreatorInput, TenantUncheckedCreateWithoutCreatorInput> | TenantCreateWithoutCreatorInput[] | TenantUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TenantCreateOrConnectWithoutCreatorInput | TenantCreateOrConnectWithoutCreatorInput[]
    createMany?: TenantCreateManyCreatorInputEnvelope
    connect?: TenantWhereUniqueInput | TenantWhereUniqueInput[]
  }

  export type VpcCreateNestedManyWithoutUserInput = {
    create?: XOR<VpcCreateWithoutUserInput, VpcUncheckedCreateWithoutUserInput> | VpcCreateWithoutUserInput[] | VpcUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VpcCreateOrConnectWithoutUserInput | VpcCreateOrConnectWithoutUserInput[]
    createMany?: VpcCreateManyUserInputEnvelope
    connect?: VpcWhereUniqueInput | VpcWhereUniqueInput[]
  }

  export type VpcCreateNestedManyWithoutCreatorInput = {
    create?: XOR<VpcCreateWithoutCreatorInput, VpcUncheckedCreateWithoutCreatorInput> | VpcCreateWithoutCreatorInput[] | VpcUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: VpcCreateOrConnectWithoutCreatorInput | VpcCreateOrConnectWithoutCreatorInput[]
    createMany?: VpcCreateManyCreatorInputEnvelope
    connect?: VpcWhereUniqueInput | VpcWhereUniqueInput[]
  }

  export type VpcCreateNestedManyWithoutUpdaterInput = {
    create?: XOR<VpcCreateWithoutUpdaterInput, VpcUncheckedCreateWithoutUpdaterInput> | VpcCreateWithoutUpdaterInput[] | VpcUncheckedCreateWithoutUpdaterInput[]
    connectOrCreate?: VpcCreateOrConnectWithoutUpdaterInput | VpcCreateOrConnectWithoutUpdaterInput[]
    createMany?: VpcCreateManyUpdaterInputEnvelope
    connect?: VpcWhereUniqueInput | VpcWhereUniqueInput[]
  }

  export type PlaceCreateNestedManyWithoutCreatorInput = {
    create?: XOR<PlaceCreateWithoutCreatorInput, PlaceUncheckedCreateWithoutCreatorInput> | PlaceCreateWithoutCreatorInput[] | PlaceUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: PlaceCreateOrConnectWithoutCreatorInput | PlaceCreateOrConnectWithoutCreatorInput[]
    createMany?: PlaceCreateManyCreatorInputEnvelope
    connect?: PlaceWhereUniqueInput | PlaceWhereUniqueInput[]
  }

  export type PlaceCreateNestedManyWithoutUpdaterInput = {
    create?: XOR<PlaceCreateWithoutUpdaterInput, PlaceUncheckedCreateWithoutUpdaterInput> | PlaceCreateWithoutUpdaterInput[] | PlaceUncheckedCreateWithoutUpdaterInput[]
    connectOrCreate?: PlaceCreateOrConnectWithoutUpdaterInput | PlaceCreateOrConnectWithoutUpdaterInput[]
    createMany?: PlaceCreateManyUpdaterInputEnvelope
    connect?: PlaceWhereUniqueInput | PlaceWhereUniqueInput[]
  }

  export type SubnetCreateNestedManyWithoutCreatorInput = {
    create?: XOR<SubnetCreateWithoutCreatorInput, SubnetUncheckedCreateWithoutCreatorInput> | SubnetCreateWithoutCreatorInput[] | SubnetUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: SubnetCreateOrConnectWithoutCreatorInput | SubnetCreateOrConnectWithoutCreatorInput[]
    createMany?: SubnetCreateManyCreatorInputEnvelope
    connect?: SubnetWhereUniqueInput | SubnetWhereUniqueInput[]
  }

  export type SubnetCreateNestedManyWithoutUpdaterInput = {
    create?: XOR<SubnetCreateWithoutUpdaterInput, SubnetUncheckedCreateWithoutUpdaterInput> | SubnetCreateWithoutUpdaterInput[] | SubnetUncheckedCreateWithoutUpdaterInput[]
    connectOrCreate?: SubnetCreateOrConnectWithoutUpdaterInput | SubnetCreateOrConnectWithoutUpdaterInput[]
    createMany?: SubnetCreateManyUpdaterInputEnvelope
    connect?: SubnetWhereUniqueInput | SubnetWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type UserGroupMemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserGroupMemberCreateWithoutUserInput, UserGroupMemberUncheckedCreateWithoutUserInput> | UserGroupMemberCreateWithoutUserInput[] | UserGroupMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserGroupMemberCreateOrConnectWithoutUserInput | UserGroupMemberCreateOrConnectWithoutUserInput[]
    createMany?: UserGroupMemberCreateManyUserInputEnvelope
    connect?: UserGroupMemberWhereUniqueInput | UserGroupMemberWhereUniqueInput[]
  }

  export type InstanceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<InstanceCreateWithoutUserInput, InstanceUncheckedCreateWithoutUserInput> | InstanceCreateWithoutUserInput[] | InstanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InstanceCreateOrConnectWithoutUserInput | InstanceCreateOrConnectWithoutUserInput[]
    createMany?: InstanceCreateManyUserInputEnvelope
    connect?: InstanceWhereUniqueInput | InstanceWhereUniqueInput[]
  }

  export type PrivateDataDiskUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PrivateDataDiskCreateWithoutUserInput, PrivateDataDiskUncheckedCreateWithoutUserInput> | PrivateDataDiskCreateWithoutUserInput[] | PrivateDataDiskUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PrivateDataDiskCreateOrConnectWithoutUserInput | PrivateDataDiskCreateOrConnectWithoutUserInput[]
    createMany?: PrivateDataDiskCreateManyUserInputEnvelope
    connect?: PrivateDataDiskWhereUniqueInput | PrivateDataDiskWhereUniqueInput[]
  }

  export type TenantUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<TenantCreateWithoutCreatorInput, TenantUncheckedCreateWithoutCreatorInput> | TenantCreateWithoutCreatorInput[] | TenantUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TenantCreateOrConnectWithoutCreatorInput | TenantCreateOrConnectWithoutCreatorInput[]
    createMany?: TenantCreateManyCreatorInputEnvelope
    connect?: TenantWhereUniqueInput | TenantWhereUniqueInput[]
  }

  export type VpcUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<VpcCreateWithoutUserInput, VpcUncheckedCreateWithoutUserInput> | VpcCreateWithoutUserInput[] | VpcUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VpcCreateOrConnectWithoutUserInput | VpcCreateOrConnectWithoutUserInput[]
    createMany?: VpcCreateManyUserInputEnvelope
    connect?: VpcWhereUniqueInput | VpcWhereUniqueInput[]
  }

  export type VpcUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<VpcCreateWithoutCreatorInput, VpcUncheckedCreateWithoutCreatorInput> | VpcCreateWithoutCreatorInput[] | VpcUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: VpcCreateOrConnectWithoutCreatorInput | VpcCreateOrConnectWithoutCreatorInput[]
    createMany?: VpcCreateManyCreatorInputEnvelope
    connect?: VpcWhereUniqueInput | VpcWhereUniqueInput[]
  }

  export type VpcUncheckedCreateNestedManyWithoutUpdaterInput = {
    create?: XOR<VpcCreateWithoutUpdaterInput, VpcUncheckedCreateWithoutUpdaterInput> | VpcCreateWithoutUpdaterInput[] | VpcUncheckedCreateWithoutUpdaterInput[]
    connectOrCreate?: VpcCreateOrConnectWithoutUpdaterInput | VpcCreateOrConnectWithoutUpdaterInput[]
    createMany?: VpcCreateManyUpdaterInputEnvelope
    connect?: VpcWhereUniqueInput | VpcWhereUniqueInput[]
  }

  export type PlaceUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<PlaceCreateWithoutCreatorInput, PlaceUncheckedCreateWithoutCreatorInput> | PlaceCreateWithoutCreatorInput[] | PlaceUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: PlaceCreateOrConnectWithoutCreatorInput | PlaceCreateOrConnectWithoutCreatorInput[]
    createMany?: PlaceCreateManyCreatorInputEnvelope
    connect?: PlaceWhereUniqueInput | PlaceWhereUniqueInput[]
  }

  export type PlaceUncheckedCreateNestedManyWithoutUpdaterInput = {
    create?: XOR<PlaceCreateWithoutUpdaterInput, PlaceUncheckedCreateWithoutUpdaterInput> | PlaceCreateWithoutUpdaterInput[] | PlaceUncheckedCreateWithoutUpdaterInput[]
    connectOrCreate?: PlaceCreateOrConnectWithoutUpdaterInput | PlaceCreateOrConnectWithoutUpdaterInput[]
    createMany?: PlaceCreateManyUpdaterInputEnvelope
    connect?: PlaceWhereUniqueInput | PlaceWhereUniqueInput[]
  }

  export type SubnetUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<SubnetCreateWithoutCreatorInput, SubnetUncheckedCreateWithoutCreatorInput> | SubnetCreateWithoutCreatorInput[] | SubnetUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: SubnetCreateOrConnectWithoutCreatorInput | SubnetCreateOrConnectWithoutCreatorInput[]
    createMany?: SubnetCreateManyCreatorInputEnvelope
    connect?: SubnetWhereUniqueInput | SubnetWhereUniqueInput[]
  }

  export type SubnetUncheckedCreateNestedManyWithoutUpdaterInput = {
    create?: XOR<SubnetCreateWithoutUpdaterInput, SubnetUncheckedCreateWithoutUpdaterInput> | SubnetCreateWithoutUpdaterInput[] | SubnetUncheckedCreateWithoutUpdaterInput[]
    connectOrCreate?: SubnetCreateOrConnectWithoutUpdaterInput | SubnetCreateOrConnectWithoutUpdaterInput[]
    createMany?: SubnetCreateManyUpdaterInputEnvelope
    connect?: SubnetWhereUniqueInput | SubnetWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type EnumUserStatusFieldUpdateOperationsInput = {
    set?: $Enums.UserStatus
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type TenantUpdateOneWithoutUsersNestedInput = {
    create?: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutUsersInput
    upsert?: TenantUpsertWithoutUsersInput
    disconnect?: TenantWhereInput | boolean
    delete?: TenantWhereInput | boolean
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutUsersInput, TenantUpdateWithoutUsersInput>, TenantUncheckedUpdateWithoutUsersInput>
  }

  export type UserGroupMemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserGroupMemberCreateWithoutUserInput, UserGroupMemberUncheckedCreateWithoutUserInput> | UserGroupMemberCreateWithoutUserInput[] | UserGroupMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserGroupMemberCreateOrConnectWithoutUserInput | UserGroupMemberCreateOrConnectWithoutUserInput[]
    upsert?: UserGroupMemberUpsertWithWhereUniqueWithoutUserInput | UserGroupMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserGroupMemberCreateManyUserInputEnvelope
    set?: UserGroupMemberWhereUniqueInput | UserGroupMemberWhereUniqueInput[]
    disconnect?: UserGroupMemberWhereUniqueInput | UserGroupMemberWhereUniqueInput[]
    delete?: UserGroupMemberWhereUniqueInput | UserGroupMemberWhereUniqueInput[]
    connect?: UserGroupMemberWhereUniqueInput | UserGroupMemberWhereUniqueInput[]
    update?: UserGroupMemberUpdateWithWhereUniqueWithoutUserInput | UserGroupMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserGroupMemberUpdateManyWithWhereWithoutUserInput | UserGroupMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserGroupMemberScalarWhereInput | UserGroupMemberScalarWhereInput[]
  }

  export type InstanceUpdateManyWithoutUserNestedInput = {
    create?: XOR<InstanceCreateWithoutUserInput, InstanceUncheckedCreateWithoutUserInput> | InstanceCreateWithoutUserInput[] | InstanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InstanceCreateOrConnectWithoutUserInput | InstanceCreateOrConnectWithoutUserInput[]
    upsert?: InstanceUpsertWithWhereUniqueWithoutUserInput | InstanceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InstanceCreateManyUserInputEnvelope
    set?: InstanceWhereUniqueInput | InstanceWhereUniqueInput[]
    disconnect?: InstanceWhereUniqueInput | InstanceWhereUniqueInput[]
    delete?: InstanceWhereUniqueInput | InstanceWhereUniqueInput[]
    connect?: InstanceWhereUniqueInput | InstanceWhereUniqueInput[]
    update?: InstanceUpdateWithWhereUniqueWithoutUserInput | InstanceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InstanceUpdateManyWithWhereWithoutUserInput | InstanceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InstanceScalarWhereInput | InstanceScalarWhereInput[]
  }

  export type PrivateDataDiskUpdateManyWithoutUserNestedInput = {
    create?: XOR<PrivateDataDiskCreateWithoutUserInput, PrivateDataDiskUncheckedCreateWithoutUserInput> | PrivateDataDiskCreateWithoutUserInput[] | PrivateDataDiskUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PrivateDataDiskCreateOrConnectWithoutUserInput | PrivateDataDiskCreateOrConnectWithoutUserInput[]
    upsert?: PrivateDataDiskUpsertWithWhereUniqueWithoutUserInput | PrivateDataDiskUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PrivateDataDiskCreateManyUserInputEnvelope
    set?: PrivateDataDiskWhereUniqueInput | PrivateDataDiskWhereUniqueInput[]
    disconnect?: PrivateDataDiskWhereUniqueInput | PrivateDataDiskWhereUniqueInput[]
    delete?: PrivateDataDiskWhereUniqueInput | PrivateDataDiskWhereUniqueInput[]
    connect?: PrivateDataDiskWhereUniqueInput | PrivateDataDiskWhereUniqueInput[]
    update?: PrivateDataDiskUpdateWithWhereUniqueWithoutUserInput | PrivateDataDiskUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PrivateDataDiskUpdateManyWithWhereWithoutUserInput | PrivateDataDiskUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PrivateDataDiskScalarWhereInput | PrivateDataDiskScalarWhereInput[]
  }

  export type TenantUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<TenantCreateWithoutCreatorInput, TenantUncheckedCreateWithoutCreatorInput> | TenantCreateWithoutCreatorInput[] | TenantUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TenantCreateOrConnectWithoutCreatorInput | TenantCreateOrConnectWithoutCreatorInput[]
    upsert?: TenantUpsertWithWhereUniqueWithoutCreatorInput | TenantUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: TenantCreateManyCreatorInputEnvelope
    set?: TenantWhereUniqueInput | TenantWhereUniqueInput[]
    disconnect?: TenantWhereUniqueInput | TenantWhereUniqueInput[]
    delete?: TenantWhereUniqueInput | TenantWhereUniqueInput[]
    connect?: TenantWhereUniqueInput | TenantWhereUniqueInput[]
    update?: TenantUpdateWithWhereUniqueWithoutCreatorInput | TenantUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: TenantUpdateManyWithWhereWithoutCreatorInput | TenantUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: TenantScalarWhereInput | TenantScalarWhereInput[]
  }

  export type VpcUpdateManyWithoutUserNestedInput = {
    create?: XOR<VpcCreateWithoutUserInput, VpcUncheckedCreateWithoutUserInput> | VpcCreateWithoutUserInput[] | VpcUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VpcCreateOrConnectWithoutUserInput | VpcCreateOrConnectWithoutUserInput[]
    upsert?: VpcUpsertWithWhereUniqueWithoutUserInput | VpcUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: VpcCreateManyUserInputEnvelope
    set?: VpcWhereUniqueInput | VpcWhereUniqueInput[]
    disconnect?: VpcWhereUniqueInput | VpcWhereUniqueInput[]
    delete?: VpcWhereUniqueInput | VpcWhereUniqueInput[]
    connect?: VpcWhereUniqueInput | VpcWhereUniqueInput[]
    update?: VpcUpdateWithWhereUniqueWithoutUserInput | VpcUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: VpcUpdateManyWithWhereWithoutUserInput | VpcUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: VpcScalarWhereInput | VpcScalarWhereInput[]
  }

  export type VpcUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<VpcCreateWithoutCreatorInput, VpcUncheckedCreateWithoutCreatorInput> | VpcCreateWithoutCreatorInput[] | VpcUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: VpcCreateOrConnectWithoutCreatorInput | VpcCreateOrConnectWithoutCreatorInput[]
    upsert?: VpcUpsertWithWhereUniqueWithoutCreatorInput | VpcUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: VpcCreateManyCreatorInputEnvelope
    set?: VpcWhereUniqueInput | VpcWhereUniqueInput[]
    disconnect?: VpcWhereUniqueInput | VpcWhereUniqueInput[]
    delete?: VpcWhereUniqueInput | VpcWhereUniqueInput[]
    connect?: VpcWhereUniqueInput | VpcWhereUniqueInput[]
    update?: VpcUpdateWithWhereUniqueWithoutCreatorInput | VpcUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: VpcUpdateManyWithWhereWithoutCreatorInput | VpcUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: VpcScalarWhereInput | VpcScalarWhereInput[]
  }

  export type VpcUpdateManyWithoutUpdaterNestedInput = {
    create?: XOR<VpcCreateWithoutUpdaterInput, VpcUncheckedCreateWithoutUpdaterInput> | VpcCreateWithoutUpdaterInput[] | VpcUncheckedCreateWithoutUpdaterInput[]
    connectOrCreate?: VpcCreateOrConnectWithoutUpdaterInput | VpcCreateOrConnectWithoutUpdaterInput[]
    upsert?: VpcUpsertWithWhereUniqueWithoutUpdaterInput | VpcUpsertWithWhereUniqueWithoutUpdaterInput[]
    createMany?: VpcCreateManyUpdaterInputEnvelope
    set?: VpcWhereUniqueInput | VpcWhereUniqueInput[]
    disconnect?: VpcWhereUniqueInput | VpcWhereUniqueInput[]
    delete?: VpcWhereUniqueInput | VpcWhereUniqueInput[]
    connect?: VpcWhereUniqueInput | VpcWhereUniqueInput[]
    update?: VpcUpdateWithWhereUniqueWithoutUpdaterInput | VpcUpdateWithWhereUniqueWithoutUpdaterInput[]
    updateMany?: VpcUpdateManyWithWhereWithoutUpdaterInput | VpcUpdateManyWithWhereWithoutUpdaterInput[]
    deleteMany?: VpcScalarWhereInput | VpcScalarWhereInput[]
  }

  export type PlaceUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<PlaceCreateWithoutCreatorInput, PlaceUncheckedCreateWithoutCreatorInput> | PlaceCreateWithoutCreatorInput[] | PlaceUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: PlaceCreateOrConnectWithoutCreatorInput | PlaceCreateOrConnectWithoutCreatorInput[]
    upsert?: PlaceUpsertWithWhereUniqueWithoutCreatorInput | PlaceUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: PlaceCreateManyCreatorInputEnvelope
    set?: PlaceWhereUniqueInput | PlaceWhereUniqueInput[]
    disconnect?: PlaceWhereUniqueInput | PlaceWhereUniqueInput[]
    delete?: PlaceWhereUniqueInput | PlaceWhereUniqueInput[]
    connect?: PlaceWhereUniqueInput | PlaceWhereUniqueInput[]
    update?: PlaceUpdateWithWhereUniqueWithoutCreatorInput | PlaceUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: PlaceUpdateManyWithWhereWithoutCreatorInput | PlaceUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: PlaceScalarWhereInput | PlaceScalarWhereInput[]
  }

  export type PlaceUpdateManyWithoutUpdaterNestedInput = {
    create?: XOR<PlaceCreateWithoutUpdaterInput, PlaceUncheckedCreateWithoutUpdaterInput> | PlaceCreateWithoutUpdaterInput[] | PlaceUncheckedCreateWithoutUpdaterInput[]
    connectOrCreate?: PlaceCreateOrConnectWithoutUpdaterInput | PlaceCreateOrConnectWithoutUpdaterInput[]
    upsert?: PlaceUpsertWithWhereUniqueWithoutUpdaterInput | PlaceUpsertWithWhereUniqueWithoutUpdaterInput[]
    createMany?: PlaceCreateManyUpdaterInputEnvelope
    set?: PlaceWhereUniqueInput | PlaceWhereUniqueInput[]
    disconnect?: PlaceWhereUniqueInput | PlaceWhereUniqueInput[]
    delete?: PlaceWhereUniqueInput | PlaceWhereUniqueInput[]
    connect?: PlaceWhereUniqueInput | PlaceWhereUniqueInput[]
    update?: PlaceUpdateWithWhereUniqueWithoutUpdaterInput | PlaceUpdateWithWhereUniqueWithoutUpdaterInput[]
    updateMany?: PlaceUpdateManyWithWhereWithoutUpdaterInput | PlaceUpdateManyWithWhereWithoutUpdaterInput[]
    deleteMany?: PlaceScalarWhereInput | PlaceScalarWhereInput[]
  }

  export type SubnetUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<SubnetCreateWithoutCreatorInput, SubnetUncheckedCreateWithoutCreatorInput> | SubnetCreateWithoutCreatorInput[] | SubnetUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: SubnetCreateOrConnectWithoutCreatorInput | SubnetCreateOrConnectWithoutCreatorInput[]
    upsert?: SubnetUpsertWithWhereUniqueWithoutCreatorInput | SubnetUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: SubnetCreateManyCreatorInputEnvelope
    set?: SubnetWhereUniqueInput | SubnetWhereUniqueInput[]
    disconnect?: SubnetWhereUniqueInput | SubnetWhereUniqueInput[]
    delete?: SubnetWhereUniqueInput | SubnetWhereUniqueInput[]
    connect?: SubnetWhereUniqueInput | SubnetWhereUniqueInput[]
    update?: SubnetUpdateWithWhereUniqueWithoutCreatorInput | SubnetUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: SubnetUpdateManyWithWhereWithoutCreatorInput | SubnetUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: SubnetScalarWhereInput | SubnetScalarWhereInput[]
  }

  export type SubnetUpdateManyWithoutUpdaterNestedInput = {
    create?: XOR<SubnetCreateWithoutUpdaterInput, SubnetUncheckedCreateWithoutUpdaterInput> | SubnetCreateWithoutUpdaterInput[] | SubnetUncheckedCreateWithoutUpdaterInput[]
    connectOrCreate?: SubnetCreateOrConnectWithoutUpdaterInput | SubnetCreateOrConnectWithoutUpdaterInput[]
    upsert?: SubnetUpsertWithWhereUniqueWithoutUpdaterInput | SubnetUpsertWithWhereUniqueWithoutUpdaterInput[]
    createMany?: SubnetCreateManyUpdaterInputEnvelope
    set?: SubnetWhereUniqueInput | SubnetWhereUniqueInput[]
    disconnect?: SubnetWhereUniqueInput | SubnetWhereUniqueInput[]
    delete?: SubnetWhereUniqueInput | SubnetWhereUniqueInput[]
    connect?: SubnetWhereUniqueInput | SubnetWhereUniqueInput[]
    update?: SubnetUpdateWithWhereUniqueWithoutUpdaterInput | SubnetUpdateWithWhereUniqueWithoutUpdaterInput[]
    updateMany?: SubnetUpdateManyWithWhereWithoutUpdaterInput | SubnetUpdateManyWithWhereWithoutUpdaterInput[]
    deleteMany?: SubnetScalarWhereInput | SubnetScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type UserGroupMemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserGroupMemberCreateWithoutUserInput, UserGroupMemberUncheckedCreateWithoutUserInput> | UserGroupMemberCreateWithoutUserInput[] | UserGroupMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserGroupMemberCreateOrConnectWithoutUserInput | UserGroupMemberCreateOrConnectWithoutUserInput[]
    upsert?: UserGroupMemberUpsertWithWhereUniqueWithoutUserInput | UserGroupMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserGroupMemberCreateManyUserInputEnvelope
    set?: UserGroupMemberWhereUniqueInput | UserGroupMemberWhereUniqueInput[]
    disconnect?: UserGroupMemberWhereUniqueInput | UserGroupMemberWhereUniqueInput[]
    delete?: UserGroupMemberWhereUniqueInput | UserGroupMemberWhereUniqueInput[]
    connect?: UserGroupMemberWhereUniqueInput | UserGroupMemberWhereUniqueInput[]
    update?: UserGroupMemberUpdateWithWhereUniqueWithoutUserInput | UserGroupMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserGroupMemberUpdateManyWithWhereWithoutUserInput | UserGroupMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserGroupMemberScalarWhereInput | UserGroupMemberScalarWhereInput[]
  }

  export type InstanceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<InstanceCreateWithoutUserInput, InstanceUncheckedCreateWithoutUserInput> | InstanceCreateWithoutUserInput[] | InstanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InstanceCreateOrConnectWithoutUserInput | InstanceCreateOrConnectWithoutUserInput[]
    upsert?: InstanceUpsertWithWhereUniqueWithoutUserInput | InstanceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InstanceCreateManyUserInputEnvelope
    set?: InstanceWhereUniqueInput | InstanceWhereUniqueInput[]
    disconnect?: InstanceWhereUniqueInput | InstanceWhereUniqueInput[]
    delete?: InstanceWhereUniqueInput | InstanceWhereUniqueInput[]
    connect?: InstanceWhereUniqueInput | InstanceWhereUniqueInput[]
    update?: InstanceUpdateWithWhereUniqueWithoutUserInput | InstanceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InstanceUpdateManyWithWhereWithoutUserInput | InstanceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InstanceScalarWhereInput | InstanceScalarWhereInput[]
  }

  export type PrivateDataDiskUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PrivateDataDiskCreateWithoutUserInput, PrivateDataDiskUncheckedCreateWithoutUserInput> | PrivateDataDiskCreateWithoutUserInput[] | PrivateDataDiskUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PrivateDataDiskCreateOrConnectWithoutUserInput | PrivateDataDiskCreateOrConnectWithoutUserInput[]
    upsert?: PrivateDataDiskUpsertWithWhereUniqueWithoutUserInput | PrivateDataDiskUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PrivateDataDiskCreateManyUserInputEnvelope
    set?: PrivateDataDiskWhereUniqueInput | PrivateDataDiskWhereUniqueInput[]
    disconnect?: PrivateDataDiskWhereUniqueInput | PrivateDataDiskWhereUniqueInput[]
    delete?: PrivateDataDiskWhereUniqueInput | PrivateDataDiskWhereUniqueInput[]
    connect?: PrivateDataDiskWhereUniqueInput | PrivateDataDiskWhereUniqueInput[]
    update?: PrivateDataDiskUpdateWithWhereUniqueWithoutUserInput | PrivateDataDiskUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PrivateDataDiskUpdateManyWithWhereWithoutUserInput | PrivateDataDiskUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PrivateDataDiskScalarWhereInput | PrivateDataDiskScalarWhereInput[]
  }

  export type TenantUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<TenantCreateWithoutCreatorInput, TenantUncheckedCreateWithoutCreatorInput> | TenantCreateWithoutCreatorInput[] | TenantUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TenantCreateOrConnectWithoutCreatorInput | TenantCreateOrConnectWithoutCreatorInput[]
    upsert?: TenantUpsertWithWhereUniqueWithoutCreatorInput | TenantUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: TenantCreateManyCreatorInputEnvelope
    set?: TenantWhereUniqueInput | TenantWhereUniqueInput[]
    disconnect?: TenantWhereUniqueInput | TenantWhereUniqueInput[]
    delete?: TenantWhereUniqueInput | TenantWhereUniqueInput[]
    connect?: TenantWhereUniqueInput | TenantWhereUniqueInput[]
    update?: TenantUpdateWithWhereUniqueWithoutCreatorInput | TenantUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: TenantUpdateManyWithWhereWithoutCreatorInput | TenantUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: TenantScalarWhereInput | TenantScalarWhereInput[]
  }

  export type VpcUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<VpcCreateWithoutUserInput, VpcUncheckedCreateWithoutUserInput> | VpcCreateWithoutUserInput[] | VpcUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VpcCreateOrConnectWithoutUserInput | VpcCreateOrConnectWithoutUserInput[]
    upsert?: VpcUpsertWithWhereUniqueWithoutUserInput | VpcUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: VpcCreateManyUserInputEnvelope
    set?: VpcWhereUniqueInput | VpcWhereUniqueInput[]
    disconnect?: VpcWhereUniqueInput | VpcWhereUniqueInput[]
    delete?: VpcWhereUniqueInput | VpcWhereUniqueInput[]
    connect?: VpcWhereUniqueInput | VpcWhereUniqueInput[]
    update?: VpcUpdateWithWhereUniqueWithoutUserInput | VpcUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: VpcUpdateManyWithWhereWithoutUserInput | VpcUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: VpcScalarWhereInput | VpcScalarWhereInput[]
  }

  export type VpcUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<VpcCreateWithoutCreatorInput, VpcUncheckedCreateWithoutCreatorInput> | VpcCreateWithoutCreatorInput[] | VpcUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: VpcCreateOrConnectWithoutCreatorInput | VpcCreateOrConnectWithoutCreatorInput[]
    upsert?: VpcUpsertWithWhereUniqueWithoutCreatorInput | VpcUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: VpcCreateManyCreatorInputEnvelope
    set?: VpcWhereUniqueInput | VpcWhereUniqueInput[]
    disconnect?: VpcWhereUniqueInput | VpcWhereUniqueInput[]
    delete?: VpcWhereUniqueInput | VpcWhereUniqueInput[]
    connect?: VpcWhereUniqueInput | VpcWhereUniqueInput[]
    update?: VpcUpdateWithWhereUniqueWithoutCreatorInput | VpcUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: VpcUpdateManyWithWhereWithoutCreatorInput | VpcUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: VpcScalarWhereInput | VpcScalarWhereInput[]
  }

  export type VpcUncheckedUpdateManyWithoutUpdaterNestedInput = {
    create?: XOR<VpcCreateWithoutUpdaterInput, VpcUncheckedCreateWithoutUpdaterInput> | VpcCreateWithoutUpdaterInput[] | VpcUncheckedCreateWithoutUpdaterInput[]
    connectOrCreate?: VpcCreateOrConnectWithoutUpdaterInput | VpcCreateOrConnectWithoutUpdaterInput[]
    upsert?: VpcUpsertWithWhereUniqueWithoutUpdaterInput | VpcUpsertWithWhereUniqueWithoutUpdaterInput[]
    createMany?: VpcCreateManyUpdaterInputEnvelope
    set?: VpcWhereUniqueInput | VpcWhereUniqueInput[]
    disconnect?: VpcWhereUniqueInput | VpcWhereUniqueInput[]
    delete?: VpcWhereUniqueInput | VpcWhereUniqueInput[]
    connect?: VpcWhereUniqueInput | VpcWhereUniqueInput[]
    update?: VpcUpdateWithWhereUniqueWithoutUpdaterInput | VpcUpdateWithWhereUniqueWithoutUpdaterInput[]
    updateMany?: VpcUpdateManyWithWhereWithoutUpdaterInput | VpcUpdateManyWithWhereWithoutUpdaterInput[]
    deleteMany?: VpcScalarWhereInput | VpcScalarWhereInput[]
  }

  export type PlaceUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<PlaceCreateWithoutCreatorInput, PlaceUncheckedCreateWithoutCreatorInput> | PlaceCreateWithoutCreatorInput[] | PlaceUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: PlaceCreateOrConnectWithoutCreatorInput | PlaceCreateOrConnectWithoutCreatorInput[]
    upsert?: PlaceUpsertWithWhereUniqueWithoutCreatorInput | PlaceUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: PlaceCreateManyCreatorInputEnvelope
    set?: PlaceWhereUniqueInput | PlaceWhereUniqueInput[]
    disconnect?: PlaceWhereUniqueInput | PlaceWhereUniqueInput[]
    delete?: PlaceWhereUniqueInput | PlaceWhereUniqueInput[]
    connect?: PlaceWhereUniqueInput | PlaceWhereUniqueInput[]
    update?: PlaceUpdateWithWhereUniqueWithoutCreatorInput | PlaceUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: PlaceUpdateManyWithWhereWithoutCreatorInput | PlaceUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: PlaceScalarWhereInput | PlaceScalarWhereInput[]
  }

  export type PlaceUncheckedUpdateManyWithoutUpdaterNestedInput = {
    create?: XOR<PlaceCreateWithoutUpdaterInput, PlaceUncheckedCreateWithoutUpdaterInput> | PlaceCreateWithoutUpdaterInput[] | PlaceUncheckedCreateWithoutUpdaterInput[]
    connectOrCreate?: PlaceCreateOrConnectWithoutUpdaterInput | PlaceCreateOrConnectWithoutUpdaterInput[]
    upsert?: PlaceUpsertWithWhereUniqueWithoutUpdaterInput | PlaceUpsertWithWhereUniqueWithoutUpdaterInput[]
    createMany?: PlaceCreateManyUpdaterInputEnvelope
    set?: PlaceWhereUniqueInput | PlaceWhereUniqueInput[]
    disconnect?: PlaceWhereUniqueInput | PlaceWhereUniqueInput[]
    delete?: PlaceWhereUniqueInput | PlaceWhereUniqueInput[]
    connect?: PlaceWhereUniqueInput | PlaceWhereUniqueInput[]
    update?: PlaceUpdateWithWhereUniqueWithoutUpdaterInput | PlaceUpdateWithWhereUniqueWithoutUpdaterInput[]
    updateMany?: PlaceUpdateManyWithWhereWithoutUpdaterInput | PlaceUpdateManyWithWhereWithoutUpdaterInput[]
    deleteMany?: PlaceScalarWhereInput | PlaceScalarWhereInput[]
  }

  export type SubnetUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<SubnetCreateWithoutCreatorInput, SubnetUncheckedCreateWithoutCreatorInput> | SubnetCreateWithoutCreatorInput[] | SubnetUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: SubnetCreateOrConnectWithoutCreatorInput | SubnetCreateOrConnectWithoutCreatorInput[]
    upsert?: SubnetUpsertWithWhereUniqueWithoutCreatorInput | SubnetUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: SubnetCreateManyCreatorInputEnvelope
    set?: SubnetWhereUniqueInput | SubnetWhereUniqueInput[]
    disconnect?: SubnetWhereUniqueInput | SubnetWhereUniqueInput[]
    delete?: SubnetWhereUniqueInput | SubnetWhereUniqueInput[]
    connect?: SubnetWhereUniqueInput | SubnetWhereUniqueInput[]
    update?: SubnetUpdateWithWhereUniqueWithoutCreatorInput | SubnetUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: SubnetUpdateManyWithWhereWithoutCreatorInput | SubnetUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: SubnetScalarWhereInput | SubnetScalarWhereInput[]
  }

  export type SubnetUncheckedUpdateManyWithoutUpdaterNestedInput = {
    create?: XOR<SubnetCreateWithoutUpdaterInput, SubnetUncheckedCreateWithoutUpdaterInput> | SubnetCreateWithoutUpdaterInput[] | SubnetUncheckedCreateWithoutUpdaterInput[]
    connectOrCreate?: SubnetCreateOrConnectWithoutUpdaterInput | SubnetCreateOrConnectWithoutUpdaterInput[]
    upsert?: SubnetUpsertWithWhereUniqueWithoutUpdaterInput | SubnetUpsertWithWhereUniqueWithoutUpdaterInput[]
    createMany?: SubnetCreateManyUpdaterInputEnvelope
    set?: SubnetWhereUniqueInput | SubnetWhereUniqueInput[]
    disconnect?: SubnetWhereUniqueInput | SubnetWhereUniqueInput[]
    delete?: SubnetWhereUniqueInput | SubnetWhereUniqueInput[]
    connect?: SubnetWhereUniqueInput | SubnetWhereUniqueInput[]
    update?: SubnetUpdateWithWhereUniqueWithoutUpdaterInput | SubnetUpdateWithWhereUniqueWithoutUpdaterInput[]
    updateMany?: SubnetUpdateManyWithWhereWithoutUpdaterInput | SubnetUpdateManyWithWhereWithoutUpdaterInput[]
    deleteMany?: SubnetScalarWhereInput | SubnetScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutUserGroupsInput = {
    create?: XOR<TenantCreateWithoutUserGroupsInput, TenantUncheckedCreateWithoutUserGroupsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutUserGroupsInput
    connect?: TenantWhereUniqueInput
  }

  export type UserGroupCreateNestedOneWithoutChildGroupsInput = {
    create?: XOR<UserGroupCreateWithoutChildGroupsInput, UserGroupUncheckedCreateWithoutChildGroupsInput>
    connectOrCreate?: UserGroupCreateOrConnectWithoutChildGroupsInput
    connect?: UserGroupWhereUniqueInput
  }

  export type UserGroupCreateNestedManyWithoutParentGroupInput = {
    create?: XOR<UserGroupCreateWithoutParentGroupInput, UserGroupUncheckedCreateWithoutParentGroupInput> | UserGroupCreateWithoutParentGroupInput[] | UserGroupUncheckedCreateWithoutParentGroupInput[]
    connectOrCreate?: UserGroupCreateOrConnectWithoutParentGroupInput | UserGroupCreateOrConnectWithoutParentGroupInput[]
    createMany?: UserGroupCreateManyParentGroupInputEnvelope
    connect?: UserGroupWhereUniqueInput | UserGroupWhereUniqueInput[]
  }

  export type UserGroupMemberCreateNestedManyWithoutGroupInput = {
    create?: XOR<UserGroupMemberCreateWithoutGroupInput, UserGroupMemberUncheckedCreateWithoutGroupInput> | UserGroupMemberCreateWithoutGroupInput[] | UserGroupMemberUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: UserGroupMemberCreateOrConnectWithoutGroupInput | UserGroupMemberCreateOrConnectWithoutGroupInput[]
    createMany?: UserGroupMemberCreateManyGroupInputEnvelope
    connect?: UserGroupMemberWhereUniqueInput | UserGroupMemberWhereUniqueInput[]
  }

  export type UserGroupUncheckedCreateNestedManyWithoutParentGroupInput = {
    create?: XOR<UserGroupCreateWithoutParentGroupInput, UserGroupUncheckedCreateWithoutParentGroupInput> | UserGroupCreateWithoutParentGroupInput[] | UserGroupUncheckedCreateWithoutParentGroupInput[]
    connectOrCreate?: UserGroupCreateOrConnectWithoutParentGroupInput | UserGroupCreateOrConnectWithoutParentGroupInput[]
    createMany?: UserGroupCreateManyParentGroupInputEnvelope
    connect?: UserGroupWhereUniqueInput | UserGroupWhereUniqueInput[]
  }

  export type UserGroupMemberUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<UserGroupMemberCreateWithoutGroupInput, UserGroupMemberUncheckedCreateWithoutGroupInput> | UserGroupMemberCreateWithoutGroupInput[] | UserGroupMemberUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: UserGroupMemberCreateOrConnectWithoutGroupInput | UserGroupMemberCreateOrConnectWithoutGroupInput[]
    createMany?: UserGroupMemberCreateManyGroupInputEnvelope
    connect?: UserGroupMemberWhereUniqueInput | UserGroupMemberWhereUniqueInput[]
  }

  export type TenantUpdateOneRequiredWithoutUserGroupsNestedInput = {
    create?: XOR<TenantCreateWithoutUserGroupsInput, TenantUncheckedCreateWithoutUserGroupsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutUserGroupsInput
    upsert?: TenantUpsertWithoutUserGroupsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutUserGroupsInput, TenantUpdateWithoutUserGroupsInput>, TenantUncheckedUpdateWithoutUserGroupsInput>
  }

  export type UserGroupUpdateOneWithoutChildGroupsNestedInput = {
    create?: XOR<UserGroupCreateWithoutChildGroupsInput, UserGroupUncheckedCreateWithoutChildGroupsInput>
    connectOrCreate?: UserGroupCreateOrConnectWithoutChildGroupsInput
    upsert?: UserGroupUpsertWithoutChildGroupsInput
    disconnect?: UserGroupWhereInput | boolean
    delete?: UserGroupWhereInput | boolean
    connect?: UserGroupWhereUniqueInput
    update?: XOR<XOR<UserGroupUpdateToOneWithWhereWithoutChildGroupsInput, UserGroupUpdateWithoutChildGroupsInput>, UserGroupUncheckedUpdateWithoutChildGroupsInput>
  }

  export type UserGroupUpdateManyWithoutParentGroupNestedInput = {
    create?: XOR<UserGroupCreateWithoutParentGroupInput, UserGroupUncheckedCreateWithoutParentGroupInput> | UserGroupCreateWithoutParentGroupInput[] | UserGroupUncheckedCreateWithoutParentGroupInput[]
    connectOrCreate?: UserGroupCreateOrConnectWithoutParentGroupInput | UserGroupCreateOrConnectWithoutParentGroupInput[]
    upsert?: UserGroupUpsertWithWhereUniqueWithoutParentGroupInput | UserGroupUpsertWithWhereUniqueWithoutParentGroupInput[]
    createMany?: UserGroupCreateManyParentGroupInputEnvelope
    set?: UserGroupWhereUniqueInput | UserGroupWhereUniqueInput[]
    disconnect?: UserGroupWhereUniqueInput | UserGroupWhereUniqueInput[]
    delete?: UserGroupWhereUniqueInput | UserGroupWhereUniqueInput[]
    connect?: UserGroupWhereUniqueInput | UserGroupWhereUniqueInput[]
    update?: UserGroupUpdateWithWhereUniqueWithoutParentGroupInput | UserGroupUpdateWithWhereUniqueWithoutParentGroupInput[]
    updateMany?: UserGroupUpdateManyWithWhereWithoutParentGroupInput | UserGroupUpdateManyWithWhereWithoutParentGroupInput[]
    deleteMany?: UserGroupScalarWhereInput | UserGroupScalarWhereInput[]
  }

  export type UserGroupMemberUpdateManyWithoutGroupNestedInput = {
    create?: XOR<UserGroupMemberCreateWithoutGroupInput, UserGroupMemberUncheckedCreateWithoutGroupInput> | UserGroupMemberCreateWithoutGroupInput[] | UserGroupMemberUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: UserGroupMemberCreateOrConnectWithoutGroupInput | UserGroupMemberCreateOrConnectWithoutGroupInput[]
    upsert?: UserGroupMemberUpsertWithWhereUniqueWithoutGroupInput | UserGroupMemberUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: UserGroupMemberCreateManyGroupInputEnvelope
    set?: UserGroupMemberWhereUniqueInput | UserGroupMemberWhereUniqueInput[]
    disconnect?: UserGroupMemberWhereUniqueInput | UserGroupMemberWhereUniqueInput[]
    delete?: UserGroupMemberWhereUniqueInput | UserGroupMemberWhereUniqueInput[]
    connect?: UserGroupMemberWhereUniqueInput | UserGroupMemberWhereUniqueInput[]
    update?: UserGroupMemberUpdateWithWhereUniqueWithoutGroupInput | UserGroupMemberUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: UserGroupMemberUpdateManyWithWhereWithoutGroupInput | UserGroupMemberUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: UserGroupMemberScalarWhereInput | UserGroupMemberScalarWhereInput[]
  }

  export type UserGroupUncheckedUpdateManyWithoutParentGroupNestedInput = {
    create?: XOR<UserGroupCreateWithoutParentGroupInput, UserGroupUncheckedCreateWithoutParentGroupInput> | UserGroupCreateWithoutParentGroupInput[] | UserGroupUncheckedCreateWithoutParentGroupInput[]
    connectOrCreate?: UserGroupCreateOrConnectWithoutParentGroupInput | UserGroupCreateOrConnectWithoutParentGroupInput[]
    upsert?: UserGroupUpsertWithWhereUniqueWithoutParentGroupInput | UserGroupUpsertWithWhereUniqueWithoutParentGroupInput[]
    createMany?: UserGroupCreateManyParentGroupInputEnvelope
    set?: UserGroupWhereUniqueInput | UserGroupWhereUniqueInput[]
    disconnect?: UserGroupWhereUniqueInput | UserGroupWhereUniqueInput[]
    delete?: UserGroupWhereUniqueInput | UserGroupWhereUniqueInput[]
    connect?: UserGroupWhereUniqueInput | UserGroupWhereUniqueInput[]
    update?: UserGroupUpdateWithWhereUniqueWithoutParentGroupInput | UserGroupUpdateWithWhereUniqueWithoutParentGroupInput[]
    updateMany?: UserGroupUpdateManyWithWhereWithoutParentGroupInput | UserGroupUpdateManyWithWhereWithoutParentGroupInput[]
    deleteMany?: UserGroupScalarWhereInput | UserGroupScalarWhereInput[]
  }

  export type UserGroupMemberUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<UserGroupMemberCreateWithoutGroupInput, UserGroupMemberUncheckedCreateWithoutGroupInput> | UserGroupMemberCreateWithoutGroupInput[] | UserGroupMemberUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: UserGroupMemberCreateOrConnectWithoutGroupInput | UserGroupMemberCreateOrConnectWithoutGroupInput[]
    upsert?: UserGroupMemberUpsertWithWhereUniqueWithoutGroupInput | UserGroupMemberUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: UserGroupMemberCreateManyGroupInputEnvelope
    set?: UserGroupMemberWhereUniqueInput | UserGroupMemberWhereUniqueInput[]
    disconnect?: UserGroupMemberWhereUniqueInput | UserGroupMemberWhereUniqueInput[]
    delete?: UserGroupMemberWhereUniqueInput | UserGroupMemberWhereUniqueInput[]
    connect?: UserGroupMemberWhereUniqueInput | UserGroupMemberWhereUniqueInput[]
    update?: UserGroupMemberUpdateWithWhereUniqueWithoutGroupInput | UserGroupMemberUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: UserGroupMemberUpdateManyWithWhereWithoutGroupInput | UserGroupMemberUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: UserGroupMemberScalarWhereInput | UserGroupMemberScalarWhereInput[]
  }

  export type UserGroupCreateNestedOneWithoutMembersInput = {
    create?: XOR<UserGroupCreateWithoutMembersInput, UserGroupUncheckedCreateWithoutMembersInput>
    connectOrCreate?: UserGroupCreateOrConnectWithoutMembersInput
    connect?: UserGroupWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutGroupMembershipsInput = {
    create?: XOR<UserCreateWithoutGroupMembershipsInput, UserUncheckedCreateWithoutGroupMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGroupMembershipsInput
    connect?: UserWhereUniqueInput
  }

  export type UserGroupUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<UserGroupCreateWithoutMembersInput, UserGroupUncheckedCreateWithoutMembersInput>
    connectOrCreate?: UserGroupCreateOrConnectWithoutMembersInput
    upsert?: UserGroupUpsertWithoutMembersInput
    connect?: UserGroupWhereUniqueInput
    update?: XOR<XOR<UserGroupUpdateToOneWithWhereWithoutMembersInput, UserGroupUpdateWithoutMembersInput>, UserGroupUncheckedUpdateWithoutMembersInput>
  }

  export type UserUpdateOneRequiredWithoutGroupMembershipsNestedInput = {
    create?: XOR<UserCreateWithoutGroupMembershipsInput, UserUncheckedCreateWithoutGroupMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGroupMembershipsInput
    upsert?: UserUpsertWithoutGroupMembershipsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutGroupMembershipsInput, UserUpdateWithoutGroupMembershipsInput>, UserUncheckedUpdateWithoutGroupMembershipsInput>
  }

  export type RolePermissionCreateNestedManyWithoutPermissionInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type RolePermissionUncheckedCreateNestedManyWithoutPermissionInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type EnumResourceTypeFieldUpdateOperationsInput = {
    set?: $Enums.ResourceType
  }

  export type EnumPermissionActionFieldUpdateOperationsInput = {
    set?: $Enums.PermissionAction
  }

  export type RolePermissionUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutPermissionInput | RolePermissionUpsertWithWhereUniqueWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutPermissionInput | RolePermissionUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutPermissionInput | RolePermissionUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type RolePermissionUncheckedUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutPermissionInput | RolePermissionUpsertWithWhereUniqueWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutPermissionInput | RolePermissionUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutPermissionInput | RolePermissionUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type PermissionCreateNestedOneWithoutRolePermissionsInput = {
    create?: XOR<PermissionCreateWithoutRolePermissionsInput, PermissionUncheckedCreateWithoutRolePermissionsInput>
    connectOrCreate?: PermissionCreateOrConnectWithoutRolePermissionsInput
    connect?: PermissionWhereUniqueInput
  }

  export type PermissionUpdateOneRequiredWithoutRolePermissionsNestedInput = {
    create?: XOR<PermissionCreateWithoutRolePermissionsInput, PermissionUncheckedCreateWithoutRolePermissionsInput>
    connectOrCreate?: PermissionCreateOrConnectWithoutRolePermissionsInput
    upsert?: PermissionUpsertWithoutRolePermissionsInput
    connect?: PermissionWhereUniqueInput
    update?: XOR<XOR<PermissionUpdateToOneWithWhereWithoutRolePermissionsInput, PermissionUpdateWithoutRolePermissionsInput>, PermissionUncheckedUpdateWithoutRolePermissionsInput>
  }

  export type TenantCreateNestedOneWithoutInstancesInput = {
    create?: XOR<TenantCreateWithoutInstancesInput, TenantUncheckedCreateWithoutInstancesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutInstancesInput
    connect?: TenantWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutInstancesInput = {
    create?: XOR<UserCreateWithoutInstancesInput, UserUncheckedCreateWithoutInstancesInput>
    connectOrCreate?: UserCreateOrConnectWithoutInstancesInput
    connect?: UserWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutInstancesNestedInput = {
    create?: XOR<TenantCreateWithoutInstancesInput, TenantUncheckedCreateWithoutInstancesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutInstancesInput
    upsert?: TenantUpsertWithoutInstancesInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutInstancesInput, TenantUpdateWithoutInstancesInput>, TenantUncheckedUpdateWithoutInstancesInput>
  }

  export type UserUpdateOneRequiredWithoutInstancesNestedInput = {
    create?: XOR<UserCreateWithoutInstancesInput, UserUncheckedCreateWithoutInstancesInput>
    connectOrCreate?: UserCreateOrConnectWithoutInstancesInput
    upsert?: UserUpsertWithoutInstancesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInstancesInput, UserUpdateWithoutInstancesInput>, UserUncheckedUpdateWithoutInstancesInput>
  }

  export type TenantCreateNestedOneWithoutPrivateDataDisksInput = {
    create?: XOR<TenantCreateWithoutPrivateDataDisksInput, TenantUncheckedCreateWithoutPrivateDataDisksInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPrivateDataDisksInput
    connect?: TenantWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPrivateDataDisksInput = {
    create?: XOR<UserCreateWithoutPrivateDataDisksInput, UserUncheckedCreateWithoutPrivateDataDisksInput>
    connectOrCreate?: UserCreateOrConnectWithoutPrivateDataDisksInput
    connect?: UserWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TenantUpdateOneRequiredWithoutPrivateDataDisksNestedInput = {
    create?: XOR<TenantCreateWithoutPrivateDataDisksInput, TenantUncheckedCreateWithoutPrivateDataDisksInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPrivateDataDisksInput
    upsert?: TenantUpsertWithoutPrivateDataDisksInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutPrivateDataDisksInput, TenantUpdateWithoutPrivateDataDisksInput>, TenantUncheckedUpdateWithoutPrivateDataDisksInput>
  }

  export type UserUpdateOneRequiredWithoutPrivateDataDisksNestedInput = {
    create?: XOR<UserCreateWithoutPrivateDataDisksInput, UserUncheckedCreateWithoutPrivateDataDisksInput>
    connectOrCreate?: UserCreateOrConnectWithoutPrivateDataDisksInput
    upsert?: UserUpsertWithoutPrivateDataDisksInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPrivateDataDisksInput, UserUpdateWithoutPrivateDataDisksInput>, UserUncheckedUpdateWithoutPrivateDataDisksInput>
  }

  export type TenantCreateNestedOneWithoutVpcsInput = {
    create?: XOR<TenantCreateWithoutVpcsInput, TenantUncheckedCreateWithoutVpcsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutVpcsInput
    connect?: TenantWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutVpcsInput = {
    create?: XOR<UserCreateWithoutVpcsInput, UserUncheckedCreateWithoutVpcsInput>
    connectOrCreate?: UserCreateOrConnectWithoutVpcsInput
    connect?: UserWhereUniqueInput
  }

  export type SubnetCreateNestedManyWithoutVpcInput = {
    create?: XOR<SubnetCreateWithoutVpcInput, SubnetUncheckedCreateWithoutVpcInput> | SubnetCreateWithoutVpcInput[] | SubnetUncheckedCreateWithoutVpcInput[]
    connectOrCreate?: SubnetCreateOrConnectWithoutVpcInput | SubnetCreateOrConnectWithoutVpcInput[]
    createMany?: SubnetCreateManyVpcInputEnvelope
    connect?: SubnetWhereUniqueInput | SubnetWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutCreatedVpcsInput = {
    create?: XOR<UserCreateWithoutCreatedVpcsInput, UserUncheckedCreateWithoutCreatedVpcsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedVpcsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUpdatedVpcsInput = {
    create?: XOR<UserCreateWithoutUpdatedVpcsInput, UserUncheckedCreateWithoutUpdatedVpcsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUpdatedVpcsInput
    connect?: UserWhereUniqueInput
  }

  export type SubnetUncheckedCreateNestedManyWithoutVpcInput = {
    create?: XOR<SubnetCreateWithoutVpcInput, SubnetUncheckedCreateWithoutVpcInput> | SubnetCreateWithoutVpcInput[] | SubnetUncheckedCreateWithoutVpcInput[]
    connectOrCreate?: SubnetCreateOrConnectWithoutVpcInput | SubnetCreateOrConnectWithoutVpcInput[]
    createMany?: SubnetCreateManyVpcInputEnvelope
    connect?: SubnetWhereUniqueInput | SubnetWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type EnumVpcStatusFieldUpdateOperationsInput = {
    set?: $Enums.VpcStatus
  }

  export type TenantUpdateOneRequiredWithoutVpcsNestedInput = {
    create?: XOR<TenantCreateWithoutVpcsInput, TenantUncheckedCreateWithoutVpcsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutVpcsInput
    upsert?: TenantUpsertWithoutVpcsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutVpcsInput, TenantUpdateWithoutVpcsInput>, TenantUncheckedUpdateWithoutVpcsInput>
  }

  export type UserUpdateOneRequiredWithoutVpcsNestedInput = {
    create?: XOR<UserCreateWithoutVpcsInput, UserUncheckedCreateWithoutVpcsInput>
    connectOrCreate?: UserCreateOrConnectWithoutVpcsInput
    upsert?: UserUpsertWithoutVpcsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVpcsInput, UserUpdateWithoutVpcsInput>, UserUncheckedUpdateWithoutVpcsInput>
  }

  export type SubnetUpdateManyWithoutVpcNestedInput = {
    create?: XOR<SubnetCreateWithoutVpcInput, SubnetUncheckedCreateWithoutVpcInput> | SubnetCreateWithoutVpcInput[] | SubnetUncheckedCreateWithoutVpcInput[]
    connectOrCreate?: SubnetCreateOrConnectWithoutVpcInput | SubnetCreateOrConnectWithoutVpcInput[]
    upsert?: SubnetUpsertWithWhereUniqueWithoutVpcInput | SubnetUpsertWithWhereUniqueWithoutVpcInput[]
    createMany?: SubnetCreateManyVpcInputEnvelope
    set?: SubnetWhereUniqueInput | SubnetWhereUniqueInput[]
    disconnect?: SubnetWhereUniqueInput | SubnetWhereUniqueInput[]
    delete?: SubnetWhereUniqueInput | SubnetWhereUniqueInput[]
    connect?: SubnetWhereUniqueInput | SubnetWhereUniqueInput[]
    update?: SubnetUpdateWithWhereUniqueWithoutVpcInput | SubnetUpdateWithWhereUniqueWithoutVpcInput[]
    updateMany?: SubnetUpdateManyWithWhereWithoutVpcInput | SubnetUpdateManyWithWhereWithoutVpcInput[]
    deleteMany?: SubnetScalarWhereInput | SubnetScalarWhereInput[]
  }

  export type UserUpdateOneWithoutCreatedVpcsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedVpcsInput, UserUncheckedCreateWithoutCreatedVpcsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedVpcsInput
    upsert?: UserUpsertWithoutCreatedVpcsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedVpcsInput, UserUpdateWithoutCreatedVpcsInput>, UserUncheckedUpdateWithoutCreatedVpcsInput>
  }

  export type UserUpdateOneWithoutUpdatedVpcsNestedInput = {
    create?: XOR<UserCreateWithoutUpdatedVpcsInput, UserUncheckedCreateWithoutUpdatedVpcsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUpdatedVpcsInput
    upsert?: UserUpsertWithoutUpdatedVpcsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUpdatedVpcsInput, UserUpdateWithoutUpdatedVpcsInput>, UserUncheckedUpdateWithoutUpdatedVpcsInput>
  }

  export type SubnetUncheckedUpdateManyWithoutVpcNestedInput = {
    create?: XOR<SubnetCreateWithoutVpcInput, SubnetUncheckedCreateWithoutVpcInput> | SubnetCreateWithoutVpcInput[] | SubnetUncheckedCreateWithoutVpcInput[]
    connectOrCreate?: SubnetCreateOrConnectWithoutVpcInput | SubnetCreateOrConnectWithoutVpcInput[]
    upsert?: SubnetUpsertWithWhereUniqueWithoutVpcInput | SubnetUpsertWithWhereUniqueWithoutVpcInput[]
    createMany?: SubnetCreateManyVpcInputEnvelope
    set?: SubnetWhereUniqueInput | SubnetWhereUniqueInput[]
    disconnect?: SubnetWhereUniqueInput | SubnetWhereUniqueInput[]
    delete?: SubnetWhereUniqueInput | SubnetWhereUniqueInput[]
    connect?: SubnetWhereUniqueInput | SubnetWhereUniqueInput[]
    update?: SubnetUpdateWithWhereUniqueWithoutVpcInput | SubnetUpdateWithWhereUniqueWithoutVpcInput[]
    updateMany?: SubnetUpdateManyWithWhereWithoutVpcInput | SubnetUpdateManyWithWhereWithoutVpcInput[]
    deleteMany?: SubnetScalarWhereInput | SubnetScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutPlacesInput = {
    create?: XOR<TenantCreateWithoutPlacesInput, TenantUncheckedCreateWithoutPlacesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPlacesInput
    connect?: TenantWhereUniqueInput
  }

  export type SubnetCreateNestedOneWithoutPlaceInput = {
    create?: XOR<SubnetCreateWithoutPlaceInput, SubnetUncheckedCreateWithoutPlaceInput>
    connectOrCreate?: SubnetCreateOrConnectWithoutPlaceInput
    connect?: SubnetWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedPlacesInput = {
    create?: XOR<UserCreateWithoutCreatedPlacesInput, UserUncheckedCreateWithoutCreatedPlacesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedPlacesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUpdatedPlacesInput = {
    create?: XOR<UserCreateWithoutUpdatedPlacesInput, UserUncheckedCreateWithoutUpdatedPlacesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUpdatedPlacesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumPlaceStatusFieldUpdateOperationsInput = {
    set?: $Enums.PlaceStatus
  }

  export type TenantUpdateOneRequiredWithoutPlacesNestedInput = {
    create?: XOR<TenantCreateWithoutPlacesInput, TenantUncheckedCreateWithoutPlacesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPlacesInput
    upsert?: TenantUpsertWithoutPlacesInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutPlacesInput, TenantUpdateWithoutPlacesInput>, TenantUncheckedUpdateWithoutPlacesInput>
  }

  export type SubnetUpdateOneWithoutPlaceNestedInput = {
    create?: XOR<SubnetCreateWithoutPlaceInput, SubnetUncheckedCreateWithoutPlaceInput>
    connectOrCreate?: SubnetCreateOrConnectWithoutPlaceInput
    upsert?: SubnetUpsertWithoutPlaceInput
    disconnect?: SubnetWhereInput | boolean
    delete?: SubnetWhereInput | boolean
    connect?: SubnetWhereUniqueInput
    update?: XOR<XOR<SubnetUpdateToOneWithWhereWithoutPlaceInput, SubnetUpdateWithoutPlaceInput>, SubnetUncheckedUpdateWithoutPlaceInput>
  }

  export type UserUpdateOneWithoutCreatedPlacesNestedInput = {
    create?: XOR<UserCreateWithoutCreatedPlacesInput, UserUncheckedCreateWithoutCreatedPlacesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedPlacesInput
    upsert?: UserUpsertWithoutCreatedPlacesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedPlacesInput, UserUpdateWithoutCreatedPlacesInput>, UserUncheckedUpdateWithoutCreatedPlacesInput>
  }

  export type UserUpdateOneWithoutUpdatedPlacesNestedInput = {
    create?: XOR<UserCreateWithoutUpdatedPlacesInput, UserUncheckedCreateWithoutUpdatedPlacesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUpdatedPlacesInput
    upsert?: UserUpsertWithoutUpdatedPlacesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUpdatedPlacesInput, UserUpdateWithoutUpdatedPlacesInput>, UserUncheckedUpdateWithoutUpdatedPlacesInput>
  }

  export type VpcCreateNestedOneWithoutSubnetsInput = {
    create?: XOR<VpcCreateWithoutSubnetsInput, VpcUncheckedCreateWithoutSubnetsInput>
    connectOrCreate?: VpcCreateOrConnectWithoutSubnetsInput
    connect?: VpcWhereUniqueInput
  }

  export type PlaceCreateNestedOneWithoutSubnetInput = {
    create?: XOR<PlaceCreateWithoutSubnetInput, PlaceUncheckedCreateWithoutSubnetInput>
    connectOrCreate?: PlaceCreateOrConnectWithoutSubnetInput
    connect?: PlaceWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedSubnetsInput = {
    create?: XOR<UserCreateWithoutCreatedSubnetsInput, UserUncheckedCreateWithoutCreatedSubnetsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedSubnetsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUpdatedSubnetsInput = {
    create?: XOR<UserCreateWithoutUpdatedSubnetsInput, UserUncheckedCreateWithoutUpdatedSubnetsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUpdatedSubnetsInput
    connect?: UserWhereUniqueInput
  }

  export type PlaceUncheckedCreateNestedOneWithoutSubnetInput = {
    create?: XOR<PlaceCreateWithoutSubnetInput, PlaceUncheckedCreateWithoutSubnetInput>
    connectOrCreate?: PlaceCreateOrConnectWithoutSubnetInput
    connect?: PlaceWhereUniqueInput
  }

  export type EnumSubnetStatusFieldUpdateOperationsInput = {
    set?: $Enums.SubnetStatus
  }

  export type VpcUpdateOneRequiredWithoutSubnetsNestedInput = {
    create?: XOR<VpcCreateWithoutSubnetsInput, VpcUncheckedCreateWithoutSubnetsInput>
    connectOrCreate?: VpcCreateOrConnectWithoutSubnetsInput
    upsert?: VpcUpsertWithoutSubnetsInput
    connect?: VpcWhereUniqueInput
    update?: XOR<XOR<VpcUpdateToOneWithWhereWithoutSubnetsInput, VpcUpdateWithoutSubnetsInput>, VpcUncheckedUpdateWithoutSubnetsInput>
  }

  export type PlaceUpdateOneWithoutSubnetNestedInput = {
    create?: XOR<PlaceCreateWithoutSubnetInput, PlaceUncheckedCreateWithoutSubnetInput>
    connectOrCreate?: PlaceCreateOrConnectWithoutSubnetInput
    upsert?: PlaceUpsertWithoutSubnetInput
    disconnect?: PlaceWhereInput | boolean
    delete?: PlaceWhereInput | boolean
    connect?: PlaceWhereUniqueInput
    update?: XOR<XOR<PlaceUpdateToOneWithWhereWithoutSubnetInput, PlaceUpdateWithoutSubnetInput>, PlaceUncheckedUpdateWithoutSubnetInput>
  }

  export type UserUpdateOneWithoutCreatedSubnetsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedSubnetsInput, UserUncheckedCreateWithoutCreatedSubnetsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedSubnetsInput
    upsert?: UserUpsertWithoutCreatedSubnetsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedSubnetsInput, UserUpdateWithoutCreatedSubnetsInput>, UserUncheckedUpdateWithoutCreatedSubnetsInput>
  }

  export type UserUpdateOneWithoutUpdatedSubnetsNestedInput = {
    create?: XOR<UserCreateWithoutUpdatedSubnetsInput, UserUncheckedCreateWithoutUpdatedSubnetsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUpdatedSubnetsInput
    upsert?: UserUpsertWithoutUpdatedSubnetsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUpdatedSubnetsInput, UserUpdateWithoutUpdatedSubnetsInput>, UserUncheckedUpdateWithoutUpdatedSubnetsInput>
  }

  export type PlaceUncheckedUpdateOneWithoutSubnetNestedInput = {
    create?: XOR<PlaceCreateWithoutSubnetInput, PlaceUncheckedCreateWithoutSubnetInput>
    connectOrCreate?: PlaceCreateOrConnectWithoutSubnetInput
    upsert?: PlaceUpsertWithoutSubnetInput
    disconnect?: PlaceWhereInput | boolean
    delete?: PlaceWhereInput | boolean
    connect?: PlaceWhereUniqueInput
    update?: XOR<XOR<PlaceUpdateToOneWithWhereWithoutSubnetInput, PlaceUpdateWithoutSubnetInput>, PlaceUncheckedUpdateWithoutSubnetInput>
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumTenantStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TenantStatus | EnumTenantStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TenantStatus[] | ListEnumTenantStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TenantStatus[] | ListEnumTenantStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTenantStatusFilter<$PrismaModel> | $Enums.TenantStatus
  }

  export type NestedUuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedEnumTenantStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TenantStatus | EnumTenantStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TenantStatus[] | ListEnumTenantStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TenantStatus[] | ListEnumTenantStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTenantStatusWithAggregatesFilter<$PrismaModel> | $Enums.TenantStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTenantStatusFilter<$PrismaModel>
    _max?: NestedEnumTenantStatusFilter<$PrismaModel>
  }

  export type NestedUuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedEnumUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusFilter<$PrismaModel> | $Enums.UserStatus
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedEnumUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserStatusFilter<$PrismaModel>
    _max?: NestedEnumUserStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumResourceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ResourceType | EnumResourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ResourceType[] | ListEnumResourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ResourceType[] | ListEnumResourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumResourceTypeFilter<$PrismaModel> | $Enums.ResourceType
  }

  export type NestedEnumPermissionActionFilter<$PrismaModel = never> = {
    equals?: $Enums.PermissionAction | EnumPermissionActionFieldRefInput<$PrismaModel>
    in?: $Enums.PermissionAction[] | ListEnumPermissionActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.PermissionAction[] | ListEnumPermissionActionFieldRefInput<$PrismaModel>
    not?: NestedEnumPermissionActionFilter<$PrismaModel> | $Enums.PermissionAction
  }

  export type NestedEnumResourceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ResourceType | EnumResourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ResourceType[] | ListEnumResourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ResourceType[] | ListEnumResourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumResourceTypeWithAggregatesFilter<$PrismaModel> | $Enums.ResourceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumResourceTypeFilter<$PrismaModel>
    _max?: NestedEnumResourceTypeFilter<$PrismaModel>
  }

  export type NestedEnumPermissionActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PermissionAction | EnumPermissionActionFieldRefInput<$PrismaModel>
    in?: $Enums.PermissionAction[] | ListEnumPermissionActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.PermissionAction[] | ListEnumPermissionActionFieldRefInput<$PrismaModel>
    not?: NestedEnumPermissionActionWithAggregatesFilter<$PrismaModel> | $Enums.PermissionAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPermissionActionFilter<$PrismaModel>
    _max?: NestedEnumPermissionActionFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumVpcStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VpcStatus | EnumVpcStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VpcStatus[] | ListEnumVpcStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VpcStatus[] | ListEnumVpcStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVpcStatusFilter<$PrismaModel> | $Enums.VpcStatus
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumVpcStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VpcStatus | EnumVpcStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VpcStatus[] | ListEnumVpcStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VpcStatus[] | ListEnumVpcStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVpcStatusWithAggregatesFilter<$PrismaModel> | $Enums.VpcStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVpcStatusFilter<$PrismaModel>
    _max?: NestedEnumVpcStatusFilter<$PrismaModel>
  }

  export type NestedEnumPlaceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PlaceStatus | EnumPlaceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PlaceStatus[] | ListEnumPlaceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlaceStatus[] | ListEnumPlaceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPlaceStatusFilter<$PrismaModel> | $Enums.PlaceStatus
  }

  export type NestedEnumPlaceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PlaceStatus | EnumPlaceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PlaceStatus[] | ListEnumPlaceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlaceStatus[] | ListEnumPlaceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPlaceStatusWithAggregatesFilter<$PrismaModel> | $Enums.PlaceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPlaceStatusFilter<$PrismaModel>
    _max?: NestedEnumPlaceStatusFilter<$PrismaModel>
  }

  export type NestedEnumSubnetStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubnetStatus | EnumSubnetStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubnetStatus[] | ListEnumSubnetStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubnetStatus[] | ListEnumSubnetStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubnetStatusFilter<$PrismaModel> | $Enums.SubnetStatus
  }

  export type NestedEnumSubnetStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubnetStatus | EnumSubnetStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubnetStatus[] | ListEnumSubnetStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubnetStatus[] | ListEnumSubnetStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubnetStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubnetStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubnetStatusFilter<$PrismaModel>
    _max?: NestedEnumSubnetStatusFilter<$PrismaModel>
  }

  export type UserCreateWithoutTenantInput = {
    id?: string
    username: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    groupMemberships?: UserGroupMemberCreateNestedManyWithoutUserInput
    instances?: InstanceCreateNestedManyWithoutUserInput
    privateDataDisks?: PrivateDataDiskCreateNestedManyWithoutUserInput
    createdTenants?: TenantCreateNestedManyWithoutCreatorInput
    vpcs?: VpcCreateNestedManyWithoutUserInput
    createdVpcs?: VpcCreateNestedManyWithoutCreatorInput
    updatedVpcs?: VpcCreateNestedManyWithoutUpdaterInput
    createdPlaces?: PlaceCreateNestedManyWithoutCreatorInput
    updatedPlaces?: PlaceCreateNestedManyWithoutUpdaterInput
    createdSubnets?: SubnetCreateNestedManyWithoutCreatorInput
    updatedSubnets?: SubnetCreateNestedManyWithoutUpdaterInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTenantInput = {
    id?: string
    username: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    groupMemberships?: UserGroupMemberUncheckedCreateNestedManyWithoutUserInput
    instances?: InstanceUncheckedCreateNestedManyWithoutUserInput
    privateDataDisks?: PrivateDataDiskUncheckedCreateNestedManyWithoutUserInput
    createdTenants?: TenantUncheckedCreateNestedManyWithoutCreatorInput
    vpcs?: VpcUncheckedCreateNestedManyWithoutUserInput
    createdVpcs?: VpcUncheckedCreateNestedManyWithoutCreatorInput
    updatedVpcs?: VpcUncheckedCreateNestedManyWithoutUpdaterInput
    createdPlaces?: PlaceUncheckedCreateNestedManyWithoutCreatorInput
    updatedPlaces?: PlaceUncheckedCreateNestedManyWithoutUpdaterInput
    createdSubnets?: SubnetUncheckedCreateNestedManyWithoutCreatorInput
    updatedSubnets?: SubnetUncheckedCreateNestedManyWithoutUpdaterInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTenantInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput>
  }

  export type UserCreateManyTenantInputEnvelope = {
    data: UserCreateManyTenantInput | UserCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type UserGroupCreateWithoutTenantInput = {
    id?: string
    name: string
    description?: string | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    parentGroup?: UserGroupCreateNestedOneWithoutChildGroupsInput
    childGroups?: UserGroupCreateNestedManyWithoutParentGroupInput
    members?: UserGroupMemberCreateNestedManyWithoutGroupInput
  }

  export type UserGroupUncheckedCreateWithoutTenantInput = {
    id?: string
    name: string
    description?: string | null
    parentGroupId?: string | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    childGroups?: UserGroupUncheckedCreateNestedManyWithoutParentGroupInput
    members?: UserGroupMemberUncheckedCreateNestedManyWithoutGroupInput
  }

  export type UserGroupCreateOrConnectWithoutTenantInput = {
    where: UserGroupWhereUniqueInput
    create: XOR<UserGroupCreateWithoutTenantInput, UserGroupUncheckedCreateWithoutTenantInput>
  }

  export type UserGroupCreateManyTenantInputEnvelope = {
    data: UserGroupCreateManyTenantInput | UserGroupCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type InstanceCreateWithoutTenantInput = {
    id?: string
    name: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutInstancesInput
  }

  export type InstanceUncheckedCreateWithoutTenantInput = {
    id?: string
    name: string
    userId: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InstanceCreateOrConnectWithoutTenantInput = {
    where: InstanceWhereUniqueInput
    create: XOR<InstanceCreateWithoutTenantInput, InstanceUncheckedCreateWithoutTenantInput>
  }

  export type InstanceCreateManyTenantInputEnvelope = {
    data: InstanceCreateManyTenantInput | InstanceCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type PrivateDataDiskCreateWithoutTenantInput = {
    id?: string
    name: string
    sizeGb: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPrivateDataDisksInput
  }

  export type PrivateDataDiskUncheckedCreateWithoutTenantInput = {
    id?: string
    name: string
    userId: string
    sizeGb: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PrivateDataDiskCreateOrConnectWithoutTenantInput = {
    where: PrivateDataDiskWhereUniqueInput
    create: XOR<PrivateDataDiskCreateWithoutTenantInput, PrivateDataDiskUncheckedCreateWithoutTenantInput>
  }

  export type PrivateDataDiskCreateManyTenantInputEnvelope = {
    data: PrivateDataDiskCreateManyTenantInput | PrivateDataDiskCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type VpcCreateWithoutTenantInput = {
    id?: string
    name: string
    description?: string | null
    cidrBlock: string
    edgeDataCenterId?: string | null
    vlanId?: number | null
    enableDns?: boolean
    dnsServers?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.VpcStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutVpcsInput
    subnets?: SubnetCreateNestedManyWithoutVpcInput
    creator?: UserCreateNestedOneWithoutCreatedVpcsInput
    updater?: UserCreateNestedOneWithoutUpdatedVpcsInput
  }

  export type VpcUncheckedCreateWithoutTenantInput = {
    id?: string
    name: string
    description?: string | null
    userId: string
    cidrBlock: string
    edgeDataCenterId?: string | null
    vlanId?: number | null
    enableDns?: boolean
    dnsServers?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.VpcStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    subnets?: SubnetUncheckedCreateNestedManyWithoutVpcInput
  }

  export type VpcCreateOrConnectWithoutTenantInput = {
    where: VpcWhereUniqueInput
    create: XOR<VpcCreateWithoutTenantInput, VpcUncheckedCreateWithoutTenantInput>
  }

  export type VpcCreateManyTenantInputEnvelope = {
    data: VpcCreateManyTenantInput | VpcCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type PlaceCreateWithoutTenantInput = {
    id?: string
    name: string
    description?: string | null
    location?: string | null
    status?: $Enums.PlaceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    subnet?: SubnetCreateNestedOneWithoutPlaceInput
    creator?: UserCreateNestedOneWithoutCreatedPlacesInput
    updater?: UserCreateNestedOneWithoutUpdatedPlacesInput
  }

  export type PlaceUncheckedCreateWithoutTenantInput = {
    id?: string
    name: string
    description?: string | null
    subnetId?: string | null
    location?: string | null
    status?: $Enums.PlaceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
  }

  export type PlaceCreateOrConnectWithoutTenantInput = {
    where: PlaceWhereUniqueInput
    create: XOR<PlaceCreateWithoutTenantInput, PlaceUncheckedCreateWithoutTenantInput>
  }

  export type PlaceCreateManyTenantInputEnvelope = {
    data: PlaceCreateManyTenantInput | PlaceCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutCreatedTenantsInput = {
    id?: string
    username: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant?: TenantCreateNestedOneWithoutUsersInput
    groupMemberships?: UserGroupMemberCreateNestedManyWithoutUserInput
    instances?: InstanceCreateNestedManyWithoutUserInput
    privateDataDisks?: PrivateDataDiskCreateNestedManyWithoutUserInput
    vpcs?: VpcCreateNestedManyWithoutUserInput
    createdVpcs?: VpcCreateNestedManyWithoutCreatorInput
    updatedVpcs?: VpcCreateNestedManyWithoutUpdaterInput
    createdPlaces?: PlaceCreateNestedManyWithoutCreatorInput
    updatedPlaces?: PlaceCreateNestedManyWithoutUpdaterInput
    createdSubnets?: SubnetCreateNestedManyWithoutCreatorInput
    updatedSubnets?: SubnetCreateNestedManyWithoutUpdaterInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedTenantsInput = {
    id?: string
    username: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    tenantId?: string | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    groupMemberships?: UserGroupMemberUncheckedCreateNestedManyWithoutUserInput
    instances?: InstanceUncheckedCreateNestedManyWithoutUserInput
    privateDataDisks?: PrivateDataDiskUncheckedCreateNestedManyWithoutUserInput
    vpcs?: VpcUncheckedCreateNestedManyWithoutUserInput
    createdVpcs?: VpcUncheckedCreateNestedManyWithoutCreatorInput
    updatedVpcs?: VpcUncheckedCreateNestedManyWithoutUpdaterInput
    createdPlaces?: PlaceUncheckedCreateNestedManyWithoutCreatorInput
    updatedPlaces?: PlaceUncheckedCreateNestedManyWithoutUpdaterInput
    createdSubnets?: SubnetUncheckedCreateNestedManyWithoutCreatorInput
    updatedSubnets?: SubnetUncheckedCreateNestedManyWithoutUpdaterInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedTenantsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedTenantsInput, UserUncheckedCreateWithoutCreatedTenantsInput>
  }

  export type UserUpsertWithWhereUniqueWithoutTenantInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutTenantInput, UserUncheckedUpdateWithoutTenantInput>
    create: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput>
  }

  export type UserUpdateWithWhereUniqueWithoutTenantInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutTenantInput, UserUncheckedUpdateWithoutTenantInput>
  }

  export type UserUpdateManyWithWhereWithoutTenantInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutTenantInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: UuidFilter<"User"> | string
    username?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    tenantId?: UuidNullableFilter<"User"> | string | null
    quotaConfig?: JsonNullableFilter<"User">
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type UserGroupUpsertWithWhereUniqueWithoutTenantInput = {
    where: UserGroupWhereUniqueInput
    update: XOR<UserGroupUpdateWithoutTenantInput, UserGroupUncheckedUpdateWithoutTenantInput>
    create: XOR<UserGroupCreateWithoutTenantInput, UserGroupUncheckedCreateWithoutTenantInput>
  }

  export type UserGroupUpdateWithWhereUniqueWithoutTenantInput = {
    where: UserGroupWhereUniqueInput
    data: XOR<UserGroupUpdateWithoutTenantInput, UserGroupUncheckedUpdateWithoutTenantInput>
  }

  export type UserGroupUpdateManyWithWhereWithoutTenantInput = {
    where: UserGroupScalarWhereInput
    data: XOR<UserGroupUpdateManyMutationInput, UserGroupUncheckedUpdateManyWithoutTenantInput>
  }

  export type UserGroupScalarWhereInput = {
    AND?: UserGroupScalarWhereInput | UserGroupScalarWhereInput[]
    OR?: UserGroupScalarWhereInput[]
    NOT?: UserGroupScalarWhereInput | UserGroupScalarWhereInput[]
    id?: UuidFilter<"UserGroup"> | string
    name?: StringFilter<"UserGroup"> | string
    description?: StringNullableFilter<"UserGroup"> | string | null
    tenantId?: UuidFilter<"UserGroup"> | string
    parentGroupId?: UuidNullableFilter<"UserGroup"> | string | null
    quotaConfig?: JsonNullableFilter<"UserGroup">
    createdAt?: DateTimeFilter<"UserGroup"> | Date | string
    updatedAt?: DateTimeFilter<"UserGroup"> | Date | string
  }

  export type InstanceUpsertWithWhereUniqueWithoutTenantInput = {
    where: InstanceWhereUniqueInput
    update: XOR<InstanceUpdateWithoutTenantInput, InstanceUncheckedUpdateWithoutTenantInput>
    create: XOR<InstanceCreateWithoutTenantInput, InstanceUncheckedCreateWithoutTenantInput>
  }

  export type InstanceUpdateWithWhereUniqueWithoutTenantInput = {
    where: InstanceWhereUniqueInput
    data: XOR<InstanceUpdateWithoutTenantInput, InstanceUncheckedUpdateWithoutTenantInput>
  }

  export type InstanceUpdateManyWithWhereWithoutTenantInput = {
    where: InstanceScalarWhereInput
    data: XOR<InstanceUpdateManyMutationInput, InstanceUncheckedUpdateManyWithoutTenantInput>
  }

  export type InstanceScalarWhereInput = {
    AND?: InstanceScalarWhereInput | InstanceScalarWhereInput[]
    OR?: InstanceScalarWhereInput[]
    NOT?: InstanceScalarWhereInput | InstanceScalarWhereInput[]
    id?: UuidFilter<"Instance"> | string
    name?: StringFilter<"Instance"> | string
    tenantId?: UuidFilter<"Instance"> | string
    userId?: UuidFilter<"Instance"> | string
    status?: StringFilter<"Instance"> | string
    createdAt?: DateTimeFilter<"Instance"> | Date | string
    updatedAt?: DateTimeFilter<"Instance"> | Date | string
  }

  export type PrivateDataDiskUpsertWithWhereUniqueWithoutTenantInput = {
    where: PrivateDataDiskWhereUniqueInput
    update: XOR<PrivateDataDiskUpdateWithoutTenantInput, PrivateDataDiskUncheckedUpdateWithoutTenantInput>
    create: XOR<PrivateDataDiskCreateWithoutTenantInput, PrivateDataDiskUncheckedCreateWithoutTenantInput>
  }

  export type PrivateDataDiskUpdateWithWhereUniqueWithoutTenantInput = {
    where: PrivateDataDiskWhereUniqueInput
    data: XOR<PrivateDataDiskUpdateWithoutTenantInput, PrivateDataDiskUncheckedUpdateWithoutTenantInput>
  }

  export type PrivateDataDiskUpdateManyWithWhereWithoutTenantInput = {
    where: PrivateDataDiskScalarWhereInput
    data: XOR<PrivateDataDiskUpdateManyMutationInput, PrivateDataDiskUncheckedUpdateManyWithoutTenantInput>
  }

  export type PrivateDataDiskScalarWhereInput = {
    AND?: PrivateDataDiskScalarWhereInput | PrivateDataDiskScalarWhereInput[]
    OR?: PrivateDataDiskScalarWhereInput[]
    NOT?: PrivateDataDiskScalarWhereInput | PrivateDataDiskScalarWhereInput[]
    id?: UuidFilter<"PrivateDataDisk"> | string
    name?: StringFilter<"PrivateDataDisk"> | string
    tenantId?: UuidFilter<"PrivateDataDisk"> | string
    userId?: UuidFilter<"PrivateDataDisk"> | string
    sizeGb?: IntFilter<"PrivateDataDisk"> | number
    status?: StringFilter<"PrivateDataDisk"> | string
    createdAt?: DateTimeFilter<"PrivateDataDisk"> | Date | string
    updatedAt?: DateTimeFilter<"PrivateDataDisk"> | Date | string
  }

  export type VpcUpsertWithWhereUniqueWithoutTenantInput = {
    where: VpcWhereUniqueInput
    update: XOR<VpcUpdateWithoutTenantInput, VpcUncheckedUpdateWithoutTenantInput>
    create: XOR<VpcCreateWithoutTenantInput, VpcUncheckedCreateWithoutTenantInput>
  }

  export type VpcUpdateWithWhereUniqueWithoutTenantInput = {
    where: VpcWhereUniqueInput
    data: XOR<VpcUpdateWithoutTenantInput, VpcUncheckedUpdateWithoutTenantInput>
  }

  export type VpcUpdateManyWithWhereWithoutTenantInput = {
    where: VpcScalarWhereInput
    data: XOR<VpcUpdateManyMutationInput, VpcUncheckedUpdateManyWithoutTenantInput>
  }

  export type VpcScalarWhereInput = {
    AND?: VpcScalarWhereInput | VpcScalarWhereInput[]
    OR?: VpcScalarWhereInput[]
    NOT?: VpcScalarWhereInput | VpcScalarWhereInput[]
    id?: UuidFilter<"Vpc"> | string
    name?: StringFilter<"Vpc"> | string
    description?: StringNullableFilter<"Vpc"> | string | null
    tenantId?: UuidFilter<"Vpc"> | string
    userId?: UuidFilter<"Vpc"> | string
    cidrBlock?: StringFilter<"Vpc"> | string
    edgeDataCenterId?: UuidNullableFilter<"Vpc"> | string | null
    vlanId?: IntNullableFilter<"Vpc"> | number | null
    enableDns?: BoolFilter<"Vpc"> | boolean
    dnsServers?: JsonNullableFilter<"Vpc">
    status?: EnumVpcStatusFilter<"Vpc"> | $Enums.VpcStatus
    createdAt?: DateTimeFilter<"Vpc"> | Date | string
    updatedAt?: DateTimeFilter<"Vpc"> | Date | string
    createdBy?: UuidNullableFilter<"Vpc"> | string | null
    updatedBy?: UuidNullableFilter<"Vpc"> | string | null
  }

  export type PlaceUpsertWithWhereUniqueWithoutTenantInput = {
    where: PlaceWhereUniqueInput
    update: XOR<PlaceUpdateWithoutTenantInput, PlaceUncheckedUpdateWithoutTenantInput>
    create: XOR<PlaceCreateWithoutTenantInput, PlaceUncheckedCreateWithoutTenantInput>
  }

  export type PlaceUpdateWithWhereUniqueWithoutTenantInput = {
    where: PlaceWhereUniqueInput
    data: XOR<PlaceUpdateWithoutTenantInput, PlaceUncheckedUpdateWithoutTenantInput>
  }

  export type PlaceUpdateManyWithWhereWithoutTenantInput = {
    where: PlaceScalarWhereInput
    data: XOR<PlaceUpdateManyMutationInput, PlaceUncheckedUpdateManyWithoutTenantInput>
  }

  export type PlaceScalarWhereInput = {
    AND?: PlaceScalarWhereInput | PlaceScalarWhereInput[]
    OR?: PlaceScalarWhereInput[]
    NOT?: PlaceScalarWhereInput | PlaceScalarWhereInput[]
    id?: UuidFilter<"Place"> | string
    name?: StringFilter<"Place"> | string
    description?: StringNullableFilter<"Place"> | string | null
    tenantId?: UuidFilter<"Place"> | string
    subnetId?: UuidNullableFilter<"Place"> | string | null
    location?: StringNullableFilter<"Place"> | string | null
    status?: EnumPlaceStatusFilter<"Place"> | $Enums.PlaceStatus
    createdAt?: DateTimeFilter<"Place"> | Date | string
    updatedAt?: DateTimeFilter<"Place"> | Date | string
    createdBy?: UuidNullableFilter<"Place"> | string | null
    updatedBy?: UuidNullableFilter<"Place"> | string | null
  }

  export type UserUpsertWithoutCreatedTenantsInput = {
    update: XOR<UserUpdateWithoutCreatedTenantsInput, UserUncheckedUpdateWithoutCreatedTenantsInput>
    create: XOR<UserCreateWithoutCreatedTenantsInput, UserUncheckedCreateWithoutCreatedTenantsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedTenantsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedTenantsInput, UserUncheckedUpdateWithoutCreatedTenantsInput>
  }

  export type UserUpdateWithoutCreatedTenantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutUsersNestedInput
    groupMemberships?: UserGroupMemberUpdateManyWithoutUserNestedInput
    instances?: InstanceUpdateManyWithoutUserNestedInput
    privateDataDisks?: PrivateDataDiskUpdateManyWithoutUserNestedInput
    vpcs?: VpcUpdateManyWithoutUserNestedInput
    createdVpcs?: VpcUpdateManyWithoutCreatorNestedInput
    updatedVpcs?: VpcUpdateManyWithoutUpdaterNestedInput
    createdPlaces?: PlaceUpdateManyWithoutCreatorNestedInput
    updatedPlaces?: PlaceUpdateManyWithoutUpdaterNestedInput
    createdSubnets?: SubnetUpdateManyWithoutCreatorNestedInput
    updatedSubnets?: SubnetUpdateManyWithoutUpdaterNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedTenantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groupMemberships?: UserGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    instances?: InstanceUncheckedUpdateManyWithoutUserNestedInput
    privateDataDisks?: PrivateDataDiskUncheckedUpdateManyWithoutUserNestedInput
    vpcs?: VpcUncheckedUpdateManyWithoutUserNestedInput
    createdVpcs?: VpcUncheckedUpdateManyWithoutCreatorNestedInput
    updatedVpcs?: VpcUncheckedUpdateManyWithoutUpdaterNestedInput
    createdPlaces?: PlaceUncheckedUpdateManyWithoutCreatorNestedInput
    updatedPlaces?: PlaceUncheckedUpdateManyWithoutUpdaterNestedInput
    createdSubnets?: SubnetUncheckedUpdateManyWithoutCreatorNestedInput
    updatedSubnets?: SubnetUncheckedUpdateManyWithoutUpdaterNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TenantCreateWithoutUsersInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.TenantStatus
    adminUserId?: string | null
    vlanId?: number | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    userGroups?: UserGroupCreateNestedManyWithoutTenantInput
    instances?: InstanceCreateNestedManyWithoutTenantInput
    privateDataDisks?: PrivateDataDiskCreateNestedManyWithoutTenantInput
    vpcs?: VpcCreateNestedManyWithoutTenantInput
    places?: PlaceCreateNestedManyWithoutTenantInput
    creator?: UserCreateNestedOneWithoutCreatedTenantsInput
  }

  export type TenantUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.TenantStatus
    adminUserId?: string | null
    vlanId?: number | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    userGroups?: UserGroupUncheckedCreateNestedManyWithoutTenantInput
    instances?: InstanceUncheckedCreateNestedManyWithoutTenantInput
    privateDataDisks?: PrivateDataDiskUncheckedCreateNestedManyWithoutTenantInput
    vpcs?: VpcUncheckedCreateNestedManyWithoutTenantInput
    places?: PlaceUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutUsersInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
  }

  export type UserGroupMemberCreateWithoutUserInput = {
    id?: string
    joinedAt?: Date | string
    addedBy?: string | null
    group: UserGroupCreateNestedOneWithoutMembersInput
  }

  export type UserGroupMemberUncheckedCreateWithoutUserInput = {
    id?: string
    groupId: string
    joinedAt?: Date | string
    addedBy?: string | null
  }

  export type UserGroupMemberCreateOrConnectWithoutUserInput = {
    where: UserGroupMemberWhereUniqueInput
    create: XOR<UserGroupMemberCreateWithoutUserInput, UserGroupMemberUncheckedCreateWithoutUserInput>
  }

  export type UserGroupMemberCreateManyUserInputEnvelope = {
    data: UserGroupMemberCreateManyUserInput | UserGroupMemberCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type InstanceCreateWithoutUserInput = {
    id?: string
    name: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutInstancesInput
  }

  export type InstanceUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    tenantId: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InstanceCreateOrConnectWithoutUserInput = {
    where: InstanceWhereUniqueInput
    create: XOR<InstanceCreateWithoutUserInput, InstanceUncheckedCreateWithoutUserInput>
  }

  export type InstanceCreateManyUserInputEnvelope = {
    data: InstanceCreateManyUserInput | InstanceCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PrivateDataDiskCreateWithoutUserInput = {
    id?: string
    name: string
    sizeGb: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutPrivateDataDisksInput
  }

  export type PrivateDataDiskUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    tenantId: string
    sizeGb: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PrivateDataDiskCreateOrConnectWithoutUserInput = {
    where: PrivateDataDiskWhereUniqueInput
    create: XOR<PrivateDataDiskCreateWithoutUserInput, PrivateDataDiskUncheckedCreateWithoutUserInput>
  }

  export type PrivateDataDiskCreateManyUserInputEnvelope = {
    data: PrivateDataDiskCreateManyUserInput | PrivateDataDiskCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TenantCreateWithoutCreatorInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.TenantStatus
    adminUserId?: string | null
    vlanId?: number | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    userGroups?: UserGroupCreateNestedManyWithoutTenantInput
    instances?: InstanceCreateNestedManyWithoutTenantInput
    privateDataDisks?: PrivateDataDiskCreateNestedManyWithoutTenantInput
    vpcs?: VpcCreateNestedManyWithoutTenantInput
    places?: PlaceCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutCreatorInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.TenantStatus
    adminUserId?: string | null
    vlanId?: number | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    userGroups?: UserGroupUncheckedCreateNestedManyWithoutTenantInput
    instances?: InstanceUncheckedCreateNestedManyWithoutTenantInput
    privateDataDisks?: PrivateDataDiskUncheckedCreateNestedManyWithoutTenantInput
    vpcs?: VpcUncheckedCreateNestedManyWithoutTenantInput
    places?: PlaceUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutCreatorInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutCreatorInput, TenantUncheckedCreateWithoutCreatorInput>
  }

  export type TenantCreateManyCreatorInputEnvelope = {
    data: TenantCreateManyCreatorInput | TenantCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type VpcCreateWithoutUserInput = {
    id?: string
    name: string
    description?: string | null
    cidrBlock: string
    edgeDataCenterId?: string | null
    vlanId?: number | null
    enableDns?: boolean
    dnsServers?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.VpcStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutVpcsInput
    subnets?: SubnetCreateNestedManyWithoutVpcInput
    creator?: UserCreateNestedOneWithoutCreatedVpcsInput
    updater?: UserCreateNestedOneWithoutUpdatedVpcsInput
  }

  export type VpcUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    description?: string | null
    tenantId: string
    cidrBlock: string
    edgeDataCenterId?: string | null
    vlanId?: number | null
    enableDns?: boolean
    dnsServers?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.VpcStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    subnets?: SubnetUncheckedCreateNestedManyWithoutVpcInput
  }

  export type VpcCreateOrConnectWithoutUserInput = {
    where: VpcWhereUniqueInput
    create: XOR<VpcCreateWithoutUserInput, VpcUncheckedCreateWithoutUserInput>
  }

  export type VpcCreateManyUserInputEnvelope = {
    data: VpcCreateManyUserInput | VpcCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type VpcCreateWithoutCreatorInput = {
    id?: string
    name: string
    description?: string | null
    cidrBlock: string
    edgeDataCenterId?: string | null
    vlanId?: number | null
    enableDns?: boolean
    dnsServers?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.VpcStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutVpcsInput
    user: UserCreateNestedOneWithoutVpcsInput
    subnets?: SubnetCreateNestedManyWithoutVpcInput
    updater?: UserCreateNestedOneWithoutUpdatedVpcsInput
  }

  export type VpcUncheckedCreateWithoutCreatorInput = {
    id?: string
    name: string
    description?: string | null
    tenantId: string
    userId: string
    cidrBlock: string
    edgeDataCenterId?: string | null
    vlanId?: number | null
    enableDns?: boolean
    dnsServers?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.VpcStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
    subnets?: SubnetUncheckedCreateNestedManyWithoutVpcInput
  }

  export type VpcCreateOrConnectWithoutCreatorInput = {
    where: VpcWhereUniqueInput
    create: XOR<VpcCreateWithoutCreatorInput, VpcUncheckedCreateWithoutCreatorInput>
  }

  export type VpcCreateManyCreatorInputEnvelope = {
    data: VpcCreateManyCreatorInput | VpcCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type VpcCreateWithoutUpdaterInput = {
    id?: string
    name: string
    description?: string | null
    cidrBlock: string
    edgeDataCenterId?: string | null
    vlanId?: number | null
    enableDns?: boolean
    dnsServers?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.VpcStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutVpcsInput
    user: UserCreateNestedOneWithoutVpcsInput
    subnets?: SubnetCreateNestedManyWithoutVpcInput
    creator?: UserCreateNestedOneWithoutCreatedVpcsInput
  }

  export type VpcUncheckedCreateWithoutUpdaterInput = {
    id?: string
    name: string
    description?: string | null
    tenantId: string
    userId: string
    cidrBlock: string
    edgeDataCenterId?: string | null
    vlanId?: number | null
    enableDns?: boolean
    dnsServers?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.VpcStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    subnets?: SubnetUncheckedCreateNestedManyWithoutVpcInput
  }

  export type VpcCreateOrConnectWithoutUpdaterInput = {
    where: VpcWhereUniqueInput
    create: XOR<VpcCreateWithoutUpdaterInput, VpcUncheckedCreateWithoutUpdaterInput>
  }

  export type VpcCreateManyUpdaterInputEnvelope = {
    data: VpcCreateManyUpdaterInput | VpcCreateManyUpdaterInput[]
    skipDuplicates?: boolean
  }

  export type PlaceCreateWithoutCreatorInput = {
    id?: string
    name: string
    description?: string | null
    location?: string | null
    status?: $Enums.PlaceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutPlacesInput
    subnet?: SubnetCreateNestedOneWithoutPlaceInput
    updater?: UserCreateNestedOneWithoutUpdatedPlacesInput
  }

  export type PlaceUncheckedCreateWithoutCreatorInput = {
    id?: string
    name: string
    description?: string | null
    tenantId: string
    subnetId?: string | null
    location?: string | null
    status?: $Enums.PlaceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type PlaceCreateOrConnectWithoutCreatorInput = {
    where: PlaceWhereUniqueInput
    create: XOR<PlaceCreateWithoutCreatorInput, PlaceUncheckedCreateWithoutCreatorInput>
  }

  export type PlaceCreateManyCreatorInputEnvelope = {
    data: PlaceCreateManyCreatorInput | PlaceCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type PlaceCreateWithoutUpdaterInput = {
    id?: string
    name: string
    description?: string | null
    location?: string | null
    status?: $Enums.PlaceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutPlacesInput
    subnet?: SubnetCreateNestedOneWithoutPlaceInput
    creator?: UserCreateNestedOneWithoutCreatedPlacesInput
  }

  export type PlaceUncheckedCreateWithoutUpdaterInput = {
    id?: string
    name: string
    description?: string | null
    tenantId: string
    subnetId?: string | null
    location?: string | null
    status?: $Enums.PlaceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
  }

  export type PlaceCreateOrConnectWithoutUpdaterInput = {
    where: PlaceWhereUniqueInput
    create: XOR<PlaceCreateWithoutUpdaterInput, PlaceUncheckedCreateWithoutUpdaterInput>
  }

  export type PlaceCreateManyUpdaterInputEnvelope = {
    data: PlaceCreateManyUpdaterInput | PlaceCreateManyUpdaterInput[]
    skipDuplicates?: boolean
  }

  export type SubnetCreateWithoutCreatorInput = {
    id?: string
    name: string
    cidrBlock: string
    availabilityZone?: string | null
    gateway?: string | null
    vlanId?: number | null
    isPublic?: boolean
    autoAssignIp?: boolean
    status?: $Enums.SubnetStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    vpc: VpcCreateNestedOneWithoutSubnetsInput
    place?: PlaceCreateNestedOneWithoutSubnetInput
    updater?: UserCreateNestedOneWithoutUpdatedSubnetsInput
  }

  export type SubnetUncheckedCreateWithoutCreatorInput = {
    id?: string
    name: string
    vpcId: string
    cidrBlock: string
    availabilityZone?: string | null
    gateway?: string | null
    vlanId?: number | null
    isPublic?: boolean
    autoAssignIp?: boolean
    status?: $Enums.SubnetStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
    place?: PlaceUncheckedCreateNestedOneWithoutSubnetInput
  }

  export type SubnetCreateOrConnectWithoutCreatorInput = {
    where: SubnetWhereUniqueInput
    create: XOR<SubnetCreateWithoutCreatorInput, SubnetUncheckedCreateWithoutCreatorInput>
  }

  export type SubnetCreateManyCreatorInputEnvelope = {
    data: SubnetCreateManyCreatorInput | SubnetCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type SubnetCreateWithoutUpdaterInput = {
    id?: string
    name: string
    cidrBlock: string
    availabilityZone?: string | null
    gateway?: string | null
    vlanId?: number | null
    isPublic?: boolean
    autoAssignIp?: boolean
    status?: $Enums.SubnetStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    vpc: VpcCreateNestedOneWithoutSubnetsInput
    place?: PlaceCreateNestedOneWithoutSubnetInput
    creator?: UserCreateNestedOneWithoutCreatedSubnetsInput
  }

  export type SubnetUncheckedCreateWithoutUpdaterInput = {
    id?: string
    name: string
    vpcId: string
    cidrBlock: string
    availabilityZone?: string | null
    gateway?: string | null
    vlanId?: number | null
    isPublic?: boolean
    autoAssignIp?: boolean
    status?: $Enums.SubnetStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    place?: PlaceUncheckedCreateNestedOneWithoutSubnetInput
  }

  export type SubnetCreateOrConnectWithoutUpdaterInput = {
    where: SubnetWhereUniqueInput
    create: XOR<SubnetCreateWithoutUpdaterInput, SubnetUncheckedCreateWithoutUpdaterInput>
  }

  export type SubnetCreateManyUpdaterInputEnvelope = {
    data: SubnetCreateManyUpdaterInput | SubnetCreateManyUpdaterInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutUserInput = {
    id?: string
    action: string
    resourceType: string
    resourceId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    status: string
    createdAt?: Date | string
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string
    action: string
    resourceType: string
    resourceId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    status: string
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutUsersInput = {
    update: XOR<TenantUpdateWithoutUsersInput, TenantUncheckedUpdateWithoutUsersInput>
    create: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutUsersInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutUsersInput, TenantUncheckedUpdateWithoutUsersInput>
  }

  export type TenantUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    vlanId?: NullableIntFieldUpdateOperationsInput | number | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userGroups?: UserGroupUpdateManyWithoutTenantNestedInput
    instances?: InstanceUpdateManyWithoutTenantNestedInput
    privateDataDisks?: PrivateDataDiskUpdateManyWithoutTenantNestedInput
    vpcs?: VpcUpdateManyWithoutTenantNestedInput
    places?: PlaceUpdateManyWithoutTenantNestedInput
    creator?: UserUpdateOneWithoutCreatedTenantsNestedInput
  }

  export type TenantUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    vlanId?: NullableIntFieldUpdateOperationsInput | number | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    userGroups?: UserGroupUncheckedUpdateManyWithoutTenantNestedInput
    instances?: InstanceUncheckedUpdateManyWithoutTenantNestedInput
    privateDataDisks?: PrivateDataDiskUncheckedUpdateManyWithoutTenantNestedInput
    vpcs?: VpcUncheckedUpdateManyWithoutTenantNestedInput
    places?: PlaceUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UserGroupMemberUpsertWithWhereUniqueWithoutUserInput = {
    where: UserGroupMemberWhereUniqueInput
    update: XOR<UserGroupMemberUpdateWithoutUserInput, UserGroupMemberUncheckedUpdateWithoutUserInput>
    create: XOR<UserGroupMemberCreateWithoutUserInput, UserGroupMemberUncheckedCreateWithoutUserInput>
  }

  export type UserGroupMemberUpdateWithWhereUniqueWithoutUserInput = {
    where: UserGroupMemberWhereUniqueInput
    data: XOR<UserGroupMemberUpdateWithoutUserInput, UserGroupMemberUncheckedUpdateWithoutUserInput>
  }

  export type UserGroupMemberUpdateManyWithWhereWithoutUserInput = {
    where: UserGroupMemberScalarWhereInput
    data: XOR<UserGroupMemberUpdateManyMutationInput, UserGroupMemberUncheckedUpdateManyWithoutUserInput>
  }

  export type UserGroupMemberScalarWhereInput = {
    AND?: UserGroupMemberScalarWhereInput | UserGroupMemberScalarWhereInput[]
    OR?: UserGroupMemberScalarWhereInput[]
    NOT?: UserGroupMemberScalarWhereInput | UserGroupMemberScalarWhereInput[]
    id?: UuidFilter<"UserGroupMember"> | string
    groupId?: UuidFilter<"UserGroupMember"> | string
    userId?: UuidFilter<"UserGroupMember"> | string
    joinedAt?: DateTimeFilter<"UserGroupMember"> | Date | string
    addedBy?: UuidNullableFilter<"UserGroupMember"> | string | null
  }

  export type InstanceUpsertWithWhereUniqueWithoutUserInput = {
    where: InstanceWhereUniqueInput
    update: XOR<InstanceUpdateWithoutUserInput, InstanceUncheckedUpdateWithoutUserInput>
    create: XOR<InstanceCreateWithoutUserInput, InstanceUncheckedCreateWithoutUserInput>
  }

  export type InstanceUpdateWithWhereUniqueWithoutUserInput = {
    where: InstanceWhereUniqueInput
    data: XOR<InstanceUpdateWithoutUserInput, InstanceUncheckedUpdateWithoutUserInput>
  }

  export type InstanceUpdateManyWithWhereWithoutUserInput = {
    where: InstanceScalarWhereInput
    data: XOR<InstanceUpdateManyMutationInput, InstanceUncheckedUpdateManyWithoutUserInput>
  }

  export type PrivateDataDiskUpsertWithWhereUniqueWithoutUserInput = {
    where: PrivateDataDiskWhereUniqueInput
    update: XOR<PrivateDataDiskUpdateWithoutUserInput, PrivateDataDiskUncheckedUpdateWithoutUserInput>
    create: XOR<PrivateDataDiskCreateWithoutUserInput, PrivateDataDiskUncheckedCreateWithoutUserInput>
  }

  export type PrivateDataDiskUpdateWithWhereUniqueWithoutUserInput = {
    where: PrivateDataDiskWhereUniqueInput
    data: XOR<PrivateDataDiskUpdateWithoutUserInput, PrivateDataDiskUncheckedUpdateWithoutUserInput>
  }

  export type PrivateDataDiskUpdateManyWithWhereWithoutUserInput = {
    where: PrivateDataDiskScalarWhereInput
    data: XOR<PrivateDataDiskUpdateManyMutationInput, PrivateDataDiskUncheckedUpdateManyWithoutUserInput>
  }

  export type TenantUpsertWithWhereUniqueWithoutCreatorInput = {
    where: TenantWhereUniqueInput
    update: XOR<TenantUpdateWithoutCreatorInput, TenantUncheckedUpdateWithoutCreatorInput>
    create: XOR<TenantCreateWithoutCreatorInput, TenantUncheckedCreateWithoutCreatorInput>
  }

  export type TenantUpdateWithWhereUniqueWithoutCreatorInput = {
    where: TenantWhereUniqueInput
    data: XOR<TenantUpdateWithoutCreatorInput, TenantUncheckedUpdateWithoutCreatorInput>
  }

  export type TenantUpdateManyWithWhereWithoutCreatorInput = {
    where: TenantScalarWhereInput
    data: XOR<TenantUpdateManyMutationInput, TenantUncheckedUpdateManyWithoutCreatorInput>
  }

  export type TenantScalarWhereInput = {
    AND?: TenantScalarWhereInput | TenantScalarWhereInput[]
    OR?: TenantScalarWhereInput[]
    NOT?: TenantScalarWhereInput | TenantScalarWhereInput[]
    id?: UuidFilter<"Tenant"> | string
    name?: StringFilter<"Tenant"> | string
    description?: StringNullableFilter<"Tenant"> | string | null
    status?: EnumTenantStatusFilter<"Tenant"> | $Enums.TenantStatus
    adminUserId?: UuidNullableFilter<"Tenant"> | string | null
    vlanId?: IntNullableFilter<"Tenant"> | number | null
    quotaConfig?: JsonNullableFilter<"Tenant">
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeFilter<"Tenant"> | Date | string
    createdBy?: UuidNullableFilter<"Tenant"> | string | null
  }

  export type VpcUpsertWithWhereUniqueWithoutUserInput = {
    where: VpcWhereUniqueInput
    update: XOR<VpcUpdateWithoutUserInput, VpcUncheckedUpdateWithoutUserInput>
    create: XOR<VpcCreateWithoutUserInput, VpcUncheckedCreateWithoutUserInput>
  }

  export type VpcUpdateWithWhereUniqueWithoutUserInput = {
    where: VpcWhereUniqueInput
    data: XOR<VpcUpdateWithoutUserInput, VpcUncheckedUpdateWithoutUserInput>
  }

  export type VpcUpdateManyWithWhereWithoutUserInput = {
    where: VpcScalarWhereInput
    data: XOR<VpcUpdateManyMutationInput, VpcUncheckedUpdateManyWithoutUserInput>
  }

  export type VpcUpsertWithWhereUniqueWithoutCreatorInput = {
    where: VpcWhereUniqueInput
    update: XOR<VpcUpdateWithoutCreatorInput, VpcUncheckedUpdateWithoutCreatorInput>
    create: XOR<VpcCreateWithoutCreatorInput, VpcUncheckedCreateWithoutCreatorInput>
  }

  export type VpcUpdateWithWhereUniqueWithoutCreatorInput = {
    where: VpcWhereUniqueInput
    data: XOR<VpcUpdateWithoutCreatorInput, VpcUncheckedUpdateWithoutCreatorInput>
  }

  export type VpcUpdateManyWithWhereWithoutCreatorInput = {
    where: VpcScalarWhereInput
    data: XOR<VpcUpdateManyMutationInput, VpcUncheckedUpdateManyWithoutCreatorInput>
  }

  export type VpcUpsertWithWhereUniqueWithoutUpdaterInput = {
    where: VpcWhereUniqueInput
    update: XOR<VpcUpdateWithoutUpdaterInput, VpcUncheckedUpdateWithoutUpdaterInput>
    create: XOR<VpcCreateWithoutUpdaterInput, VpcUncheckedCreateWithoutUpdaterInput>
  }

  export type VpcUpdateWithWhereUniqueWithoutUpdaterInput = {
    where: VpcWhereUniqueInput
    data: XOR<VpcUpdateWithoutUpdaterInput, VpcUncheckedUpdateWithoutUpdaterInput>
  }

  export type VpcUpdateManyWithWhereWithoutUpdaterInput = {
    where: VpcScalarWhereInput
    data: XOR<VpcUpdateManyMutationInput, VpcUncheckedUpdateManyWithoutUpdaterInput>
  }

  export type PlaceUpsertWithWhereUniqueWithoutCreatorInput = {
    where: PlaceWhereUniqueInput
    update: XOR<PlaceUpdateWithoutCreatorInput, PlaceUncheckedUpdateWithoutCreatorInput>
    create: XOR<PlaceCreateWithoutCreatorInput, PlaceUncheckedCreateWithoutCreatorInput>
  }

  export type PlaceUpdateWithWhereUniqueWithoutCreatorInput = {
    where: PlaceWhereUniqueInput
    data: XOR<PlaceUpdateWithoutCreatorInput, PlaceUncheckedUpdateWithoutCreatorInput>
  }

  export type PlaceUpdateManyWithWhereWithoutCreatorInput = {
    where: PlaceScalarWhereInput
    data: XOR<PlaceUpdateManyMutationInput, PlaceUncheckedUpdateManyWithoutCreatorInput>
  }

  export type PlaceUpsertWithWhereUniqueWithoutUpdaterInput = {
    where: PlaceWhereUniqueInput
    update: XOR<PlaceUpdateWithoutUpdaterInput, PlaceUncheckedUpdateWithoutUpdaterInput>
    create: XOR<PlaceCreateWithoutUpdaterInput, PlaceUncheckedCreateWithoutUpdaterInput>
  }

  export type PlaceUpdateWithWhereUniqueWithoutUpdaterInput = {
    where: PlaceWhereUniqueInput
    data: XOR<PlaceUpdateWithoutUpdaterInput, PlaceUncheckedUpdateWithoutUpdaterInput>
  }

  export type PlaceUpdateManyWithWhereWithoutUpdaterInput = {
    where: PlaceScalarWhereInput
    data: XOR<PlaceUpdateManyMutationInput, PlaceUncheckedUpdateManyWithoutUpdaterInput>
  }

  export type SubnetUpsertWithWhereUniqueWithoutCreatorInput = {
    where: SubnetWhereUniqueInput
    update: XOR<SubnetUpdateWithoutCreatorInput, SubnetUncheckedUpdateWithoutCreatorInput>
    create: XOR<SubnetCreateWithoutCreatorInput, SubnetUncheckedCreateWithoutCreatorInput>
  }

  export type SubnetUpdateWithWhereUniqueWithoutCreatorInput = {
    where: SubnetWhereUniqueInput
    data: XOR<SubnetUpdateWithoutCreatorInput, SubnetUncheckedUpdateWithoutCreatorInput>
  }

  export type SubnetUpdateManyWithWhereWithoutCreatorInput = {
    where: SubnetScalarWhereInput
    data: XOR<SubnetUpdateManyMutationInput, SubnetUncheckedUpdateManyWithoutCreatorInput>
  }

  export type SubnetScalarWhereInput = {
    AND?: SubnetScalarWhereInput | SubnetScalarWhereInput[]
    OR?: SubnetScalarWhereInput[]
    NOT?: SubnetScalarWhereInput | SubnetScalarWhereInput[]
    id?: UuidFilter<"Subnet"> | string
    name?: StringFilter<"Subnet"> | string
    vpcId?: UuidFilter<"Subnet"> | string
    cidrBlock?: StringFilter<"Subnet"> | string
    availabilityZone?: StringNullableFilter<"Subnet"> | string | null
    gateway?: StringNullableFilter<"Subnet"> | string | null
    vlanId?: IntNullableFilter<"Subnet"> | number | null
    isPublic?: BoolFilter<"Subnet"> | boolean
    autoAssignIp?: BoolFilter<"Subnet"> | boolean
    status?: EnumSubnetStatusFilter<"Subnet"> | $Enums.SubnetStatus
    createdAt?: DateTimeFilter<"Subnet"> | Date | string
    updatedAt?: DateTimeFilter<"Subnet"> | Date | string
    createdBy?: UuidNullableFilter<"Subnet"> | string | null
    updatedBy?: UuidNullableFilter<"Subnet"> | string | null
  }

  export type SubnetUpsertWithWhereUniqueWithoutUpdaterInput = {
    where: SubnetWhereUniqueInput
    update: XOR<SubnetUpdateWithoutUpdaterInput, SubnetUncheckedUpdateWithoutUpdaterInput>
    create: XOR<SubnetCreateWithoutUpdaterInput, SubnetUncheckedCreateWithoutUpdaterInput>
  }

  export type SubnetUpdateWithWhereUniqueWithoutUpdaterInput = {
    where: SubnetWhereUniqueInput
    data: XOR<SubnetUpdateWithoutUpdaterInput, SubnetUncheckedUpdateWithoutUpdaterInput>
  }

  export type SubnetUpdateManyWithWhereWithoutUpdaterInput = {
    where: SubnetScalarWhereInput
    data: XOR<SubnetUpdateManyMutationInput, SubnetUncheckedUpdateManyWithoutUpdaterInput>
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: UuidFilter<"AuditLog"> | string
    userId?: UuidFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    resourceType?: StringFilter<"AuditLog"> | string
    resourceId?: UuidNullableFilter<"AuditLog"> | string | null
    details?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    status?: StringFilter<"AuditLog"> | string
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type TenantCreateWithoutUserGroupsInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.TenantStatus
    adminUserId?: string | null
    vlanId?: number | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    instances?: InstanceCreateNestedManyWithoutTenantInput
    privateDataDisks?: PrivateDataDiskCreateNestedManyWithoutTenantInput
    vpcs?: VpcCreateNestedManyWithoutTenantInput
    places?: PlaceCreateNestedManyWithoutTenantInput
    creator?: UserCreateNestedOneWithoutCreatedTenantsInput
  }

  export type TenantUncheckedCreateWithoutUserGroupsInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.TenantStatus
    adminUserId?: string | null
    vlanId?: number | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    instances?: InstanceUncheckedCreateNestedManyWithoutTenantInput
    privateDataDisks?: PrivateDataDiskUncheckedCreateNestedManyWithoutTenantInput
    vpcs?: VpcUncheckedCreateNestedManyWithoutTenantInput
    places?: PlaceUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutUserGroupsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutUserGroupsInput, TenantUncheckedCreateWithoutUserGroupsInput>
  }

  export type UserGroupCreateWithoutChildGroupsInput = {
    id?: string
    name: string
    description?: string | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutUserGroupsInput
    parentGroup?: UserGroupCreateNestedOneWithoutChildGroupsInput
    members?: UserGroupMemberCreateNestedManyWithoutGroupInput
  }

  export type UserGroupUncheckedCreateWithoutChildGroupsInput = {
    id?: string
    name: string
    description?: string | null
    tenantId: string
    parentGroupId?: string | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: UserGroupMemberUncheckedCreateNestedManyWithoutGroupInput
  }

  export type UserGroupCreateOrConnectWithoutChildGroupsInput = {
    where: UserGroupWhereUniqueInput
    create: XOR<UserGroupCreateWithoutChildGroupsInput, UserGroupUncheckedCreateWithoutChildGroupsInput>
  }

  export type UserGroupCreateWithoutParentGroupInput = {
    id?: string
    name: string
    description?: string | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutUserGroupsInput
    childGroups?: UserGroupCreateNestedManyWithoutParentGroupInput
    members?: UserGroupMemberCreateNestedManyWithoutGroupInput
  }

  export type UserGroupUncheckedCreateWithoutParentGroupInput = {
    id?: string
    name: string
    description?: string | null
    tenantId: string
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    childGroups?: UserGroupUncheckedCreateNestedManyWithoutParentGroupInput
    members?: UserGroupMemberUncheckedCreateNestedManyWithoutGroupInput
  }

  export type UserGroupCreateOrConnectWithoutParentGroupInput = {
    where: UserGroupWhereUniqueInput
    create: XOR<UserGroupCreateWithoutParentGroupInput, UserGroupUncheckedCreateWithoutParentGroupInput>
  }

  export type UserGroupCreateManyParentGroupInputEnvelope = {
    data: UserGroupCreateManyParentGroupInput | UserGroupCreateManyParentGroupInput[]
    skipDuplicates?: boolean
  }

  export type UserGroupMemberCreateWithoutGroupInput = {
    id?: string
    joinedAt?: Date | string
    addedBy?: string | null
    user: UserCreateNestedOneWithoutGroupMembershipsInput
  }

  export type UserGroupMemberUncheckedCreateWithoutGroupInput = {
    id?: string
    userId: string
    joinedAt?: Date | string
    addedBy?: string | null
  }

  export type UserGroupMemberCreateOrConnectWithoutGroupInput = {
    where: UserGroupMemberWhereUniqueInput
    create: XOR<UserGroupMemberCreateWithoutGroupInput, UserGroupMemberUncheckedCreateWithoutGroupInput>
  }

  export type UserGroupMemberCreateManyGroupInputEnvelope = {
    data: UserGroupMemberCreateManyGroupInput | UserGroupMemberCreateManyGroupInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutUserGroupsInput = {
    update: XOR<TenantUpdateWithoutUserGroupsInput, TenantUncheckedUpdateWithoutUserGroupsInput>
    create: XOR<TenantCreateWithoutUserGroupsInput, TenantUncheckedCreateWithoutUserGroupsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutUserGroupsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutUserGroupsInput, TenantUncheckedUpdateWithoutUserGroupsInput>
  }

  export type TenantUpdateWithoutUserGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    vlanId?: NullableIntFieldUpdateOperationsInput | number | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    instances?: InstanceUpdateManyWithoutTenantNestedInput
    privateDataDisks?: PrivateDataDiskUpdateManyWithoutTenantNestedInput
    vpcs?: VpcUpdateManyWithoutTenantNestedInput
    places?: PlaceUpdateManyWithoutTenantNestedInput
    creator?: UserUpdateOneWithoutCreatedTenantsNestedInput
  }

  export type TenantUncheckedUpdateWithoutUserGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    vlanId?: NullableIntFieldUpdateOperationsInput | number | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    instances?: InstanceUncheckedUpdateManyWithoutTenantNestedInput
    privateDataDisks?: PrivateDataDiskUncheckedUpdateManyWithoutTenantNestedInput
    vpcs?: VpcUncheckedUpdateManyWithoutTenantNestedInput
    places?: PlaceUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UserGroupUpsertWithoutChildGroupsInput = {
    update: XOR<UserGroupUpdateWithoutChildGroupsInput, UserGroupUncheckedUpdateWithoutChildGroupsInput>
    create: XOR<UserGroupCreateWithoutChildGroupsInput, UserGroupUncheckedCreateWithoutChildGroupsInput>
    where?: UserGroupWhereInput
  }

  export type UserGroupUpdateToOneWithWhereWithoutChildGroupsInput = {
    where?: UserGroupWhereInput
    data: XOR<UserGroupUpdateWithoutChildGroupsInput, UserGroupUncheckedUpdateWithoutChildGroupsInput>
  }

  export type UserGroupUpdateWithoutChildGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutUserGroupsNestedInput
    parentGroup?: UserGroupUpdateOneWithoutChildGroupsNestedInput
    members?: UserGroupMemberUpdateManyWithoutGroupNestedInput
  }

  export type UserGroupUncheckedUpdateWithoutChildGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    parentGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: UserGroupMemberUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type UserGroupUpsertWithWhereUniqueWithoutParentGroupInput = {
    where: UserGroupWhereUniqueInput
    update: XOR<UserGroupUpdateWithoutParentGroupInput, UserGroupUncheckedUpdateWithoutParentGroupInput>
    create: XOR<UserGroupCreateWithoutParentGroupInput, UserGroupUncheckedCreateWithoutParentGroupInput>
  }

  export type UserGroupUpdateWithWhereUniqueWithoutParentGroupInput = {
    where: UserGroupWhereUniqueInput
    data: XOR<UserGroupUpdateWithoutParentGroupInput, UserGroupUncheckedUpdateWithoutParentGroupInput>
  }

  export type UserGroupUpdateManyWithWhereWithoutParentGroupInput = {
    where: UserGroupScalarWhereInput
    data: XOR<UserGroupUpdateManyMutationInput, UserGroupUncheckedUpdateManyWithoutParentGroupInput>
  }

  export type UserGroupMemberUpsertWithWhereUniqueWithoutGroupInput = {
    where: UserGroupMemberWhereUniqueInput
    update: XOR<UserGroupMemberUpdateWithoutGroupInput, UserGroupMemberUncheckedUpdateWithoutGroupInput>
    create: XOR<UserGroupMemberCreateWithoutGroupInput, UserGroupMemberUncheckedCreateWithoutGroupInput>
  }

  export type UserGroupMemberUpdateWithWhereUniqueWithoutGroupInput = {
    where: UserGroupMemberWhereUniqueInput
    data: XOR<UserGroupMemberUpdateWithoutGroupInput, UserGroupMemberUncheckedUpdateWithoutGroupInput>
  }

  export type UserGroupMemberUpdateManyWithWhereWithoutGroupInput = {
    where: UserGroupMemberScalarWhereInput
    data: XOR<UserGroupMemberUpdateManyMutationInput, UserGroupMemberUncheckedUpdateManyWithoutGroupInput>
  }

  export type UserGroupCreateWithoutMembersInput = {
    id?: string
    name: string
    description?: string | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutUserGroupsInput
    parentGroup?: UserGroupCreateNestedOneWithoutChildGroupsInput
    childGroups?: UserGroupCreateNestedManyWithoutParentGroupInput
  }

  export type UserGroupUncheckedCreateWithoutMembersInput = {
    id?: string
    name: string
    description?: string | null
    tenantId: string
    parentGroupId?: string | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    childGroups?: UserGroupUncheckedCreateNestedManyWithoutParentGroupInput
  }

  export type UserGroupCreateOrConnectWithoutMembersInput = {
    where: UserGroupWhereUniqueInput
    create: XOR<UserGroupCreateWithoutMembersInput, UserGroupUncheckedCreateWithoutMembersInput>
  }

  export type UserCreateWithoutGroupMembershipsInput = {
    id?: string
    username: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant?: TenantCreateNestedOneWithoutUsersInput
    instances?: InstanceCreateNestedManyWithoutUserInput
    privateDataDisks?: PrivateDataDiskCreateNestedManyWithoutUserInput
    createdTenants?: TenantCreateNestedManyWithoutCreatorInput
    vpcs?: VpcCreateNestedManyWithoutUserInput
    createdVpcs?: VpcCreateNestedManyWithoutCreatorInput
    updatedVpcs?: VpcCreateNestedManyWithoutUpdaterInput
    createdPlaces?: PlaceCreateNestedManyWithoutCreatorInput
    updatedPlaces?: PlaceCreateNestedManyWithoutUpdaterInput
    createdSubnets?: SubnetCreateNestedManyWithoutCreatorInput
    updatedSubnets?: SubnetCreateNestedManyWithoutUpdaterInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutGroupMembershipsInput = {
    id?: string
    username: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    tenantId?: string | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    instances?: InstanceUncheckedCreateNestedManyWithoutUserInput
    privateDataDisks?: PrivateDataDiskUncheckedCreateNestedManyWithoutUserInput
    createdTenants?: TenantUncheckedCreateNestedManyWithoutCreatorInput
    vpcs?: VpcUncheckedCreateNestedManyWithoutUserInput
    createdVpcs?: VpcUncheckedCreateNestedManyWithoutCreatorInput
    updatedVpcs?: VpcUncheckedCreateNestedManyWithoutUpdaterInput
    createdPlaces?: PlaceUncheckedCreateNestedManyWithoutCreatorInput
    updatedPlaces?: PlaceUncheckedCreateNestedManyWithoutUpdaterInput
    createdSubnets?: SubnetUncheckedCreateNestedManyWithoutCreatorInput
    updatedSubnets?: SubnetUncheckedCreateNestedManyWithoutUpdaterInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutGroupMembershipsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGroupMembershipsInput, UserUncheckedCreateWithoutGroupMembershipsInput>
  }

  export type UserGroupUpsertWithoutMembersInput = {
    update: XOR<UserGroupUpdateWithoutMembersInput, UserGroupUncheckedUpdateWithoutMembersInput>
    create: XOR<UserGroupCreateWithoutMembersInput, UserGroupUncheckedCreateWithoutMembersInput>
    where?: UserGroupWhereInput
  }

  export type UserGroupUpdateToOneWithWhereWithoutMembersInput = {
    where?: UserGroupWhereInput
    data: XOR<UserGroupUpdateWithoutMembersInput, UserGroupUncheckedUpdateWithoutMembersInput>
  }

  export type UserGroupUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutUserGroupsNestedInput
    parentGroup?: UserGroupUpdateOneWithoutChildGroupsNestedInput
    childGroups?: UserGroupUpdateManyWithoutParentGroupNestedInput
  }

  export type UserGroupUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    parentGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    childGroups?: UserGroupUncheckedUpdateManyWithoutParentGroupNestedInput
  }

  export type UserUpsertWithoutGroupMembershipsInput = {
    update: XOR<UserUpdateWithoutGroupMembershipsInput, UserUncheckedUpdateWithoutGroupMembershipsInput>
    create: XOR<UserCreateWithoutGroupMembershipsInput, UserUncheckedCreateWithoutGroupMembershipsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutGroupMembershipsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutGroupMembershipsInput, UserUncheckedUpdateWithoutGroupMembershipsInput>
  }

  export type UserUpdateWithoutGroupMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutUsersNestedInput
    instances?: InstanceUpdateManyWithoutUserNestedInput
    privateDataDisks?: PrivateDataDiskUpdateManyWithoutUserNestedInput
    createdTenants?: TenantUpdateManyWithoutCreatorNestedInput
    vpcs?: VpcUpdateManyWithoutUserNestedInput
    createdVpcs?: VpcUpdateManyWithoutCreatorNestedInput
    updatedVpcs?: VpcUpdateManyWithoutUpdaterNestedInput
    createdPlaces?: PlaceUpdateManyWithoutCreatorNestedInput
    updatedPlaces?: PlaceUpdateManyWithoutUpdaterNestedInput
    createdSubnets?: SubnetUpdateManyWithoutCreatorNestedInput
    updatedSubnets?: SubnetUpdateManyWithoutUpdaterNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutGroupMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instances?: InstanceUncheckedUpdateManyWithoutUserNestedInput
    privateDataDisks?: PrivateDataDiskUncheckedUpdateManyWithoutUserNestedInput
    createdTenants?: TenantUncheckedUpdateManyWithoutCreatorNestedInput
    vpcs?: VpcUncheckedUpdateManyWithoutUserNestedInput
    createdVpcs?: VpcUncheckedUpdateManyWithoutCreatorNestedInput
    updatedVpcs?: VpcUncheckedUpdateManyWithoutUpdaterNestedInput
    createdPlaces?: PlaceUncheckedUpdateManyWithoutCreatorNestedInput
    updatedPlaces?: PlaceUncheckedUpdateManyWithoutUpdaterNestedInput
    createdSubnets?: SubnetUncheckedUpdateManyWithoutCreatorNestedInput
    updatedSubnets?: SubnetUncheckedUpdateManyWithoutUpdaterNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RolePermissionCreateWithoutPermissionInput = {
    id?: string
    role: $Enums.UserRole
  }

  export type RolePermissionUncheckedCreateWithoutPermissionInput = {
    id?: string
    role: $Enums.UserRole
  }

  export type RolePermissionCreateOrConnectWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput
    create: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput>
  }

  export type RolePermissionCreateManyPermissionInputEnvelope = {
    data: RolePermissionCreateManyPermissionInput | RolePermissionCreateManyPermissionInput[]
    skipDuplicates?: boolean
  }

  export type RolePermissionUpsertWithWhereUniqueWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput
    update: XOR<RolePermissionUpdateWithoutPermissionInput, RolePermissionUncheckedUpdateWithoutPermissionInput>
    create: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput>
  }

  export type RolePermissionUpdateWithWhereUniqueWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput
    data: XOR<RolePermissionUpdateWithoutPermissionInput, RolePermissionUncheckedUpdateWithoutPermissionInput>
  }

  export type RolePermissionUpdateManyWithWhereWithoutPermissionInput = {
    where: RolePermissionScalarWhereInput
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyWithoutPermissionInput>
  }

  export type RolePermissionScalarWhereInput = {
    AND?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
    OR?: RolePermissionScalarWhereInput[]
    NOT?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
    id?: UuidFilter<"RolePermission"> | string
    role?: EnumUserRoleFilter<"RolePermission"> | $Enums.UserRole
    permissionId?: UuidFilter<"RolePermission"> | string
  }

  export type PermissionCreateWithoutRolePermissionsInput = {
    id?: string
    resourceType: $Enums.ResourceType
    action: $Enums.PermissionAction
    permissionName: string
    description?: string | null
    createdAt?: Date | string
  }

  export type PermissionUncheckedCreateWithoutRolePermissionsInput = {
    id?: string
    resourceType: $Enums.ResourceType
    action: $Enums.PermissionAction
    permissionName: string
    description?: string | null
    createdAt?: Date | string
  }

  export type PermissionCreateOrConnectWithoutRolePermissionsInput = {
    where: PermissionWhereUniqueInput
    create: XOR<PermissionCreateWithoutRolePermissionsInput, PermissionUncheckedCreateWithoutRolePermissionsInput>
  }

  export type PermissionUpsertWithoutRolePermissionsInput = {
    update: XOR<PermissionUpdateWithoutRolePermissionsInput, PermissionUncheckedUpdateWithoutRolePermissionsInput>
    create: XOR<PermissionCreateWithoutRolePermissionsInput, PermissionUncheckedCreateWithoutRolePermissionsInput>
    where?: PermissionWhereInput
  }

  export type PermissionUpdateToOneWithWhereWithoutRolePermissionsInput = {
    where?: PermissionWhereInput
    data: XOR<PermissionUpdateWithoutRolePermissionsInput, PermissionUncheckedUpdateWithoutRolePermissionsInput>
  }

  export type PermissionUpdateWithoutRolePermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    resourceType?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    action?: EnumPermissionActionFieldUpdateOperationsInput | $Enums.PermissionAction
    permissionName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionUncheckedUpdateWithoutRolePermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    resourceType?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    action?: EnumPermissionActionFieldUpdateOperationsInput | $Enums.PermissionAction
    permissionName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantCreateWithoutInstancesInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.TenantStatus
    adminUserId?: string | null
    vlanId?: number | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    userGroups?: UserGroupCreateNestedManyWithoutTenantInput
    privateDataDisks?: PrivateDataDiskCreateNestedManyWithoutTenantInput
    vpcs?: VpcCreateNestedManyWithoutTenantInput
    places?: PlaceCreateNestedManyWithoutTenantInput
    creator?: UserCreateNestedOneWithoutCreatedTenantsInput
  }

  export type TenantUncheckedCreateWithoutInstancesInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.TenantStatus
    adminUserId?: string | null
    vlanId?: number | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    userGroups?: UserGroupUncheckedCreateNestedManyWithoutTenantInput
    privateDataDisks?: PrivateDataDiskUncheckedCreateNestedManyWithoutTenantInput
    vpcs?: VpcUncheckedCreateNestedManyWithoutTenantInput
    places?: PlaceUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutInstancesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutInstancesInput, TenantUncheckedCreateWithoutInstancesInput>
  }

  export type UserCreateWithoutInstancesInput = {
    id?: string
    username: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant?: TenantCreateNestedOneWithoutUsersInput
    groupMemberships?: UserGroupMemberCreateNestedManyWithoutUserInput
    privateDataDisks?: PrivateDataDiskCreateNestedManyWithoutUserInput
    createdTenants?: TenantCreateNestedManyWithoutCreatorInput
    vpcs?: VpcCreateNestedManyWithoutUserInput
    createdVpcs?: VpcCreateNestedManyWithoutCreatorInput
    updatedVpcs?: VpcCreateNestedManyWithoutUpdaterInput
    createdPlaces?: PlaceCreateNestedManyWithoutCreatorInput
    updatedPlaces?: PlaceCreateNestedManyWithoutUpdaterInput
    createdSubnets?: SubnetCreateNestedManyWithoutCreatorInput
    updatedSubnets?: SubnetCreateNestedManyWithoutUpdaterInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInstancesInput = {
    id?: string
    username: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    tenantId?: string | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    groupMemberships?: UserGroupMemberUncheckedCreateNestedManyWithoutUserInput
    privateDataDisks?: PrivateDataDiskUncheckedCreateNestedManyWithoutUserInput
    createdTenants?: TenantUncheckedCreateNestedManyWithoutCreatorInput
    vpcs?: VpcUncheckedCreateNestedManyWithoutUserInput
    createdVpcs?: VpcUncheckedCreateNestedManyWithoutCreatorInput
    updatedVpcs?: VpcUncheckedCreateNestedManyWithoutUpdaterInput
    createdPlaces?: PlaceUncheckedCreateNestedManyWithoutCreatorInput
    updatedPlaces?: PlaceUncheckedCreateNestedManyWithoutUpdaterInput
    createdSubnets?: SubnetUncheckedCreateNestedManyWithoutCreatorInput
    updatedSubnets?: SubnetUncheckedCreateNestedManyWithoutUpdaterInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInstancesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInstancesInput, UserUncheckedCreateWithoutInstancesInput>
  }

  export type TenantUpsertWithoutInstancesInput = {
    update: XOR<TenantUpdateWithoutInstancesInput, TenantUncheckedUpdateWithoutInstancesInput>
    create: XOR<TenantCreateWithoutInstancesInput, TenantUncheckedCreateWithoutInstancesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutInstancesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutInstancesInput, TenantUncheckedUpdateWithoutInstancesInput>
  }

  export type TenantUpdateWithoutInstancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    vlanId?: NullableIntFieldUpdateOperationsInput | number | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    userGroups?: UserGroupUpdateManyWithoutTenantNestedInput
    privateDataDisks?: PrivateDataDiskUpdateManyWithoutTenantNestedInput
    vpcs?: VpcUpdateManyWithoutTenantNestedInput
    places?: PlaceUpdateManyWithoutTenantNestedInput
    creator?: UserUpdateOneWithoutCreatedTenantsNestedInput
  }

  export type TenantUncheckedUpdateWithoutInstancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    vlanId?: NullableIntFieldUpdateOperationsInput | number | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    userGroups?: UserGroupUncheckedUpdateManyWithoutTenantNestedInput
    privateDataDisks?: PrivateDataDiskUncheckedUpdateManyWithoutTenantNestedInput
    vpcs?: VpcUncheckedUpdateManyWithoutTenantNestedInput
    places?: PlaceUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UserUpsertWithoutInstancesInput = {
    update: XOR<UserUpdateWithoutInstancesInput, UserUncheckedUpdateWithoutInstancesInput>
    create: XOR<UserCreateWithoutInstancesInput, UserUncheckedCreateWithoutInstancesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInstancesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInstancesInput, UserUncheckedUpdateWithoutInstancesInput>
  }

  export type UserUpdateWithoutInstancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutUsersNestedInput
    groupMemberships?: UserGroupMemberUpdateManyWithoutUserNestedInput
    privateDataDisks?: PrivateDataDiskUpdateManyWithoutUserNestedInput
    createdTenants?: TenantUpdateManyWithoutCreatorNestedInput
    vpcs?: VpcUpdateManyWithoutUserNestedInput
    createdVpcs?: VpcUpdateManyWithoutCreatorNestedInput
    updatedVpcs?: VpcUpdateManyWithoutUpdaterNestedInput
    createdPlaces?: PlaceUpdateManyWithoutCreatorNestedInput
    updatedPlaces?: PlaceUpdateManyWithoutUpdaterNestedInput
    createdSubnets?: SubnetUpdateManyWithoutCreatorNestedInput
    updatedSubnets?: SubnetUpdateManyWithoutUpdaterNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInstancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groupMemberships?: UserGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    privateDataDisks?: PrivateDataDiskUncheckedUpdateManyWithoutUserNestedInput
    createdTenants?: TenantUncheckedUpdateManyWithoutCreatorNestedInput
    vpcs?: VpcUncheckedUpdateManyWithoutUserNestedInput
    createdVpcs?: VpcUncheckedUpdateManyWithoutCreatorNestedInput
    updatedVpcs?: VpcUncheckedUpdateManyWithoutUpdaterNestedInput
    createdPlaces?: PlaceUncheckedUpdateManyWithoutCreatorNestedInput
    updatedPlaces?: PlaceUncheckedUpdateManyWithoutUpdaterNestedInput
    createdSubnets?: SubnetUncheckedUpdateManyWithoutCreatorNestedInput
    updatedSubnets?: SubnetUncheckedUpdateManyWithoutUpdaterNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TenantCreateWithoutPrivateDataDisksInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.TenantStatus
    adminUserId?: string | null
    vlanId?: number | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    userGroups?: UserGroupCreateNestedManyWithoutTenantInput
    instances?: InstanceCreateNestedManyWithoutTenantInput
    vpcs?: VpcCreateNestedManyWithoutTenantInput
    places?: PlaceCreateNestedManyWithoutTenantInput
    creator?: UserCreateNestedOneWithoutCreatedTenantsInput
  }

  export type TenantUncheckedCreateWithoutPrivateDataDisksInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.TenantStatus
    adminUserId?: string | null
    vlanId?: number | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    userGroups?: UserGroupUncheckedCreateNestedManyWithoutTenantInput
    instances?: InstanceUncheckedCreateNestedManyWithoutTenantInput
    vpcs?: VpcUncheckedCreateNestedManyWithoutTenantInput
    places?: PlaceUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutPrivateDataDisksInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutPrivateDataDisksInput, TenantUncheckedCreateWithoutPrivateDataDisksInput>
  }

  export type UserCreateWithoutPrivateDataDisksInput = {
    id?: string
    username: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant?: TenantCreateNestedOneWithoutUsersInput
    groupMemberships?: UserGroupMemberCreateNestedManyWithoutUserInput
    instances?: InstanceCreateNestedManyWithoutUserInput
    createdTenants?: TenantCreateNestedManyWithoutCreatorInput
    vpcs?: VpcCreateNestedManyWithoutUserInput
    createdVpcs?: VpcCreateNestedManyWithoutCreatorInput
    updatedVpcs?: VpcCreateNestedManyWithoutUpdaterInput
    createdPlaces?: PlaceCreateNestedManyWithoutCreatorInput
    updatedPlaces?: PlaceCreateNestedManyWithoutUpdaterInput
    createdSubnets?: SubnetCreateNestedManyWithoutCreatorInput
    updatedSubnets?: SubnetCreateNestedManyWithoutUpdaterInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPrivateDataDisksInput = {
    id?: string
    username: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    tenantId?: string | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    groupMemberships?: UserGroupMemberUncheckedCreateNestedManyWithoutUserInput
    instances?: InstanceUncheckedCreateNestedManyWithoutUserInput
    createdTenants?: TenantUncheckedCreateNestedManyWithoutCreatorInput
    vpcs?: VpcUncheckedCreateNestedManyWithoutUserInput
    createdVpcs?: VpcUncheckedCreateNestedManyWithoutCreatorInput
    updatedVpcs?: VpcUncheckedCreateNestedManyWithoutUpdaterInput
    createdPlaces?: PlaceUncheckedCreateNestedManyWithoutCreatorInput
    updatedPlaces?: PlaceUncheckedCreateNestedManyWithoutUpdaterInput
    createdSubnets?: SubnetUncheckedCreateNestedManyWithoutCreatorInput
    updatedSubnets?: SubnetUncheckedCreateNestedManyWithoutUpdaterInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPrivateDataDisksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPrivateDataDisksInput, UserUncheckedCreateWithoutPrivateDataDisksInput>
  }

  export type TenantUpsertWithoutPrivateDataDisksInput = {
    update: XOR<TenantUpdateWithoutPrivateDataDisksInput, TenantUncheckedUpdateWithoutPrivateDataDisksInput>
    create: XOR<TenantCreateWithoutPrivateDataDisksInput, TenantUncheckedCreateWithoutPrivateDataDisksInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutPrivateDataDisksInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutPrivateDataDisksInput, TenantUncheckedUpdateWithoutPrivateDataDisksInput>
  }

  export type TenantUpdateWithoutPrivateDataDisksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    vlanId?: NullableIntFieldUpdateOperationsInput | number | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    userGroups?: UserGroupUpdateManyWithoutTenantNestedInput
    instances?: InstanceUpdateManyWithoutTenantNestedInput
    vpcs?: VpcUpdateManyWithoutTenantNestedInput
    places?: PlaceUpdateManyWithoutTenantNestedInput
    creator?: UserUpdateOneWithoutCreatedTenantsNestedInput
  }

  export type TenantUncheckedUpdateWithoutPrivateDataDisksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    vlanId?: NullableIntFieldUpdateOperationsInput | number | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    userGroups?: UserGroupUncheckedUpdateManyWithoutTenantNestedInput
    instances?: InstanceUncheckedUpdateManyWithoutTenantNestedInput
    vpcs?: VpcUncheckedUpdateManyWithoutTenantNestedInput
    places?: PlaceUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UserUpsertWithoutPrivateDataDisksInput = {
    update: XOR<UserUpdateWithoutPrivateDataDisksInput, UserUncheckedUpdateWithoutPrivateDataDisksInput>
    create: XOR<UserCreateWithoutPrivateDataDisksInput, UserUncheckedCreateWithoutPrivateDataDisksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPrivateDataDisksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPrivateDataDisksInput, UserUncheckedUpdateWithoutPrivateDataDisksInput>
  }

  export type UserUpdateWithoutPrivateDataDisksInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutUsersNestedInput
    groupMemberships?: UserGroupMemberUpdateManyWithoutUserNestedInput
    instances?: InstanceUpdateManyWithoutUserNestedInput
    createdTenants?: TenantUpdateManyWithoutCreatorNestedInput
    vpcs?: VpcUpdateManyWithoutUserNestedInput
    createdVpcs?: VpcUpdateManyWithoutCreatorNestedInput
    updatedVpcs?: VpcUpdateManyWithoutUpdaterNestedInput
    createdPlaces?: PlaceUpdateManyWithoutCreatorNestedInput
    updatedPlaces?: PlaceUpdateManyWithoutUpdaterNestedInput
    createdSubnets?: SubnetUpdateManyWithoutCreatorNestedInput
    updatedSubnets?: SubnetUpdateManyWithoutUpdaterNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPrivateDataDisksInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groupMemberships?: UserGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    instances?: InstanceUncheckedUpdateManyWithoutUserNestedInput
    createdTenants?: TenantUncheckedUpdateManyWithoutCreatorNestedInput
    vpcs?: VpcUncheckedUpdateManyWithoutUserNestedInput
    createdVpcs?: VpcUncheckedUpdateManyWithoutCreatorNestedInput
    updatedVpcs?: VpcUncheckedUpdateManyWithoutUpdaterNestedInput
    createdPlaces?: PlaceUncheckedUpdateManyWithoutCreatorNestedInput
    updatedPlaces?: PlaceUncheckedUpdateManyWithoutUpdaterNestedInput
    createdSubnets?: SubnetUncheckedUpdateManyWithoutCreatorNestedInput
    updatedSubnets?: SubnetUncheckedUpdateManyWithoutUpdaterNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TenantCreateWithoutVpcsInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.TenantStatus
    adminUserId?: string | null
    vlanId?: number | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    userGroups?: UserGroupCreateNestedManyWithoutTenantInput
    instances?: InstanceCreateNestedManyWithoutTenantInput
    privateDataDisks?: PrivateDataDiskCreateNestedManyWithoutTenantInput
    places?: PlaceCreateNestedManyWithoutTenantInput
    creator?: UserCreateNestedOneWithoutCreatedTenantsInput
  }

  export type TenantUncheckedCreateWithoutVpcsInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.TenantStatus
    adminUserId?: string | null
    vlanId?: number | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    userGroups?: UserGroupUncheckedCreateNestedManyWithoutTenantInput
    instances?: InstanceUncheckedCreateNestedManyWithoutTenantInput
    privateDataDisks?: PrivateDataDiskUncheckedCreateNestedManyWithoutTenantInput
    places?: PlaceUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutVpcsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutVpcsInput, TenantUncheckedCreateWithoutVpcsInput>
  }

  export type UserCreateWithoutVpcsInput = {
    id?: string
    username: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant?: TenantCreateNestedOneWithoutUsersInput
    groupMemberships?: UserGroupMemberCreateNestedManyWithoutUserInput
    instances?: InstanceCreateNestedManyWithoutUserInput
    privateDataDisks?: PrivateDataDiskCreateNestedManyWithoutUserInput
    createdTenants?: TenantCreateNestedManyWithoutCreatorInput
    createdVpcs?: VpcCreateNestedManyWithoutCreatorInput
    updatedVpcs?: VpcCreateNestedManyWithoutUpdaterInput
    createdPlaces?: PlaceCreateNestedManyWithoutCreatorInput
    updatedPlaces?: PlaceCreateNestedManyWithoutUpdaterInput
    createdSubnets?: SubnetCreateNestedManyWithoutCreatorInput
    updatedSubnets?: SubnetCreateNestedManyWithoutUpdaterInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutVpcsInput = {
    id?: string
    username: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    tenantId?: string | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    groupMemberships?: UserGroupMemberUncheckedCreateNestedManyWithoutUserInput
    instances?: InstanceUncheckedCreateNestedManyWithoutUserInput
    privateDataDisks?: PrivateDataDiskUncheckedCreateNestedManyWithoutUserInput
    createdTenants?: TenantUncheckedCreateNestedManyWithoutCreatorInput
    createdVpcs?: VpcUncheckedCreateNestedManyWithoutCreatorInput
    updatedVpcs?: VpcUncheckedCreateNestedManyWithoutUpdaterInput
    createdPlaces?: PlaceUncheckedCreateNestedManyWithoutCreatorInput
    updatedPlaces?: PlaceUncheckedCreateNestedManyWithoutUpdaterInput
    createdSubnets?: SubnetUncheckedCreateNestedManyWithoutCreatorInput
    updatedSubnets?: SubnetUncheckedCreateNestedManyWithoutUpdaterInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutVpcsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVpcsInput, UserUncheckedCreateWithoutVpcsInput>
  }

  export type SubnetCreateWithoutVpcInput = {
    id?: string
    name: string
    cidrBlock: string
    availabilityZone?: string | null
    gateway?: string | null
    vlanId?: number | null
    isPublic?: boolean
    autoAssignIp?: boolean
    status?: $Enums.SubnetStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    place?: PlaceCreateNestedOneWithoutSubnetInput
    creator?: UserCreateNestedOneWithoutCreatedSubnetsInput
    updater?: UserCreateNestedOneWithoutUpdatedSubnetsInput
  }

  export type SubnetUncheckedCreateWithoutVpcInput = {
    id?: string
    name: string
    cidrBlock: string
    availabilityZone?: string | null
    gateway?: string | null
    vlanId?: number | null
    isPublic?: boolean
    autoAssignIp?: boolean
    status?: $Enums.SubnetStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    place?: PlaceUncheckedCreateNestedOneWithoutSubnetInput
  }

  export type SubnetCreateOrConnectWithoutVpcInput = {
    where: SubnetWhereUniqueInput
    create: XOR<SubnetCreateWithoutVpcInput, SubnetUncheckedCreateWithoutVpcInput>
  }

  export type SubnetCreateManyVpcInputEnvelope = {
    data: SubnetCreateManyVpcInput | SubnetCreateManyVpcInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutCreatedVpcsInput = {
    id?: string
    username: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant?: TenantCreateNestedOneWithoutUsersInput
    groupMemberships?: UserGroupMemberCreateNestedManyWithoutUserInput
    instances?: InstanceCreateNestedManyWithoutUserInput
    privateDataDisks?: PrivateDataDiskCreateNestedManyWithoutUserInput
    createdTenants?: TenantCreateNestedManyWithoutCreatorInput
    vpcs?: VpcCreateNestedManyWithoutUserInput
    updatedVpcs?: VpcCreateNestedManyWithoutUpdaterInput
    createdPlaces?: PlaceCreateNestedManyWithoutCreatorInput
    updatedPlaces?: PlaceCreateNestedManyWithoutUpdaterInput
    createdSubnets?: SubnetCreateNestedManyWithoutCreatorInput
    updatedSubnets?: SubnetCreateNestedManyWithoutUpdaterInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedVpcsInput = {
    id?: string
    username: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    tenantId?: string | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    groupMemberships?: UserGroupMemberUncheckedCreateNestedManyWithoutUserInput
    instances?: InstanceUncheckedCreateNestedManyWithoutUserInput
    privateDataDisks?: PrivateDataDiskUncheckedCreateNestedManyWithoutUserInput
    createdTenants?: TenantUncheckedCreateNestedManyWithoutCreatorInput
    vpcs?: VpcUncheckedCreateNestedManyWithoutUserInput
    updatedVpcs?: VpcUncheckedCreateNestedManyWithoutUpdaterInput
    createdPlaces?: PlaceUncheckedCreateNestedManyWithoutCreatorInput
    updatedPlaces?: PlaceUncheckedCreateNestedManyWithoutUpdaterInput
    createdSubnets?: SubnetUncheckedCreateNestedManyWithoutCreatorInput
    updatedSubnets?: SubnetUncheckedCreateNestedManyWithoutUpdaterInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedVpcsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedVpcsInput, UserUncheckedCreateWithoutCreatedVpcsInput>
  }

  export type UserCreateWithoutUpdatedVpcsInput = {
    id?: string
    username: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant?: TenantCreateNestedOneWithoutUsersInput
    groupMemberships?: UserGroupMemberCreateNestedManyWithoutUserInput
    instances?: InstanceCreateNestedManyWithoutUserInput
    privateDataDisks?: PrivateDataDiskCreateNestedManyWithoutUserInput
    createdTenants?: TenantCreateNestedManyWithoutCreatorInput
    vpcs?: VpcCreateNestedManyWithoutUserInput
    createdVpcs?: VpcCreateNestedManyWithoutCreatorInput
    createdPlaces?: PlaceCreateNestedManyWithoutCreatorInput
    updatedPlaces?: PlaceCreateNestedManyWithoutUpdaterInput
    createdSubnets?: SubnetCreateNestedManyWithoutCreatorInput
    updatedSubnets?: SubnetCreateNestedManyWithoutUpdaterInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUpdatedVpcsInput = {
    id?: string
    username: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    tenantId?: string | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    groupMemberships?: UserGroupMemberUncheckedCreateNestedManyWithoutUserInput
    instances?: InstanceUncheckedCreateNestedManyWithoutUserInput
    privateDataDisks?: PrivateDataDiskUncheckedCreateNestedManyWithoutUserInput
    createdTenants?: TenantUncheckedCreateNestedManyWithoutCreatorInput
    vpcs?: VpcUncheckedCreateNestedManyWithoutUserInput
    createdVpcs?: VpcUncheckedCreateNestedManyWithoutCreatorInput
    createdPlaces?: PlaceUncheckedCreateNestedManyWithoutCreatorInput
    updatedPlaces?: PlaceUncheckedCreateNestedManyWithoutUpdaterInput
    createdSubnets?: SubnetUncheckedCreateNestedManyWithoutCreatorInput
    updatedSubnets?: SubnetUncheckedCreateNestedManyWithoutUpdaterInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUpdatedVpcsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUpdatedVpcsInput, UserUncheckedCreateWithoutUpdatedVpcsInput>
  }

  export type TenantUpsertWithoutVpcsInput = {
    update: XOR<TenantUpdateWithoutVpcsInput, TenantUncheckedUpdateWithoutVpcsInput>
    create: XOR<TenantCreateWithoutVpcsInput, TenantUncheckedCreateWithoutVpcsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutVpcsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutVpcsInput, TenantUncheckedUpdateWithoutVpcsInput>
  }

  export type TenantUpdateWithoutVpcsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    vlanId?: NullableIntFieldUpdateOperationsInput | number | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    userGroups?: UserGroupUpdateManyWithoutTenantNestedInput
    instances?: InstanceUpdateManyWithoutTenantNestedInput
    privateDataDisks?: PrivateDataDiskUpdateManyWithoutTenantNestedInput
    places?: PlaceUpdateManyWithoutTenantNestedInput
    creator?: UserUpdateOneWithoutCreatedTenantsNestedInput
  }

  export type TenantUncheckedUpdateWithoutVpcsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    vlanId?: NullableIntFieldUpdateOperationsInput | number | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    userGroups?: UserGroupUncheckedUpdateManyWithoutTenantNestedInput
    instances?: InstanceUncheckedUpdateManyWithoutTenantNestedInput
    privateDataDisks?: PrivateDataDiskUncheckedUpdateManyWithoutTenantNestedInput
    places?: PlaceUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UserUpsertWithoutVpcsInput = {
    update: XOR<UserUpdateWithoutVpcsInput, UserUncheckedUpdateWithoutVpcsInput>
    create: XOR<UserCreateWithoutVpcsInput, UserUncheckedCreateWithoutVpcsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVpcsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVpcsInput, UserUncheckedUpdateWithoutVpcsInput>
  }

  export type UserUpdateWithoutVpcsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutUsersNestedInput
    groupMemberships?: UserGroupMemberUpdateManyWithoutUserNestedInput
    instances?: InstanceUpdateManyWithoutUserNestedInput
    privateDataDisks?: PrivateDataDiskUpdateManyWithoutUserNestedInput
    createdTenants?: TenantUpdateManyWithoutCreatorNestedInput
    createdVpcs?: VpcUpdateManyWithoutCreatorNestedInput
    updatedVpcs?: VpcUpdateManyWithoutUpdaterNestedInput
    createdPlaces?: PlaceUpdateManyWithoutCreatorNestedInput
    updatedPlaces?: PlaceUpdateManyWithoutUpdaterNestedInput
    createdSubnets?: SubnetUpdateManyWithoutCreatorNestedInput
    updatedSubnets?: SubnetUpdateManyWithoutUpdaterNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutVpcsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groupMemberships?: UserGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    instances?: InstanceUncheckedUpdateManyWithoutUserNestedInput
    privateDataDisks?: PrivateDataDiskUncheckedUpdateManyWithoutUserNestedInput
    createdTenants?: TenantUncheckedUpdateManyWithoutCreatorNestedInput
    createdVpcs?: VpcUncheckedUpdateManyWithoutCreatorNestedInput
    updatedVpcs?: VpcUncheckedUpdateManyWithoutUpdaterNestedInput
    createdPlaces?: PlaceUncheckedUpdateManyWithoutCreatorNestedInput
    updatedPlaces?: PlaceUncheckedUpdateManyWithoutUpdaterNestedInput
    createdSubnets?: SubnetUncheckedUpdateManyWithoutCreatorNestedInput
    updatedSubnets?: SubnetUncheckedUpdateManyWithoutUpdaterNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SubnetUpsertWithWhereUniqueWithoutVpcInput = {
    where: SubnetWhereUniqueInput
    update: XOR<SubnetUpdateWithoutVpcInput, SubnetUncheckedUpdateWithoutVpcInput>
    create: XOR<SubnetCreateWithoutVpcInput, SubnetUncheckedCreateWithoutVpcInput>
  }

  export type SubnetUpdateWithWhereUniqueWithoutVpcInput = {
    where: SubnetWhereUniqueInput
    data: XOR<SubnetUpdateWithoutVpcInput, SubnetUncheckedUpdateWithoutVpcInput>
  }

  export type SubnetUpdateManyWithWhereWithoutVpcInput = {
    where: SubnetScalarWhereInput
    data: XOR<SubnetUpdateManyMutationInput, SubnetUncheckedUpdateManyWithoutVpcInput>
  }

  export type UserUpsertWithoutCreatedVpcsInput = {
    update: XOR<UserUpdateWithoutCreatedVpcsInput, UserUncheckedUpdateWithoutCreatedVpcsInput>
    create: XOR<UserCreateWithoutCreatedVpcsInput, UserUncheckedCreateWithoutCreatedVpcsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedVpcsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedVpcsInput, UserUncheckedUpdateWithoutCreatedVpcsInput>
  }

  export type UserUpdateWithoutCreatedVpcsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutUsersNestedInput
    groupMemberships?: UserGroupMemberUpdateManyWithoutUserNestedInput
    instances?: InstanceUpdateManyWithoutUserNestedInput
    privateDataDisks?: PrivateDataDiskUpdateManyWithoutUserNestedInput
    createdTenants?: TenantUpdateManyWithoutCreatorNestedInput
    vpcs?: VpcUpdateManyWithoutUserNestedInput
    updatedVpcs?: VpcUpdateManyWithoutUpdaterNestedInput
    createdPlaces?: PlaceUpdateManyWithoutCreatorNestedInput
    updatedPlaces?: PlaceUpdateManyWithoutUpdaterNestedInput
    createdSubnets?: SubnetUpdateManyWithoutCreatorNestedInput
    updatedSubnets?: SubnetUpdateManyWithoutUpdaterNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedVpcsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groupMemberships?: UserGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    instances?: InstanceUncheckedUpdateManyWithoutUserNestedInput
    privateDataDisks?: PrivateDataDiskUncheckedUpdateManyWithoutUserNestedInput
    createdTenants?: TenantUncheckedUpdateManyWithoutCreatorNestedInput
    vpcs?: VpcUncheckedUpdateManyWithoutUserNestedInput
    updatedVpcs?: VpcUncheckedUpdateManyWithoutUpdaterNestedInput
    createdPlaces?: PlaceUncheckedUpdateManyWithoutCreatorNestedInput
    updatedPlaces?: PlaceUncheckedUpdateManyWithoutUpdaterNestedInput
    createdSubnets?: SubnetUncheckedUpdateManyWithoutCreatorNestedInput
    updatedSubnets?: SubnetUncheckedUpdateManyWithoutUpdaterNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutUpdatedVpcsInput = {
    update: XOR<UserUpdateWithoutUpdatedVpcsInput, UserUncheckedUpdateWithoutUpdatedVpcsInput>
    create: XOR<UserCreateWithoutUpdatedVpcsInput, UserUncheckedCreateWithoutUpdatedVpcsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUpdatedVpcsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUpdatedVpcsInput, UserUncheckedUpdateWithoutUpdatedVpcsInput>
  }

  export type UserUpdateWithoutUpdatedVpcsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutUsersNestedInput
    groupMemberships?: UserGroupMemberUpdateManyWithoutUserNestedInput
    instances?: InstanceUpdateManyWithoutUserNestedInput
    privateDataDisks?: PrivateDataDiskUpdateManyWithoutUserNestedInput
    createdTenants?: TenantUpdateManyWithoutCreatorNestedInput
    vpcs?: VpcUpdateManyWithoutUserNestedInput
    createdVpcs?: VpcUpdateManyWithoutCreatorNestedInput
    createdPlaces?: PlaceUpdateManyWithoutCreatorNestedInput
    updatedPlaces?: PlaceUpdateManyWithoutUpdaterNestedInput
    createdSubnets?: SubnetUpdateManyWithoutCreatorNestedInput
    updatedSubnets?: SubnetUpdateManyWithoutUpdaterNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUpdatedVpcsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groupMemberships?: UserGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    instances?: InstanceUncheckedUpdateManyWithoutUserNestedInput
    privateDataDisks?: PrivateDataDiskUncheckedUpdateManyWithoutUserNestedInput
    createdTenants?: TenantUncheckedUpdateManyWithoutCreatorNestedInput
    vpcs?: VpcUncheckedUpdateManyWithoutUserNestedInput
    createdVpcs?: VpcUncheckedUpdateManyWithoutCreatorNestedInput
    createdPlaces?: PlaceUncheckedUpdateManyWithoutCreatorNestedInput
    updatedPlaces?: PlaceUncheckedUpdateManyWithoutUpdaterNestedInput
    createdSubnets?: SubnetUncheckedUpdateManyWithoutCreatorNestedInput
    updatedSubnets?: SubnetUncheckedUpdateManyWithoutUpdaterNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TenantCreateWithoutPlacesInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.TenantStatus
    adminUserId?: string | null
    vlanId?: number | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    userGroups?: UserGroupCreateNestedManyWithoutTenantInput
    instances?: InstanceCreateNestedManyWithoutTenantInput
    privateDataDisks?: PrivateDataDiskCreateNestedManyWithoutTenantInput
    vpcs?: VpcCreateNestedManyWithoutTenantInput
    creator?: UserCreateNestedOneWithoutCreatedTenantsInput
  }

  export type TenantUncheckedCreateWithoutPlacesInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.TenantStatus
    adminUserId?: string | null
    vlanId?: number | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    userGroups?: UserGroupUncheckedCreateNestedManyWithoutTenantInput
    instances?: InstanceUncheckedCreateNestedManyWithoutTenantInput
    privateDataDisks?: PrivateDataDiskUncheckedCreateNestedManyWithoutTenantInput
    vpcs?: VpcUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutPlacesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutPlacesInput, TenantUncheckedCreateWithoutPlacesInput>
  }

  export type SubnetCreateWithoutPlaceInput = {
    id?: string
    name: string
    cidrBlock: string
    availabilityZone?: string | null
    gateway?: string | null
    vlanId?: number | null
    isPublic?: boolean
    autoAssignIp?: boolean
    status?: $Enums.SubnetStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    vpc: VpcCreateNestedOneWithoutSubnetsInput
    creator?: UserCreateNestedOneWithoutCreatedSubnetsInput
    updater?: UserCreateNestedOneWithoutUpdatedSubnetsInput
  }

  export type SubnetUncheckedCreateWithoutPlaceInput = {
    id?: string
    name: string
    vpcId: string
    cidrBlock: string
    availabilityZone?: string | null
    gateway?: string | null
    vlanId?: number | null
    isPublic?: boolean
    autoAssignIp?: boolean
    status?: $Enums.SubnetStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
  }

  export type SubnetCreateOrConnectWithoutPlaceInput = {
    where: SubnetWhereUniqueInput
    create: XOR<SubnetCreateWithoutPlaceInput, SubnetUncheckedCreateWithoutPlaceInput>
  }

  export type UserCreateWithoutCreatedPlacesInput = {
    id?: string
    username: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant?: TenantCreateNestedOneWithoutUsersInput
    groupMemberships?: UserGroupMemberCreateNestedManyWithoutUserInput
    instances?: InstanceCreateNestedManyWithoutUserInput
    privateDataDisks?: PrivateDataDiskCreateNestedManyWithoutUserInput
    createdTenants?: TenantCreateNestedManyWithoutCreatorInput
    vpcs?: VpcCreateNestedManyWithoutUserInput
    createdVpcs?: VpcCreateNestedManyWithoutCreatorInput
    updatedVpcs?: VpcCreateNestedManyWithoutUpdaterInput
    updatedPlaces?: PlaceCreateNestedManyWithoutUpdaterInput
    createdSubnets?: SubnetCreateNestedManyWithoutCreatorInput
    updatedSubnets?: SubnetCreateNestedManyWithoutUpdaterInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedPlacesInput = {
    id?: string
    username: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    tenantId?: string | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    groupMemberships?: UserGroupMemberUncheckedCreateNestedManyWithoutUserInput
    instances?: InstanceUncheckedCreateNestedManyWithoutUserInput
    privateDataDisks?: PrivateDataDiskUncheckedCreateNestedManyWithoutUserInput
    createdTenants?: TenantUncheckedCreateNestedManyWithoutCreatorInput
    vpcs?: VpcUncheckedCreateNestedManyWithoutUserInput
    createdVpcs?: VpcUncheckedCreateNestedManyWithoutCreatorInput
    updatedVpcs?: VpcUncheckedCreateNestedManyWithoutUpdaterInput
    updatedPlaces?: PlaceUncheckedCreateNestedManyWithoutUpdaterInput
    createdSubnets?: SubnetUncheckedCreateNestedManyWithoutCreatorInput
    updatedSubnets?: SubnetUncheckedCreateNestedManyWithoutUpdaterInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedPlacesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedPlacesInput, UserUncheckedCreateWithoutCreatedPlacesInput>
  }

  export type UserCreateWithoutUpdatedPlacesInput = {
    id?: string
    username: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant?: TenantCreateNestedOneWithoutUsersInput
    groupMemberships?: UserGroupMemberCreateNestedManyWithoutUserInput
    instances?: InstanceCreateNestedManyWithoutUserInput
    privateDataDisks?: PrivateDataDiskCreateNestedManyWithoutUserInput
    createdTenants?: TenantCreateNestedManyWithoutCreatorInput
    vpcs?: VpcCreateNestedManyWithoutUserInput
    createdVpcs?: VpcCreateNestedManyWithoutCreatorInput
    updatedVpcs?: VpcCreateNestedManyWithoutUpdaterInput
    createdPlaces?: PlaceCreateNestedManyWithoutCreatorInput
    createdSubnets?: SubnetCreateNestedManyWithoutCreatorInput
    updatedSubnets?: SubnetCreateNestedManyWithoutUpdaterInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUpdatedPlacesInput = {
    id?: string
    username: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    tenantId?: string | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    groupMemberships?: UserGroupMemberUncheckedCreateNestedManyWithoutUserInput
    instances?: InstanceUncheckedCreateNestedManyWithoutUserInput
    privateDataDisks?: PrivateDataDiskUncheckedCreateNestedManyWithoutUserInput
    createdTenants?: TenantUncheckedCreateNestedManyWithoutCreatorInput
    vpcs?: VpcUncheckedCreateNestedManyWithoutUserInput
    createdVpcs?: VpcUncheckedCreateNestedManyWithoutCreatorInput
    updatedVpcs?: VpcUncheckedCreateNestedManyWithoutUpdaterInput
    createdPlaces?: PlaceUncheckedCreateNestedManyWithoutCreatorInput
    createdSubnets?: SubnetUncheckedCreateNestedManyWithoutCreatorInput
    updatedSubnets?: SubnetUncheckedCreateNestedManyWithoutUpdaterInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUpdatedPlacesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUpdatedPlacesInput, UserUncheckedCreateWithoutUpdatedPlacesInput>
  }

  export type TenantUpsertWithoutPlacesInput = {
    update: XOR<TenantUpdateWithoutPlacesInput, TenantUncheckedUpdateWithoutPlacesInput>
    create: XOR<TenantCreateWithoutPlacesInput, TenantUncheckedCreateWithoutPlacesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutPlacesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutPlacesInput, TenantUncheckedUpdateWithoutPlacesInput>
  }

  export type TenantUpdateWithoutPlacesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    vlanId?: NullableIntFieldUpdateOperationsInput | number | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    userGroups?: UserGroupUpdateManyWithoutTenantNestedInput
    instances?: InstanceUpdateManyWithoutTenantNestedInput
    privateDataDisks?: PrivateDataDiskUpdateManyWithoutTenantNestedInput
    vpcs?: VpcUpdateManyWithoutTenantNestedInput
    creator?: UserUpdateOneWithoutCreatedTenantsNestedInput
  }

  export type TenantUncheckedUpdateWithoutPlacesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    vlanId?: NullableIntFieldUpdateOperationsInput | number | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    userGroups?: UserGroupUncheckedUpdateManyWithoutTenantNestedInput
    instances?: InstanceUncheckedUpdateManyWithoutTenantNestedInput
    privateDataDisks?: PrivateDataDiskUncheckedUpdateManyWithoutTenantNestedInput
    vpcs?: VpcUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type SubnetUpsertWithoutPlaceInput = {
    update: XOR<SubnetUpdateWithoutPlaceInput, SubnetUncheckedUpdateWithoutPlaceInput>
    create: XOR<SubnetCreateWithoutPlaceInput, SubnetUncheckedCreateWithoutPlaceInput>
    where?: SubnetWhereInput
  }

  export type SubnetUpdateToOneWithWhereWithoutPlaceInput = {
    where?: SubnetWhereInput
    data: XOR<SubnetUpdateWithoutPlaceInput, SubnetUncheckedUpdateWithoutPlaceInput>
  }

  export type SubnetUpdateWithoutPlaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cidrBlock?: StringFieldUpdateOperationsInput | string
    availabilityZone?: NullableStringFieldUpdateOperationsInput | string | null
    gateway?: NullableStringFieldUpdateOperationsInput | string | null
    vlanId?: NullableIntFieldUpdateOperationsInput | number | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    autoAssignIp?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumSubnetStatusFieldUpdateOperationsInput | $Enums.SubnetStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vpc?: VpcUpdateOneRequiredWithoutSubnetsNestedInput
    creator?: UserUpdateOneWithoutCreatedSubnetsNestedInput
    updater?: UserUpdateOneWithoutUpdatedSubnetsNestedInput
  }

  export type SubnetUncheckedUpdateWithoutPlaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    vpcId?: StringFieldUpdateOperationsInput | string
    cidrBlock?: StringFieldUpdateOperationsInput | string
    availabilityZone?: NullableStringFieldUpdateOperationsInput | string | null
    gateway?: NullableStringFieldUpdateOperationsInput | string | null
    vlanId?: NullableIntFieldUpdateOperationsInput | number | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    autoAssignIp?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumSubnetStatusFieldUpdateOperationsInput | $Enums.SubnetStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUpsertWithoutCreatedPlacesInput = {
    update: XOR<UserUpdateWithoutCreatedPlacesInput, UserUncheckedUpdateWithoutCreatedPlacesInput>
    create: XOR<UserCreateWithoutCreatedPlacesInput, UserUncheckedCreateWithoutCreatedPlacesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedPlacesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedPlacesInput, UserUncheckedUpdateWithoutCreatedPlacesInput>
  }

  export type UserUpdateWithoutCreatedPlacesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutUsersNestedInput
    groupMemberships?: UserGroupMemberUpdateManyWithoutUserNestedInput
    instances?: InstanceUpdateManyWithoutUserNestedInput
    privateDataDisks?: PrivateDataDiskUpdateManyWithoutUserNestedInput
    createdTenants?: TenantUpdateManyWithoutCreatorNestedInput
    vpcs?: VpcUpdateManyWithoutUserNestedInput
    createdVpcs?: VpcUpdateManyWithoutCreatorNestedInput
    updatedVpcs?: VpcUpdateManyWithoutUpdaterNestedInput
    updatedPlaces?: PlaceUpdateManyWithoutUpdaterNestedInput
    createdSubnets?: SubnetUpdateManyWithoutCreatorNestedInput
    updatedSubnets?: SubnetUpdateManyWithoutUpdaterNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedPlacesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groupMemberships?: UserGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    instances?: InstanceUncheckedUpdateManyWithoutUserNestedInput
    privateDataDisks?: PrivateDataDiskUncheckedUpdateManyWithoutUserNestedInput
    createdTenants?: TenantUncheckedUpdateManyWithoutCreatorNestedInput
    vpcs?: VpcUncheckedUpdateManyWithoutUserNestedInput
    createdVpcs?: VpcUncheckedUpdateManyWithoutCreatorNestedInput
    updatedVpcs?: VpcUncheckedUpdateManyWithoutUpdaterNestedInput
    updatedPlaces?: PlaceUncheckedUpdateManyWithoutUpdaterNestedInput
    createdSubnets?: SubnetUncheckedUpdateManyWithoutCreatorNestedInput
    updatedSubnets?: SubnetUncheckedUpdateManyWithoutUpdaterNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutUpdatedPlacesInput = {
    update: XOR<UserUpdateWithoutUpdatedPlacesInput, UserUncheckedUpdateWithoutUpdatedPlacesInput>
    create: XOR<UserCreateWithoutUpdatedPlacesInput, UserUncheckedCreateWithoutUpdatedPlacesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUpdatedPlacesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUpdatedPlacesInput, UserUncheckedUpdateWithoutUpdatedPlacesInput>
  }

  export type UserUpdateWithoutUpdatedPlacesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutUsersNestedInput
    groupMemberships?: UserGroupMemberUpdateManyWithoutUserNestedInput
    instances?: InstanceUpdateManyWithoutUserNestedInput
    privateDataDisks?: PrivateDataDiskUpdateManyWithoutUserNestedInput
    createdTenants?: TenantUpdateManyWithoutCreatorNestedInput
    vpcs?: VpcUpdateManyWithoutUserNestedInput
    createdVpcs?: VpcUpdateManyWithoutCreatorNestedInput
    updatedVpcs?: VpcUpdateManyWithoutUpdaterNestedInput
    createdPlaces?: PlaceUpdateManyWithoutCreatorNestedInput
    createdSubnets?: SubnetUpdateManyWithoutCreatorNestedInput
    updatedSubnets?: SubnetUpdateManyWithoutUpdaterNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUpdatedPlacesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groupMemberships?: UserGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    instances?: InstanceUncheckedUpdateManyWithoutUserNestedInput
    privateDataDisks?: PrivateDataDiskUncheckedUpdateManyWithoutUserNestedInput
    createdTenants?: TenantUncheckedUpdateManyWithoutCreatorNestedInput
    vpcs?: VpcUncheckedUpdateManyWithoutUserNestedInput
    createdVpcs?: VpcUncheckedUpdateManyWithoutCreatorNestedInput
    updatedVpcs?: VpcUncheckedUpdateManyWithoutUpdaterNestedInput
    createdPlaces?: PlaceUncheckedUpdateManyWithoutCreatorNestedInput
    createdSubnets?: SubnetUncheckedUpdateManyWithoutCreatorNestedInput
    updatedSubnets?: SubnetUncheckedUpdateManyWithoutUpdaterNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type VpcCreateWithoutSubnetsInput = {
    id?: string
    name: string
    description?: string | null
    cidrBlock: string
    edgeDataCenterId?: string | null
    vlanId?: number | null
    enableDns?: boolean
    dnsServers?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.VpcStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutVpcsInput
    user: UserCreateNestedOneWithoutVpcsInput
    creator?: UserCreateNestedOneWithoutCreatedVpcsInput
    updater?: UserCreateNestedOneWithoutUpdatedVpcsInput
  }

  export type VpcUncheckedCreateWithoutSubnetsInput = {
    id?: string
    name: string
    description?: string | null
    tenantId: string
    userId: string
    cidrBlock: string
    edgeDataCenterId?: string | null
    vlanId?: number | null
    enableDns?: boolean
    dnsServers?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.VpcStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
  }

  export type VpcCreateOrConnectWithoutSubnetsInput = {
    where: VpcWhereUniqueInput
    create: XOR<VpcCreateWithoutSubnetsInput, VpcUncheckedCreateWithoutSubnetsInput>
  }

  export type PlaceCreateWithoutSubnetInput = {
    id?: string
    name: string
    description?: string | null
    location?: string | null
    status?: $Enums.PlaceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutPlacesInput
    creator?: UserCreateNestedOneWithoutCreatedPlacesInput
    updater?: UserCreateNestedOneWithoutUpdatedPlacesInput
  }

  export type PlaceUncheckedCreateWithoutSubnetInput = {
    id?: string
    name: string
    description?: string | null
    tenantId: string
    location?: string | null
    status?: $Enums.PlaceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
  }

  export type PlaceCreateOrConnectWithoutSubnetInput = {
    where: PlaceWhereUniqueInput
    create: XOR<PlaceCreateWithoutSubnetInput, PlaceUncheckedCreateWithoutSubnetInput>
  }

  export type UserCreateWithoutCreatedSubnetsInput = {
    id?: string
    username: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant?: TenantCreateNestedOneWithoutUsersInput
    groupMemberships?: UserGroupMemberCreateNestedManyWithoutUserInput
    instances?: InstanceCreateNestedManyWithoutUserInput
    privateDataDisks?: PrivateDataDiskCreateNestedManyWithoutUserInput
    createdTenants?: TenantCreateNestedManyWithoutCreatorInput
    vpcs?: VpcCreateNestedManyWithoutUserInput
    createdVpcs?: VpcCreateNestedManyWithoutCreatorInput
    updatedVpcs?: VpcCreateNestedManyWithoutUpdaterInput
    createdPlaces?: PlaceCreateNestedManyWithoutCreatorInput
    updatedPlaces?: PlaceCreateNestedManyWithoutUpdaterInput
    updatedSubnets?: SubnetCreateNestedManyWithoutUpdaterInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedSubnetsInput = {
    id?: string
    username: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    tenantId?: string | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    groupMemberships?: UserGroupMemberUncheckedCreateNestedManyWithoutUserInput
    instances?: InstanceUncheckedCreateNestedManyWithoutUserInput
    privateDataDisks?: PrivateDataDiskUncheckedCreateNestedManyWithoutUserInput
    createdTenants?: TenantUncheckedCreateNestedManyWithoutCreatorInput
    vpcs?: VpcUncheckedCreateNestedManyWithoutUserInput
    createdVpcs?: VpcUncheckedCreateNestedManyWithoutCreatorInput
    updatedVpcs?: VpcUncheckedCreateNestedManyWithoutUpdaterInput
    createdPlaces?: PlaceUncheckedCreateNestedManyWithoutCreatorInput
    updatedPlaces?: PlaceUncheckedCreateNestedManyWithoutUpdaterInput
    updatedSubnets?: SubnetUncheckedCreateNestedManyWithoutUpdaterInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedSubnetsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedSubnetsInput, UserUncheckedCreateWithoutCreatedSubnetsInput>
  }

  export type UserCreateWithoutUpdatedSubnetsInput = {
    id?: string
    username: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant?: TenantCreateNestedOneWithoutUsersInput
    groupMemberships?: UserGroupMemberCreateNestedManyWithoutUserInput
    instances?: InstanceCreateNestedManyWithoutUserInput
    privateDataDisks?: PrivateDataDiskCreateNestedManyWithoutUserInput
    createdTenants?: TenantCreateNestedManyWithoutCreatorInput
    vpcs?: VpcCreateNestedManyWithoutUserInput
    createdVpcs?: VpcCreateNestedManyWithoutCreatorInput
    updatedVpcs?: VpcCreateNestedManyWithoutUpdaterInput
    createdPlaces?: PlaceCreateNestedManyWithoutCreatorInput
    updatedPlaces?: PlaceCreateNestedManyWithoutUpdaterInput
    createdSubnets?: SubnetCreateNestedManyWithoutCreatorInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUpdatedSubnetsInput = {
    id?: string
    username: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    tenantId?: string | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    groupMemberships?: UserGroupMemberUncheckedCreateNestedManyWithoutUserInput
    instances?: InstanceUncheckedCreateNestedManyWithoutUserInput
    privateDataDisks?: PrivateDataDiskUncheckedCreateNestedManyWithoutUserInput
    createdTenants?: TenantUncheckedCreateNestedManyWithoutCreatorInput
    vpcs?: VpcUncheckedCreateNestedManyWithoutUserInput
    createdVpcs?: VpcUncheckedCreateNestedManyWithoutCreatorInput
    updatedVpcs?: VpcUncheckedCreateNestedManyWithoutUpdaterInput
    createdPlaces?: PlaceUncheckedCreateNestedManyWithoutCreatorInput
    updatedPlaces?: PlaceUncheckedCreateNestedManyWithoutUpdaterInput
    createdSubnets?: SubnetUncheckedCreateNestedManyWithoutCreatorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUpdatedSubnetsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUpdatedSubnetsInput, UserUncheckedCreateWithoutUpdatedSubnetsInput>
  }

  export type VpcUpsertWithoutSubnetsInput = {
    update: XOR<VpcUpdateWithoutSubnetsInput, VpcUncheckedUpdateWithoutSubnetsInput>
    create: XOR<VpcCreateWithoutSubnetsInput, VpcUncheckedCreateWithoutSubnetsInput>
    where?: VpcWhereInput
  }

  export type VpcUpdateToOneWithWhereWithoutSubnetsInput = {
    where?: VpcWhereInput
    data: XOR<VpcUpdateWithoutSubnetsInput, VpcUncheckedUpdateWithoutSubnetsInput>
  }

  export type VpcUpdateWithoutSubnetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cidrBlock?: StringFieldUpdateOperationsInput | string
    edgeDataCenterId?: NullableStringFieldUpdateOperationsInput | string | null
    vlanId?: NullableIntFieldUpdateOperationsInput | number | null
    enableDns?: BoolFieldUpdateOperationsInput | boolean
    dnsServers?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumVpcStatusFieldUpdateOperationsInput | $Enums.VpcStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutVpcsNestedInput
    user?: UserUpdateOneRequiredWithoutVpcsNestedInput
    creator?: UserUpdateOneWithoutCreatedVpcsNestedInput
    updater?: UserUpdateOneWithoutUpdatedVpcsNestedInput
  }

  export type VpcUncheckedUpdateWithoutSubnetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    cidrBlock?: StringFieldUpdateOperationsInput | string
    edgeDataCenterId?: NullableStringFieldUpdateOperationsInput | string | null
    vlanId?: NullableIntFieldUpdateOperationsInput | number | null
    enableDns?: BoolFieldUpdateOperationsInput | boolean
    dnsServers?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumVpcStatusFieldUpdateOperationsInput | $Enums.VpcStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PlaceUpsertWithoutSubnetInput = {
    update: XOR<PlaceUpdateWithoutSubnetInput, PlaceUncheckedUpdateWithoutSubnetInput>
    create: XOR<PlaceCreateWithoutSubnetInput, PlaceUncheckedCreateWithoutSubnetInput>
    where?: PlaceWhereInput
  }

  export type PlaceUpdateToOneWithWhereWithoutSubnetInput = {
    where?: PlaceWhereInput
    data: XOR<PlaceUpdateWithoutSubnetInput, PlaceUncheckedUpdateWithoutSubnetInput>
  }

  export type PlaceUpdateWithoutSubnetInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPlaceStatusFieldUpdateOperationsInput | $Enums.PlaceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutPlacesNestedInput
    creator?: UserUpdateOneWithoutCreatedPlacesNestedInput
    updater?: UserUpdateOneWithoutUpdatedPlacesNestedInput
  }

  export type PlaceUncheckedUpdateWithoutSubnetInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPlaceStatusFieldUpdateOperationsInput | $Enums.PlaceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUpsertWithoutCreatedSubnetsInput = {
    update: XOR<UserUpdateWithoutCreatedSubnetsInput, UserUncheckedUpdateWithoutCreatedSubnetsInput>
    create: XOR<UserCreateWithoutCreatedSubnetsInput, UserUncheckedCreateWithoutCreatedSubnetsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedSubnetsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedSubnetsInput, UserUncheckedUpdateWithoutCreatedSubnetsInput>
  }

  export type UserUpdateWithoutCreatedSubnetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutUsersNestedInput
    groupMemberships?: UserGroupMemberUpdateManyWithoutUserNestedInput
    instances?: InstanceUpdateManyWithoutUserNestedInput
    privateDataDisks?: PrivateDataDiskUpdateManyWithoutUserNestedInput
    createdTenants?: TenantUpdateManyWithoutCreatorNestedInput
    vpcs?: VpcUpdateManyWithoutUserNestedInput
    createdVpcs?: VpcUpdateManyWithoutCreatorNestedInput
    updatedVpcs?: VpcUpdateManyWithoutUpdaterNestedInput
    createdPlaces?: PlaceUpdateManyWithoutCreatorNestedInput
    updatedPlaces?: PlaceUpdateManyWithoutUpdaterNestedInput
    updatedSubnets?: SubnetUpdateManyWithoutUpdaterNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedSubnetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groupMemberships?: UserGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    instances?: InstanceUncheckedUpdateManyWithoutUserNestedInput
    privateDataDisks?: PrivateDataDiskUncheckedUpdateManyWithoutUserNestedInput
    createdTenants?: TenantUncheckedUpdateManyWithoutCreatorNestedInput
    vpcs?: VpcUncheckedUpdateManyWithoutUserNestedInput
    createdVpcs?: VpcUncheckedUpdateManyWithoutCreatorNestedInput
    updatedVpcs?: VpcUncheckedUpdateManyWithoutUpdaterNestedInput
    createdPlaces?: PlaceUncheckedUpdateManyWithoutCreatorNestedInput
    updatedPlaces?: PlaceUncheckedUpdateManyWithoutUpdaterNestedInput
    updatedSubnets?: SubnetUncheckedUpdateManyWithoutUpdaterNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutUpdatedSubnetsInput = {
    update: XOR<UserUpdateWithoutUpdatedSubnetsInput, UserUncheckedUpdateWithoutUpdatedSubnetsInput>
    create: XOR<UserCreateWithoutUpdatedSubnetsInput, UserUncheckedCreateWithoutUpdatedSubnetsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUpdatedSubnetsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUpdatedSubnetsInput, UserUncheckedUpdateWithoutUpdatedSubnetsInput>
  }

  export type UserUpdateWithoutUpdatedSubnetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutUsersNestedInput
    groupMemberships?: UserGroupMemberUpdateManyWithoutUserNestedInput
    instances?: InstanceUpdateManyWithoutUserNestedInput
    privateDataDisks?: PrivateDataDiskUpdateManyWithoutUserNestedInput
    createdTenants?: TenantUpdateManyWithoutCreatorNestedInput
    vpcs?: VpcUpdateManyWithoutUserNestedInput
    createdVpcs?: VpcUpdateManyWithoutCreatorNestedInput
    updatedVpcs?: VpcUpdateManyWithoutUpdaterNestedInput
    createdPlaces?: PlaceUpdateManyWithoutCreatorNestedInput
    updatedPlaces?: PlaceUpdateManyWithoutUpdaterNestedInput
    createdSubnets?: SubnetUpdateManyWithoutCreatorNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUpdatedSubnetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groupMemberships?: UserGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    instances?: InstanceUncheckedUpdateManyWithoutUserNestedInput
    privateDataDisks?: PrivateDataDiskUncheckedUpdateManyWithoutUserNestedInput
    createdTenants?: TenantUncheckedUpdateManyWithoutCreatorNestedInput
    vpcs?: VpcUncheckedUpdateManyWithoutUserNestedInput
    createdVpcs?: VpcUncheckedUpdateManyWithoutCreatorNestedInput
    updatedVpcs?: VpcUncheckedUpdateManyWithoutUpdaterNestedInput
    createdPlaces?: PlaceUncheckedUpdateManyWithoutCreatorNestedInput
    updatedPlaces?: PlaceUncheckedUpdateManyWithoutUpdaterNestedInput
    createdSubnets?: SubnetUncheckedUpdateManyWithoutCreatorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    username: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant?: TenantCreateNestedOneWithoutUsersInput
    groupMemberships?: UserGroupMemberCreateNestedManyWithoutUserInput
    instances?: InstanceCreateNestedManyWithoutUserInput
    privateDataDisks?: PrivateDataDiskCreateNestedManyWithoutUserInput
    createdTenants?: TenantCreateNestedManyWithoutCreatorInput
    vpcs?: VpcCreateNestedManyWithoutUserInput
    createdVpcs?: VpcCreateNestedManyWithoutCreatorInput
    updatedVpcs?: VpcCreateNestedManyWithoutUpdaterInput
    createdPlaces?: PlaceCreateNestedManyWithoutCreatorInput
    updatedPlaces?: PlaceCreateNestedManyWithoutUpdaterInput
    createdSubnets?: SubnetCreateNestedManyWithoutCreatorInput
    updatedSubnets?: SubnetCreateNestedManyWithoutUpdaterInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    username: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    tenantId?: string | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    groupMemberships?: UserGroupMemberUncheckedCreateNestedManyWithoutUserInput
    instances?: InstanceUncheckedCreateNestedManyWithoutUserInput
    privateDataDisks?: PrivateDataDiskUncheckedCreateNestedManyWithoutUserInput
    createdTenants?: TenantUncheckedCreateNestedManyWithoutCreatorInput
    vpcs?: VpcUncheckedCreateNestedManyWithoutUserInput
    createdVpcs?: VpcUncheckedCreateNestedManyWithoutCreatorInput
    updatedVpcs?: VpcUncheckedCreateNestedManyWithoutUpdaterInput
    createdPlaces?: PlaceUncheckedCreateNestedManyWithoutCreatorInput
    updatedPlaces?: PlaceUncheckedCreateNestedManyWithoutUpdaterInput
    createdSubnets?: SubnetUncheckedCreateNestedManyWithoutCreatorInput
    updatedSubnets?: SubnetUncheckedCreateNestedManyWithoutUpdaterInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutUsersNestedInput
    groupMemberships?: UserGroupMemberUpdateManyWithoutUserNestedInput
    instances?: InstanceUpdateManyWithoutUserNestedInput
    privateDataDisks?: PrivateDataDiskUpdateManyWithoutUserNestedInput
    createdTenants?: TenantUpdateManyWithoutCreatorNestedInput
    vpcs?: VpcUpdateManyWithoutUserNestedInput
    createdVpcs?: VpcUpdateManyWithoutCreatorNestedInput
    updatedVpcs?: VpcUpdateManyWithoutUpdaterNestedInput
    createdPlaces?: PlaceUpdateManyWithoutCreatorNestedInput
    updatedPlaces?: PlaceUpdateManyWithoutUpdaterNestedInput
    createdSubnets?: SubnetUpdateManyWithoutCreatorNestedInput
    updatedSubnets?: SubnetUpdateManyWithoutUpdaterNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groupMemberships?: UserGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    instances?: InstanceUncheckedUpdateManyWithoutUserNestedInput
    privateDataDisks?: PrivateDataDiskUncheckedUpdateManyWithoutUserNestedInput
    createdTenants?: TenantUncheckedUpdateManyWithoutCreatorNestedInput
    vpcs?: VpcUncheckedUpdateManyWithoutUserNestedInput
    createdVpcs?: VpcUncheckedUpdateManyWithoutCreatorNestedInput
    updatedVpcs?: VpcUncheckedUpdateManyWithoutUpdaterNestedInput
    createdPlaces?: PlaceUncheckedUpdateManyWithoutCreatorNestedInput
    updatedPlaces?: PlaceUncheckedUpdateManyWithoutUpdaterNestedInput
    createdSubnets?: SubnetUncheckedUpdateManyWithoutCreatorNestedInput
    updatedSubnets?: SubnetUncheckedUpdateManyWithoutUpdaterNestedInput
  }

  export type UserCreateManyTenantInput = {
    id?: string
    username: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserGroupCreateManyTenantInput = {
    id?: string
    name: string
    description?: string | null
    parentGroupId?: string | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InstanceCreateManyTenantInput = {
    id?: string
    name: string
    userId: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PrivateDataDiskCreateManyTenantInput = {
    id?: string
    name: string
    userId: string
    sizeGb: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VpcCreateManyTenantInput = {
    id?: string
    name: string
    description?: string | null
    userId: string
    cidrBlock: string
    edgeDataCenterId?: string | null
    vlanId?: number | null
    enableDns?: boolean
    dnsServers?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.VpcStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
  }

  export type PlaceCreateManyTenantInput = {
    id?: string
    name: string
    description?: string | null
    subnetId?: string | null
    location?: string | null
    status?: $Enums.PlaceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
  }

  export type UserUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groupMemberships?: UserGroupMemberUpdateManyWithoutUserNestedInput
    instances?: InstanceUpdateManyWithoutUserNestedInput
    privateDataDisks?: PrivateDataDiskUpdateManyWithoutUserNestedInput
    createdTenants?: TenantUpdateManyWithoutCreatorNestedInput
    vpcs?: VpcUpdateManyWithoutUserNestedInput
    createdVpcs?: VpcUpdateManyWithoutCreatorNestedInput
    updatedVpcs?: VpcUpdateManyWithoutUpdaterNestedInput
    createdPlaces?: PlaceUpdateManyWithoutCreatorNestedInput
    updatedPlaces?: PlaceUpdateManyWithoutUpdaterNestedInput
    createdSubnets?: SubnetUpdateManyWithoutCreatorNestedInput
    updatedSubnets?: SubnetUpdateManyWithoutUpdaterNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groupMemberships?: UserGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    instances?: InstanceUncheckedUpdateManyWithoutUserNestedInput
    privateDataDisks?: PrivateDataDiskUncheckedUpdateManyWithoutUserNestedInput
    createdTenants?: TenantUncheckedUpdateManyWithoutCreatorNestedInput
    vpcs?: VpcUncheckedUpdateManyWithoutUserNestedInput
    createdVpcs?: VpcUncheckedUpdateManyWithoutCreatorNestedInput
    updatedVpcs?: VpcUncheckedUpdateManyWithoutUpdaterNestedInput
    createdPlaces?: PlaceUncheckedUpdateManyWithoutCreatorNestedInput
    updatedPlaces?: PlaceUncheckedUpdateManyWithoutUpdaterNestedInput
    createdSubnets?: SubnetUncheckedUpdateManyWithoutCreatorNestedInput
    updatedSubnets?: SubnetUncheckedUpdateManyWithoutUpdaterNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserGroupUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentGroup?: UserGroupUpdateOneWithoutChildGroupsNestedInput
    childGroups?: UserGroupUpdateManyWithoutParentGroupNestedInput
    members?: UserGroupMemberUpdateManyWithoutGroupNestedInput
  }

  export type UserGroupUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    childGroups?: UserGroupUncheckedUpdateManyWithoutParentGroupNestedInput
    members?: UserGroupMemberUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type UserGroupUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstanceUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutInstancesNestedInput
  }

  export type InstanceUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstanceUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrivateDataDiskUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sizeGb?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPrivateDataDisksNestedInput
  }

  export type PrivateDataDiskUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sizeGb?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrivateDataDiskUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sizeGb?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VpcUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cidrBlock?: StringFieldUpdateOperationsInput | string
    edgeDataCenterId?: NullableStringFieldUpdateOperationsInput | string | null
    vlanId?: NullableIntFieldUpdateOperationsInput | number | null
    enableDns?: BoolFieldUpdateOperationsInput | boolean
    dnsServers?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumVpcStatusFieldUpdateOperationsInput | $Enums.VpcStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutVpcsNestedInput
    subnets?: SubnetUpdateManyWithoutVpcNestedInput
    creator?: UserUpdateOneWithoutCreatedVpcsNestedInput
    updater?: UserUpdateOneWithoutUpdatedVpcsNestedInput
  }

  export type VpcUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    cidrBlock?: StringFieldUpdateOperationsInput | string
    edgeDataCenterId?: NullableStringFieldUpdateOperationsInput | string | null
    vlanId?: NullableIntFieldUpdateOperationsInput | number | null
    enableDns?: BoolFieldUpdateOperationsInput | boolean
    dnsServers?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumVpcStatusFieldUpdateOperationsInput | $Enums.VpcStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    subnets?: SubnetUncheckedUpdateManyWithoutVpcNestedInput
  }

  export type VpcUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    cidrBlock?: StringFieldUpdateOperationsInput | string
    edgeDataCenterId?: NullableStringFieldUpdateOperationsInput | string | null
    vlanId?: NullableIntFieldUpdateOperationsInput | number | null
    enableDns?: BoolFieldUpdateOperationsInput | boolean
    dnsServers?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumVpcStatusFieldUpdateOperationsInput | $Enums.VpcStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PlaceUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPlaceStatusFieldUpdateOperationsInput | $Enums.PlaceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subnet?: SubnetUpdateOneWithoutPlaceNestedInput
    creator?: UserUpdateOneWithoutCreatedPlacesNestedInput
    updater?: UserUpdateOneWithoutUpdatedPlacesNestedInput
  }

  export type PlaceUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    subnetId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPlaceStatusFieldUpdateOperationsInput | $Enums.PlaceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PlaceUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    subnetId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPlaceStatusFieldUpdateOperationsInput | $Enums.PlaceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserGroupMemberCreateManyUserInput = {
    id?: string
    groupId: string
    joinedAt?: Date | string
    addedBy?: string | null
  }

  export type InstanceCreateManyUserInput = {
    id?: string
    name: string
    tenantId: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PrivateDataDiskCreateManyUserInput = {
    id?: string
    name: string
    tenantId: string
    sizeGb: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantCreateManyCreatorInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.TenantStatus
    adminUserId?: string | null
    vlanId?: number | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VpcCreateManyUserInput = {
    id?: string
    name: string
    description?: string | null
    tenantId: string
    cidrBlock: string
    edgeDataCenterId?: string | null
    vlanId?: number | null
    enableDns?: boolean
    dnsServers?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.VpcStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
  }

  export type VpcCreateManyCreatorInput = {
    id?: string
    name: string
    description?: string | null
    tenantId: string
    userId: string
    cidrBlock: string
    edgeDataCenterId?: string | null
    vlanId?: number | null
    enableDns?: boolean
    dnsServers?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.VpcStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type VpcCreateManyUpdaterInput = {
    id?: string
    name: string
    description?: string | null
    tenantId: string
    userId: string
    cidrBlock: string
    edgeDataCenterId?: string | null
    vlanId?: number | null
    enableDns?: boolean
    dnsServers?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.VpcStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
  }

  export type PlaceCreateManyCreatorInput = {
    id?: string
    name: string
    description?: string | null
    tenantId: string
    subnetId?: string | null
    location?: string | null
    status?: $Enums.PlaceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type PlaceCreateManyUpdaterInput = {
    id?: string
    name: string
    description?: string | null
    tenantId: string
    subnetId?: string | null
    location?: string | null
    status?: $Enums.PlaceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
  }

  export type SubnetCreateManyCreatorInput = {
    id?: string
    name: string
    vpcId: string
    cidrBlock: string
    availabilityZone?: string | null
    gateway?: string | null
    vlanId?: number | null
    isPublic?: boolean
    autoAssignIp?: boolean
    status?: $Enums.SubnetStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type SubnetCreateManyUpdaterInput = {
    id?: string
    name: string
    vpcId: string
    cidrBlock: string
    availabilityZone?: string | null
    gateway?: string | null
    vlanId?: number | null
    isPublic?: boolean
    autoAssignIp?: boolean
    status?: $Enums.SubnetStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
  }

  export type AuditLogCreateManyUserInput = {
    id?: string
    action: string
    resourceType: string
    resourceId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    status: string
    createdAt?: Date | string
  }

  export type UserGroupMemberUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addedBy?: NullableStringFieldUpdateOperationsInput | string | null
    group?: UserGroupUpdateOneRequiredWithoutMembersNestedInput
  }

  export type UserGroupMemberUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserGroupMemberUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InstanceUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutInstancesNestedInput
  }

  export type InstanceUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstanceUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrivateDataDiskUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sizeGb?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutPrivateDataDisksNestedInput
  }

  export type PrivateDataDiskUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    sizeGb?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrivateDataDiskUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    sizeGb?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    vlanId?: NullableIntFieldUpdateOperationsInput | number | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    userGroups?: UserGroupUpdateManyWithoutTenantNestedInput
    instances?: InstanceUpdateManyWithoutTenantNestedInput
    privateDataDisks?: PrivateDataDiskUpdateManyWithoutTenantNestedInput
    vpcs?: VpcUpdateManyWithoutTenantNestedInput
    places?: PlaceUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    vlanId?: NullableIntFieldUpdateOperationsInput | number | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    userGroups?: UserGroupUncheckedUpdateManyWithoutTenantNestedInput
    instances?: InstanceUncheckedUpdateManyWithoutTenantNestedInput
    privateDataDisks?: PrivateDataDiskUncheckedUpdateManyWithoutTenantNestedInput
    vpcs?: VpcUncheckedUpdateManyWithoutTenantNestedInput
    places?: PlaceUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    vlanId?: NullableIntFieldUpdateOperationsInput | number | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VpcUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cidrBlock?: StringFieldUpdateOperationsInput | string
    edgeDataCenterId?: NullableStringFieldUpdateOperationsInput | string | null
    vlanId?: NullableIntFieldUpdateOperationsInput | number | null
    enableDns?: BoolFieldUpdateOperationsInput | boolean
    dnsServers?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumVpcStatusFieldUpdateOperationsInput | $Enums.VpcStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutVpcsNestedInput
    subnets?: SubnetUpdateManyWithoutVpcNestedInput
    creator?: UserUpdateOneWithoutCreatedVpcsNestedInput
    updater?: UserUpdateOneWithoutUpdatedVpcsNestedInput
  }

  export type VpcUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    cidrBlock?: StringFieldUpdateOperationsInput | string
    edgeDataCenterId?: NullableStringFieldUpdateOperationsInput | string | null
    vlanId?: NullableIntFieldUpdateOperationsInput | number | null
    enableDns?: BoolFieldUpdateOperationsInput | boolean
    dnsServers?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumVpcStatusFieldUpdateOperationsInput | $Enums.VpcStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    subnets?: SubnetUncheckedUpdateManyWithoutVpcNestedInput
  }

  export type VpcUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    cidrBlock?: StringFieldUpdateOperationsInput | string
    edgeDataCenterId?: NullableStringFieldUpdateOperationsInput | string | null
    vlanId?: NullableIntFieldUpdateOperationsInput | number | null
    enableDns?: BoolFieldUpdateOperationsInput | boolean
    dnsServers?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumVpcStatusFieldUpdateOperationsInput | $Enums.VpcStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VpcUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cidrBlock?: StringFieldUpdateOperationsInput | string
    edgeDataCenterId?: NullableStringFieldUpdateOperationsInput | string | null
    vlanId?: NullableIntFieldUpdateOperationsInput | number | null
    enableDns?: BoolFieldUpdateOperationsInput | boolean
    dnsServers?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumVpcStatusFieldUpdateOperationsInput | $Enums.VpcStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutVpcsNestedInput
    user?: UserUpdateOneRequiredWithoutVpcsNestedInput
    subnets?: SubnetUpdateManyWithoutVpcNestedInput
    updater?: UserUpdateOneWithoutUpdatedVpcsNestedInput
  }

  export type VpcUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    cidrBlock?: StringFieldUpdateOperationsInput | string
    edgeDataCenterId?: NullableStringFieldUpdateOperationsInput | string | null
    vlanId?: NullableIntFieldUpdateOperationsInput | number | null
    enableDns?: BoolFieldUpdateOperationsInput | boolean
    dnsServers?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumVpcStatusFieldUpdateOperationsInput | $Enums.VpcStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    subnets?: SubnetUncheckedUpdateManyWithoutVpcNestedInput
  }

  export type VpcUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    cidrBlock?: StringFieldUpdateOperationsInput | string
    edgeDataCenterId?: NullableStringFieldUpdateOperationsInput | string | null
    vlanId?: NullableIntFieldUpdateOperationsInput | number | null
    enableDns?: BoolFieldUpdateOperationsInput | boolean
    dnsServers?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumVpcStatusFieldUpdateOperationsInput | $Enums.VpcStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VpcUpdateWithoutUpdaterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cidrBlock?: StringFieldUpdateOperationsInput | string
    edgeDataCenterId?: NullableStringFieldUpdateOperationsInput | string | null
    vlanId?: NullableIntFieldUpdateOperationsInput | number | null
    enableDns?: BoolFieldUpdateOperationsInput | boolean
    dnsServers?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumVpcStatusFieldUpdateOperationsInput | $Enums.VpcStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutVpcsNestedInput
    user?: UserUpdateOneRequiredWithoutVpcsNestedInput
    subnets?: SubnetUpdateManyWithoutVpcNestedInput
    creator?: UserUpdateOneWithoutCreatedVpcsNestedInput
  }

  export type VpcUncheckedUpdateWithoutUpdaterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    cidrBlock?: StringFieldUpdateOperationsInput | string
    edgeDataCenterId?: NullableStringFieldUpdateOperationsInput | string | null
    vlanId?: NullableIntFieldUpdateOperationsInput | number | null
    enableDns?: BoolFieldUpdateOperationsInput | boolean
    dnsServers?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumVpcStatusFieldUpdateOperationsInput | $Enums.VpcStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    subnets?: SubnetUncheckedUpdateManyWithoutVpcNestedInput
  }

  export type VpcUncheckedUpdateManyWithoutUpdaterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    cidrBlock?: StringFieldUpdateOperationsInput | string
    edgeDataCenterId?: NullableStringFieldUpdateOperationsInput | string | null
    vlanId?: NullableIntFieldUpdateOperationsInput | number | null
    enableDns?: BoolFieldUpdateOperationsInput | boolean
    dnsServers?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumVpcStatusFieldUpdateOperationsInput | $Enums.VpcStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PlaceUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPlaceStatusFieldUpdateOperationsInput | $Enums.PlaceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutPlacesNestedInput
    subnet?: SubnetUpdateOneWithoutPlaceNestedInput
    updater?: UserUpdateOneWithoutUpdatedPlacesNestedInput
  }

  export type PlaceUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    subnetId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPlaceStatusFieldUpdateOperationsInput | $Enums.PlaceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PlaceUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    subnetId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPlaceStatusFieldUpdateOperationsInput | $Enums.PlaceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PlaceUpdateWithoutUpdaterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPlaceStatusFieldUpdateOperationsInput | $Enums.PlaceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutPlacesNestedInput
    subnet?: SubnetUpdateOneWithoutPlaceNestedInput
    creator?: UserUpdateOneWithoutCreatedPlacesNestedInput
  }

  export type PlaceUncheckedUpdateWithoutUpdaterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    subnetId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPlaceStatusFieldUpdateOperationsInput | $Enums.PlaceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PlaceUncheckedUpdateManyWithoutUpdaterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    subnetId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPlaceStatusFieldUpdateOperationsInput | $Enums.PlaceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SubnetUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cidrBlock?: StringFieldUpdateOperationsInput | string
    availabilityZone?: NullableStringFieldUpdateOperationsInput | string | null
    gateway?: NullableStringFieldUpdateOperationsInput | string | null
    vlanId?: NullableIntFieldUpdateOperationsInput | number | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    autoAssignIp?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumSubnetStatusFieldUpdateOperationsInput | $Enums.SubnetStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vpc?: VpcUpdateOneRequiredWithoutSubnetsNestedInput
    place?: PlaceUpdateOneWithoutSubnetNestedInput
    updater?: UserUpdateOneWithoutUpdatedSubnetsNestedInput
  }

  export type SubnetUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    vpcId?: StringFieldUpdateOperationsInput | string
    cidrBlock?: StringFieldUpdateOperationsInput | string
    availabilityZone?: NullableStringFieldUpdateOperationsInput | string | null
    gateway?: NullableStringFieldUpdateOperationsInput | string | null
    vlanId?: NullableIntFieldUpdateOperationsInput | number | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    autoAssignIp?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumSubnetStatusFieldUpdateOperationsInput | $Enums.SubnetStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    place?: PlaceUncheckedUpdateOneWithoutSubnetNestedInput
  }

  export type SubnetUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    vpcId?: StringFieldUpdateOperationsInput | string
    cidrBlock?: StringFieldUpdateOperationsInput | string
    availabilityZone?: NullableStringFieldUpdateOperationsInput | string | null
    gateway?: NullableStringFieldUpdateOperationsInput | string | null
    vlanId?: NullableIntFieldUpdateOperationsInput | number | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    autoAssignIp?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumSubnetStatusFieldUpdateOperationsInput | $Enums.SubnetStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SubnetUpdateWithoutUpdaterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cidrBlock?: StringFieldUpdateOperationsInput | string
    availabilityZone?: NullableStringFieldUpdateOperationsInput | string | null
    gateway?: NullableStringFieldUpdateOperationsInput | string | null
    vlanId?: NullableIntFieldUpdateOperationsInput | number | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    autoAssignIp?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumSubnetStatusFieldUpdateOperationsInput | $Enums.SubnetStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vpc?: VpcUpdateOneRequiredWithoutSubnetsNestedInput
    place?: PlaceUpdateOneWithoutSubnetNestedInput
    creator?: UserUpdateOneWithoutCreatedSubnetsNestedInput
  }

  export type SubnetUncheckedUpdateWithoutUpdaterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    vpcId?: StringFieldUpdateOperationsInput | string
    cidrBlock?: StringFieldUpdateOperationsInput | string
    availabilityZone?: NullableStringFieldUpdateOperationsInput | string | null
    gateway?: NullableStringFieldUpdateOperationsInput | string | null
    vlanId?: NullableIntFieldUpdateOperationsInput | number | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    autoAssignIp?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumSubnetStatusFieldUpdateOperationsInput | $Enums.SubnetStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    place?: PlaceUncheckedUpdateOneWithoutSubnetNestedInput
  }

  export type SubnetUncheckedUpdateManyWithoutUpdaterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    vpcId?: StringFieldUpdateOperationsInput | string
    cidrBlock?: StringFieldUpdateOperationsInput | string
    availabilityZone?: NullableStringFieldUpdateOperationsInput | string | null
    gateway?: NullableStringFieldUpdateOperationsInput | string | null
    vlanId?: NullableIntFieldUpdateOperationsInput | number | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    autoAssignIp?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumSubnetStatusFieldUpdateOperationsInput | $Enums.SubnetStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resourceType?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resourceType?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resourceType?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserGroupCreateManyParentGroupInput = {
    id?: string
    name: string
    description?: string | null
    tenantId: string
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserGroupMemberCreateManyGroupInput = {
    id?: string
    userId: string
    joinedAt?: Date | string
    addedBy?: string | null
  }

  export type UserGroupUpdateWithoutParentGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutUserGroupsNestedInput
    childGroups?: UserGroupUpdateManyWithoutParentGroupNestedInput
    members?: UserGroupMemberUpdateManyWithoutGroupNestedInput
  }

  export type UserGroupUncheckedUpdateWithoutParentGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    childGroups?: UserGroupUncheckedUpdateManyWithoutParentGroupNestedInput
    members?: UserGroupMemberUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type UserGroupUncheckedUpdateManyWithoutParentGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    quotaConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserGroupMemberUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addedBy?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutGroupMembershipsNestedInput
  }

  export type UserGroupMemberUncheckedUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserGroupMemberUncheckedUpdateManyWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RolePermissionCreateManyPermissionInput = {
    id?: string
    role: $Enums.UserRole
  }

  export type RolePermissionUpdateWithoutPermissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
  }

  export type RolePermissionUncheckedUpdateWithoutPermissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
  }

  export type RolePermissionUncheckedUpdateManyWithoutPermissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
  }

  export type SubnetCreateManyVpcInput = {
    id?: string
    name: string
    cidrBlock: string
    availabilityZone?: string | null
    gateway?: string | null
    vlanId?: number | null
    isPublic?: boolean
    autoAssignIp?: boolean
    status?: $Enums.SubnetStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
  }

  export type SubnetUpdateWithoutVpcInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cidrBlock?: StringFieldUpdateOperationsInput | string
    availabilityZone?: NullableStringFieldUpdateOperationsInput | string | null
    gateway?: NullableStringFieldUpdateOperationsInput | string | null
    vlanId?: NullableIntFieldUpdateOperationsInput | number | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    autoAssignIp?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumSubnetStatusFieldUpdateOperationsInput | $Enums.SubnetStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    place?: PlaceUpdateOneWithoutSubnetNestedInput
    creator?: UserUpdateOneWithoutCreatedSubnetsNestedInput
    updater?: UserUpdateOneWithoutUpdatedSubnetsNestedInput
  }

  export type SubnetUncheckedUpdateWithoutVpcInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cidrBlock?: StringFieldUpdateOperationsInput | string
    availabilityZone?: NullableStringFieldUpdateOperationsInput | string | null
    gateway?: NullableStringFieldUpdateOperationsInput | string | null
    vlanId?: NullableIntFieldUpdateOperationsInput | number | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    autoAssignIp?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumSubnetStatusFieldUpdateOperationsInput | $Enums.SubnetStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    place?: PlaceUncheckedUpdateOneWithoutSubnetNestedInput
  }

  export type SubnetUncheckedUpdateManyWithoutVpcInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cidrBlock?: StringFieldUpdateOperationsInput | string
    availabilityZone?: NullableStringFieldUpdateOperationsInput | string | null
    gateway?: NullableStringFieldUpdateOperationsInput | string | null
    vlanId?: NullableIntFieldUpdateOperationsInput | number | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    autoAssignIp?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumSubnetStatusFieldUpdateOperationsInput | $Enums.SubnetStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}